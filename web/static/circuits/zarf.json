{"noir_version":"1.0.0-beta.17+0d6984c7c643b690e6559351f0cb36ce62b44b26","hash":"5804805709570765210","abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":1024,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"expected_email","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_path_indices","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2707472466662157409":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"6587586420081008171":{"error_kind":"string","string":"Merkle proof verification failed"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"8784292831194001448":{"error_kind":"string","string":"data length is too long"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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diUl6Hrbw663LbveJuhK5mFXMsuuZARdyT3sSm7ZlZygK4WHXSksu1IQdKX0sCulZVdKgq5UHnalsuxKRdD1jodd71h2vUPQldrDrtSWXakJutJ42JXGsisNQVdaD7vSWnalJeh618Oudy273iXo4h52ccsuTtCVzsOudJZd6Qi60nvYld6yKz1BVwYPuzJYdmUg6MroYVdGy66MBF2ZPOzKZNmViaArs4ddmS27MhN0ZfGwK4tlVxaCrqwedmW17MpK0JXNw65sll3ZCLqye9iV3bIrO0FXDg+7clh25SDoyulhV07LrpwEXbk87Mpl2ZWLoCu3h125LbtyE3Tl8bArj2VXHoKu9zzses+y6z2CrrweduW17MpL0JXPw658ll35CLrye9iV37IrP0FXAQ+7Clh2FSDoKuhhV0HLroIEXYU87Cpk2VWIoKuwh12FLbsKE3QV8bCriGVXEYKuoh52FbXsKkrQVczDrmKWXcUIuop72FXcsqs4QVcJD7tKWHaVIOgq6WFXScuukgRdpTzsKmXZVYqgq7SHXaUtu0oTdJXxsKuMZVcZgq6yHnaVtewqS9BVzsOucpZd5Qi6ynvYVd6yqzxBVwUPuypYdlUg6KroYVdFy66KBF2VPOyqZNlViaCrsoddlS27KhN0VfGwq4plVxWCrqoedlW17KpK0FXNw65qll3VCLqqe9hV3bKrOkFXDQ+7alh21SDoet/Drvctu94n6PrAw64PLLs+IOj60MOuDy27PiTo+sjDro8suz4i6PrYw66PLbs+Juj6xMOuTyy7PiHo+tTDrk8tuz4l6PrMw67PLLs+I+j63MOuzy27Pifo+sLDri8su74g6PrSw64vLbu+JOj6ysOuryy7viLo+trDrq8tu74m6PrGw65vLLu+Ieiq6WFXTcuumgRd4R52hVt2hRN01fKwq5ZlVy2Crm897PrWsutbgq7aHnbVtuyqTdAVeNgVWHYFBF11POyqY9lVh6CrrodddS276hJ01fOwq55lVz2CrvoedtW37KpP0NXAw64Gll0NCLq+87DrO8uu7wi6vvew63vLru8Juhp62NXQsqshQVcjD7saWXY1Iuj6wcOuHyy7fiDo+tHDrh8tu34k6PrJw66fLLt+Iuj62cOuny27fibo+sXDrl8su34h6PrVw65fLbt+Jej6zcOu3yy7fiPoauxh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QtlxqZddPZQ9MvWya4Sy41Mvu2Yoe1TqZVuHskenXnatUPaY1MuuHcpOSL3sOqHssamXXXacMjH1suuFsselXnb9UHZS6mU3CGWPT73shqHs5NTLbhTKTkm97Mah7NTUy24Syp6QetlNQ9lpqZfdLJQ9MfWym4eyJ6VedotwHuZk+KM9/zEd/h7/uDw/1nl3rL/EtCW14UXLhjfdGR6Onz2PeorTlgon6wjtslm+87e8XF3/+uTqytWVqytXV66uXF25unJ15erK1ZWrK1cXZnv8Q9uVzbr2zGJde2Wxrk5ZrGvvLNbVOYt17ZPFurpksa59s1jXflmsa/8s1pXrC3N12axrFus6IIt1dctiXQdmsa7uWazroCzWdXAW6zoki3X1yGJdh2axrp5ZrKtXFuvqncW6+mSxrr5ZrKtfFuvqn8W6BmSxroFZrGtQFusanMW6DstiXUOyWNfhWaxraBbrGpbFunL7OanVNfwf2q4RWaxrZBbrOiKLdY3KYl2js1jXmCzWNTaLdY3LYl1HZrGu8Vms66gs1nV0Fus6Jot1TchiXcdmsa6JWazruCzWNSmLdR2fxbomZ7GuKVmsa2oW6zohi3VNy2JdJ2axrpOyWFdu/ytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6kqtrmw+s5ib9rm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1eXXlXs3fK6uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXanUVV/+cDnUn66qKYn1WKzZ1h7ZV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","debug_symbols":"tP3bkvU6k56H3ksf9wGB3ADQrThWKNqy7OiIjm6HJK8The7dg0mOzOf7p4vFYo3pA/ej+X+VL3d4B4hMJv7nP/0f//V//3/+r//8r//+f/7Hf/+n//S//c9/+t//27/+27/96//1n//tP/7Lv/yPf/2Pf3/91//5T9v+/2vbsH/6T2v2f97RC0fhLFyJcytshb1QCrWw1GapzVKbpTZLbZXaKrUVahIYcTXQC0fhLIy49sK2xZF5oBV64Uhs8W9HoBV64SgMtRm4EvtW2ArjLFbg/m/XtqPs/3W1wF149UAr9MJdeEngLFyJuhW2woirgREhLonOwpVoW2ErrIM0KdRCK/TCUTgLV6JvhRE3boBroRV6YcSNGzDiyOL6DinUQiv0wlE4C+PI4g7FY39iK3zFbdsWN25/wl8cB78/4i+OmzTrEs+6xLMu8apLvOoSxzO+7H+9eB+vvv9pf52irxPG9ob2hv4GecN+3v11LnHWAf6G8YaI/DqdONsdYtjK66Ri0MrrjGLIBow3zDfsfyWvM43TCGhv2I9HXmcTw1FetyoGY8A64XWVklpST5IkTYqjirsd/y7uhCRpkiV50kiaSetNMU51v5t9j6f7veyaZEmeNJJm0nqTbEn7uen+PMT4PkiSNMmSIvI+XmNoB8UY1n3gxhDW/UFRS/KkkTST1ptiSB/UkuKo9qsb41n3qxHD+SBL8qSRNJPWm2IgH7Rr2H5NvSftGrZflxjatp9vjOyDdg3bzzfG9UEzadew/RrEALD96GME2H70MQRsfzZiDBykSaGxD+0YBrYfX4wD348qBoLvRxUjISiGve9HFaPe9yOI37qDdg3fjyWGzEGW5EkjaSatN8XA8f08YuQc1JNCYz+3FRr7ecSPnu/nEb95B42k0NjPLUbZeJ1bj1E22k67xug79SRJ2jWG7LRrDN1p1xi2064xfKeZFBqvo+otNOZOobF26kmSpEmW5EkjKX5A96M/fj+DWlJPignHfm4xVg+yJE8aSTNpvSnG6kGh0V7O22OmtI+DHvdiHwcnedJImknrTfs4OKkl9SRJSg1PDU8NTw1PDU+NEf/Oz+e2xxMyQ3edz+1JPUmSNMmSPGkkzaT1ppUaKzVWaqzUWKmxUmOlxv7c9v0Zjef2pHVSPLcntaT9b49nOf5dP5+9Hk9ra0k9aT+WeIL3Z+8kS/KkOJb9qW5xLON8Cns81T001vkUntSTdo3jedw18ins+RT2fAp7PoU9n8KeT2HPp7Dv092+/2KcJEmaFNd0Pz7xpJEUGvs1kPUm3ZJaUk+SJE2yJE8aSamhqWGpYalhqWGpEaNnn5L3GCn7hLvHSNmnyD1GykGSpEmW5EkjaSatN40tKTVGaozUGKkxUmOkxgiN/Z6PmbTeFCPvoJa0R9mn9z3G0T7B7TGO9vl4j3F0UEvaj2qfovcYRwdpkiXtR7VPGHuMo3063GMc7bPhHuNon8pKjKODWlJorJ1eGrLPYmX3/5MsyZNG0kxab9rHoOzzX9nH4Ek9SZJCQ3aypNDQnUZSaNhO6009NHynltSTJEmTLMmTRtJMWm+S1JDUkNSQ1JDUkNSQ1JDUkNSQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1NDUsNSw1LDUsNSw1LDUsNSw1LDUsNTw1PDU8NTw1PDU8NTw1PDU8NTw1BipMVJjpMZIjZEaIzVGaozUGKkxUmOmxkyNmRozNWZqzNSYqTFTY6bGTI2VGis1Vmqs1FipsVJjpcZKjZUa662h25bUknqSJGmSJXnSSJpJqdFSo6VGS42WGi01Wmq01Gip0VKjpUaOc81xrjnONce55jjXHOea41xznGuOc81xrjnONce55jjXHOd6jNqXn+oxQudO8b/2nTTJkuII1k4jaSatNx0jNKgl9SRJ0iRLSg1LDUsNSw1PDU+NGI1t22n/29Z22v+2yU7rTTHyDmpJPUmSNMmSPGkkpcZIjZkaMzVmaszUiFHWdKf429evgcaIavs9ihF1UE+SJE2yJE8aSTNpnWTbltSSepIkaZIlRbzXk2MxUtrcaf/bvu0kSZpkSZ40kmbSelOMlINaUmr01Oip0VOjp0ZPjRgpve203hQj5aCW1JMiXt8p/lZ2ir993SOLX7qDWlL87X6FYhwdpEmWFMe3X78YR/tqlcU42lepLMbRvkxlMY4Oakm7xr5AZTGO9vUoi3F0kCV50kiaSetNMY5kP7cYRwf1JEkKDd3JkjxpJM2k9aYYbwe1pJ4kSakxUmOkxkiNkRojNWJs7YtyFr9g+zqaxdg6aCTNpPWmGG8HtaSeJEmalBorNVZqrNRYbw3ftqTQmDv1JEmKKK/nwOP3aF+18xhl+xqhxyg7SJL2o9pX4zxG2UGeNJJm0npTjLKDWlJPkqTU6KnRU6OnRk+Nnhoxova1P48Rta/4ecwnDxpJM2m9KUbZQS0p4tlOkqRJluRJI2m+KcbRvjLoMWZ0vzMxZg4aSTNpvSnGzEEtKeLtdzDGzEGaFBr7XY0xc9BI2jX2FUSP8bGvIHqMj4MkyZL2KPu6oceoCIpfnH0F0eMX56CIsp/vzL+NZ3xfbfV4xg+SJE2yJE8aSXHMsXC/ThrxjB/UknqSJGmSJXnSSJpJqdFSo6VGS42WGjEq9jXREaPiIE+KeHtyIJ72fZ10xNO+r7aOeNoPsiRPGkn78e2rqCOe9qD4TTmoJfUkSdIkS/KkkZQakhqaGpoamhqaGjEq9hXdEaPiIE+KeLonUeJvbaf427aTJXnSSJpJ600xKg5qSRF5v1YxKg7SJEvypPGm+NXYV/1GjACP5I4mWZInjaSZtN4U42NfmxsxPg7qSbvGvg434l3oIEvaNfa1uRG/Gvva3IhfjYNakiTFX+zXOcbMQftR7St3c3v/xTye+6CRNJPWm47nPqgl9aTQ9Z00yZI8aSTNpPWm+DU4qCX1pNToqdFTo6dGT42eGjE+9nXHGePjoJYU8eZO8bd7ri6e+331csZzHxTP/UEtqSftx7evMc547g+yJE8aSTNpvSnmXAe1pJ6UGpYalhqWGpYalhoxUva1zRkj5aCWFPFkp/jb/SmJ34V97XXGWDioJfUkSdIkS/KkiLzfjxgfB603xfg4qCX1pIi3362YQe0rhjPGQlCMhYNaUk+SJE2KePudjpFy0EjaNfaVxRm/Ljut+HU5aNfYVxtX/JKsyNJakifNN8WY2VcgV4yZg/aj2lcbV8u/iOd+X7dd8dwfJEmaFGq+kyeNpJm03hTP/UEtqSdJkialhqSGpIakhqSGpkaMj32tdMX4OEiSIt7cKf72dcVXPPf7iuuK5/6gniRJmvQ6Pt1XPtf+3J80kmbSetP+3J/UknqSJGlSanhqeGp4anhqjNQYobHf1dGTJCni7c/BiL/dn4MZf7s/YbMnSVKsnu9/EeveB3lS5CYiykxab1oRb79qS5I0yZLiqPY7uEbSTFon7bUZO47AVhgyMzB0VqAWWqEXjsJ5XowXrsS2FbbCXiiFWmiFXrjH3Vdp2rb/4LyxFfbCPe6+jvNCLbRCL9zPokUh1T4A37gSJdSivEpCLQ5HQs0CQy2ur2ihFXphqMVVl1m4EnUrDLW4LdoLpVALrdDPwfnCUTgLV+IxfA9shb1QCrXQCudpqm2L0dniv8bwPFEKtXA/3h43K4boiaNwFu5Xp4dEDNMTd7V+1OPtaj3uUIzUE7XQCr3w/Yt5FPe9cSUeP20HtsJeKIVaaIVxFgeuxLUVtsI4i3iiYrSfqIVWGGcRT1SM+BNnYahFVVCM+R4VXDHme1T5xJiXKNWKMX+iFlrhriZRyhVj/sRZuBJjzEuUesWYP7EXSqEWxowwjuyYdh44CmfhSjymnge2wl4ohVoYceN4Y3TLUSnYCnuhFMbxRqVgjO4TvXAUxtWJ2rUY3QfG6I6yrahe0qNuK0b3iVKohVYYry1HsFE4C1dijG7PasU39kIp1MI4i3hg4uf4xJUYP8gnxlkcVWW9UAq1cD+LqCeLYo43jsJdTY96x10tKr+isEmj4CsqmzQqvqK06Y1SqIWhFicUY/7EUTgLQy1uS/yYn9gKe6EUxjXLcsc3euEonIUrMSbAJ7bCXiiF8cp3YKwp7VcnSkJ0X0pqURPyxl4ohbFII4FW6IWjcBauxLYVtsJeGFd9BnrhKJyFcdWj0jB+0U9shb1wP4s4+SgoeaMV7mpRRBc1JRq1c1FUolEoF1UlGpVyUVbyxlbYC0PNArXQCr0w1DxwFq7EGPMntsK4ZnHox3rkgVpohV44CmfhSrStsBXGWcRDEPPvE71wFMZZxB2KMX9gjPkTW2EvlEIttEIvjHxI3KEY3fGARxXKG3vhHteP6lIttEIv3M/Cj7j7WURZYlSjaNQWRjmKhstFPcobQy1uS4zuqBnrUwut0AtH4SxcifE7f2KoxcnH7/yJUqiFoRaPffzOnzgK34mlFjUtB0YBi0bBWFSw6DhqbrXQCve4Iwpr47f7+LMYxzGJjFoUHRE3xvGJo3AWrsQYxye2wl4oKRG/xydaoReOwlkYavvdjNKUN7bCULPAuA4eWGpSalJqUmpSavGWfGC8Jp/YCuuaxa/0vjLVoijljaMwrtnxb1dijNh4kzgqU07shVKohVbohaNwJsZ6UbwaRTmKxiwo6lHeqIX7Wczj30bceGAyM96OopQTV+KRHD+wFfZCKdTC/erMA2fhSowRe+J+j+OTlyhGeaMU7mcxjyJxK9zvRUzHoyLljbNwJcaIPbEV9sJQi4saIza+iYnKFI1PXqI0ReOLlqhNeeMsDLX9Ukd5yhtb4a4WX79EhcobtdAKo+xhBo7CWbgSj0KVA1thL5RCLRxntV6L0hSNb22iNuXEGPMn7mcRX9VEecobpVAL4yyiej9+u+M7j6hR0fiMJYpUND5jiSqVE2PMx/coUaei8RYahSpvlEIttEIvHIWz8KVm8RWL7mP+ja2wF8qOLVALrdDPEscW1S8nWsSNa2atsBdG3LhQ++i2WAOJOpaoCn29BsS/PT50kEIttEIvHIWzcCUeRaEhcVSFHtgLQ+1ALbTCUIubNUItbtYItbi+o85iltostVlqUZt9ohZaoReOxCgijZ+6qIWxdmAvlML9LGKpJ+ph3uiFo3A/i1gLipoYi7WgKIqxdnxMEmoe2AtDbQSG2gy0Qi8chbNwJbatsBWGWnx20qRQC61wV4u1laimeeMsfFeSNzvKvA/c48biS5TPvNEKI+7xb/fjjXlJlMYcZfhRG2Ox2mHihaNwFq7EGIUntsJeKCkRZdonWmGoxR3SUTgLQy1uVozNWDqJ+hmLpZMooDmDWalZqVmpHZ9DHDgKZ2F+mWDHJxHjf/3zP8n+eYUcR7rOctaTZtJ603GU6yxnPaknSZIm7Rd/X6SJ+cJJI2kmrTftx3ZSS+pJkqRJqeGp4anhqeGpMVJjpMZIjZEaIzVGaozUGKkxUmOERj/LWU9qST1JkjTJkjxpJM2k1FipsVJjpcZKjZUaKzVWaqzUWKmx3hoxXzipJYWGnOWsJ4WGnuWsJ4WGn+WsJ82k9aZwl4NaUk+SJE2ypNRoqdFSo4XGOMtZTwqNeZaznhQa6yxnPWnX2F9lY65w0q6xL4LETOGk9aZ9nmD7mkRME07aNfbVoZgknLRr7KtAMUU4yZNG0kxabwpfOqgl9aS8HzEzOMiS/H1nYpwfNJPyfljeD8v7YXk/LO+H5f2IsapBlhRnNM4S15NmUpzRPEtcT2pJcUbrLHE9SZMsadfYF2OOn/2DZtJ6U4zGg1pST5IkTYq/bWcR6/HfjnFkZxGr7cs9x2/2QSNpJq2Tjt/rg1pST5IkTbIkTxpJMyk1Wmoc42idxa4nSZKez/PxA63vYteT3s/48et80PsZj9/mk1pST4rjk7NM9aQ4y73wMUbAQZoUZ7kXQ8YIOGgkxVn6Wc56UIyAg1pSaIyznPUkTbIkTxpJM2m9KUbAQfG38yxEPf5b/Ebta8ZRiGp7cVYUop4kSZpkSZ40kvYj8HYWoh4Uo+KgltSTJEmTLMmTRlJqjNSYqTFTY6bGTI0YFfsSVxSsnhQachasHhS/PfuiV5SanhT/q52lpietk6LU1PZVsCg1PaknxRFEIaomWZInhUaUpM6k9aYYFQe1pJ4kSZpkb4qnfV8Ai7LS87/t/+u+eBVlpSeNpJm03hS/Cwe1pJ4kSZqUGpIakhqSGpIamhrxtO/vIVFCavs82g9v3//Xw9uDWlIcy16YGd5+kCZZkieNpJm03hTj46CWlBqeGp4anhqeGp4anhqeGiM1Ynzsa29RiHqSJGmSJXnSSJpJ600xPg5KjZkaMzVmaszUmKkR42NfEPSYwx203hRzuINaUvztu2DV9iW7KFi1fYksClZP6kn7sewrVlGwepIledJ+LPvCVRSs2r5YFQWrtq80RcGq7QtNUbB6Uk8KDT8LVm2Os2D1JE8aSTNpvSlG1EGhMc/C1pMkSZPimupZ2HrSSAqNdRa2HhTj7aBdY1/+iMLWkyRJkyzJk0bSTFpvivF2UGpoamhqaGpoamhqxGjc17GinNX2VaoRI2/ZWdh6kieNpJm03hQj76CW1JMkKTU8NTw1PDU8NTw1YuStKHttST1JkjQpooyznNXWPMtZfdvOctaTNMl2amc560kjaSatnd4lrr7JWeLq+9rVWKFhZ7HrSZoUGn4WwPq+ehQFsCfNpHXS3LakltSTQmMvGNw0yZI8adfYF8ajePakXWNfGori2ZN2jfYunj1p19jXgqJ49iRL8qSRNJPWm/qW1JJ6Umr01Oip0VOjp0ZPjZ4akhqSGpIakhqSGpIakhqSGpIakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhojNUZqjNQYqTFSY6TGSI2RGiM1RmrM1JipMVNjpsZMjZkaMzVmaszUmKmxUmOlxkqNlRorNVZqrNRYqbFSY701onz3pJbUkyRJkyzJk0bSTEqNlhotNVpq5DhfOc5XjvOV43zlOF85zleO85XjfOU4XznOV47zleN85ThfOc7XMWr1LPP1fc05ynx9X1mPMt+TZlIcwbvM96SW1JMkSZMsyZNG0kxKDUsNSw1LDUsNS41jNI6zzNf3xewo8/V9JTrKfE+SJE2yJE8aSTNpvSlG3kGpMVJjpMZIjZEaIzVilO1L3lHw6/uKdxT8+r7gHQW/J1mSJ42kmbTeFCPqoJbUk1JjpcZKjZUaKzXWW+Oo9/Wj0jDGylFIGIOlH1XAXjgKZ+FKjBFzYivshVKohaXWSq2VWiu1Vmq91GLwxIp81Pu+UQq10AojblSexk9g1DVGDa/LUeQrhVq4R4jav6jhfeMonIX78UbtX9TwehT8RQ2vnx3bQu2o7JVCLQy1rOF1yRreN87ClRhjTrKG9429cFeLOqCo4X2jFXrhrhYleFHZ+8aVGKNUs973jb1QCrXQCr2w1LzUvNRGqY1SG6UWw1OPKuCIkDW8J8bvoGYN7xt7oRRqoRV64SgstVlqq9RWqa1SW6UWY1izsveN/sYo3PWj0jB+5/Qo540/k38+S3Tf6IVxkEe97yxciTF4T2yFvVAKtdAKvbDUWqm1Uuul1kutl1oMUz3qcvcIR4ljzF4PjOnria2wF0qhFu5xowwwSnTfOApn4UqMwXtiK4xgcX1jFEadYNTanhij8MRW2AulUAsj7lF264WjMNTiIYhReGCMwhNDLR6NGG921OVaoRfOwj3YUVgag+zE/SCjli5Kad+4B/OjGLcixGiJisuofn2jF47CWbgSY7ScuJ9F1OhF9esbpVALrdALR+EsXG+MStk3tsJeKIVaaIVeGGpRPRiD7MSVGMPpqCmMgXOUAcbAOaoSY+CcOAtXYgycE+N4syb2jVKohVbohaNwFq7EGGQnlpqUmpSalJqUmpRaDLKoKYya2DeuxPgtjPqMqHP1KDCIOlc/aiBjkJ24EmOQndgKe6EUamFIxJWMQXbiKJyFKzEG2Yl73CgvjDJWj/LCaK/2xlm4EmNkndgKe2HEjackxtuJVhhq8ezE+96JszDU4jTjRy2K+KKM9Y1a6IX7n0WVX1SpvnE/yCi2i3rU89/GGIruoNE47Y2tsBdKoRZa4X4MR2FejKETZ+FKjB+qE1thL5RCLbTCUmul1kqtlVovtV5qMd6O2r8YbydqYcQ9yk0jwlFuGhGiKjHG0IlSqIVWGMeb9ahvnIUrMX6oZtajvrEXSqEWWmGpaalpqWmpWalZqcXQi7LFKDl5oxbucddRTbpHWEfdaESIeskYWSdqoRV64SichSsxxluUF0Y1yRt7oRRqoRXucddRFhoR4sbGyDpRCrXQCr1wFEbceDRi6B0YQ+/EUDtKSHuhFIZaFpZ61CpGmcgb1xujPOSNrz8bW9aNvtF3jPK3rf4sxtBZ32mFXjgK5x5B/vmsBT1xH0NvbIW9UAq10Aq9cBSWWi81KTUpNSk1KTUJtaiiFCv0wogbNZAaEaKQUCNCnLFqoRV64SiM443CR12JthW2wl4ohVpohV44CkvNSs1LzUvNS81LzUMtHgK3Qi/c40YFedSDjKN0ckSEo9TTCr0wshfHn83ClRhpvRNbYS/cJY7iy328vdEKvXAUzsKVuI+3N7bCXlhqq9RWqa1QiwdmjcL5xqgoGWctaEQ4CkAjgvzzWer5xpHY4siiIrDFMRxFnVoYEbJ8c1T55qjyzXHUYcaA7Fm++cb9yI66xhiQR11jDMhYGYmizjdaoReOwlm4EmNAntgKe2GpSalJqUmpSalJqUmpaalpqWmpaalpqWmpaalpqWmpaalZqVmpWalZqVmpWalZqVmpWalZqXmpeal5qXmpeal5qXmpeal5qXmpjVIbpTZKbZTaKLVRaqPURqmNUhulNkttltostVlqs9Rmqc1Sm6U2S22W2iq1VWqr1FaprVJbpbZKLcZ8LB5GCc2Ib56jhmbEimEU0YxYEIwqmjf2Qinc48aKYVTIjFgxjIKX87/GQI/Fw+jH9sZZuBJjoMc6YvRke//XXiiFWmiFpdZLrZdaDPRYn4wqmhGri1FG88ZeuKvFkmJU0rzRCr1wFO5qsbIX5TQnxkA/cVeL9b5o6DZiySs6uo1YTYqWbuPYaiEG+rHDQgz0E0fhLFyJMdBPbIW9cFc79muIgX5u2BBqcTgx0GN9J4pz3jgLQy1udwz0WMmJAp3zIYiBfqIURty4xzGkT5yFETeuQwzeeOWKYpsR6ztRWTNiUSdKa06MAXliK+yFUqiFVugpEQPyxFkYanGhYkCe2ApDLS5fDMhYZom2cuNs8F9nsUptldoqtRiQxy4WMSBPbIW9UArjp9kCI64HzsKVGD/YsagTBTpv7IURdwXmRGAcP+MHeuEeN1ZGoibnja2wF+5xY+kk6nLeaIVeuJ9FrK1Ebc4bQ22/1FGdM2JdI8pz3tgLpVAL4yxCIsbxiaNwFq7EGMcntsJeKIVxFnEvYsSeOAtXYozYWC8ZMWJP7IVSGGcRdyhG7IleGGozMNTiFsaIjUWSqOsZsUgShT1v7IVSuKvFq30U97zRC0fhrhaLDlHgc2L8NJ/YCnthzMHj3OKn+UQr9MJROAtXYjjBia2wF9r7LTQqf0asgUTpz4kxuk9shXG8cbNidJ+ohVYYVyfUYnSfGGpxh2J0x/pDVAG9sRX2QinU9/rDUQp0oheOwlm4EttW2Ap7YZzFCvTCUTgL97OId5yoAXpjK+yF+1kcEjHmT7TCXS1ezKMUaMRiRtQCjVjMiGKgEUsRUQ30xlbYC0PNA7XQCr0w1EbgLFyJMeZPbIX9vVJ2lAadqIVW6IWjcBauRNsKW2GsZcZDEKN7HTgLV2KM7hPjeONmxeg+UQq18HW8M9ZWogrojWPHuEP76J6xOBCFQCfuo/uNrbAXxkLugVpohV44CmfhSoxc6ImtUHe1eGCmFXrhKIyziCdqrsS1FbbCOIt4ovYx/0YtDLW4QyvU4tFYoRY3YIVaXN+13hgVQW9shbtaLFBEUdAbtdAKd7X4mYnCoDfOwpW4j/k3RsphBPZCKdRCK/TCUTgLV+KR8zkwVtIPjHRrnGaP4+2Bs3AlylaYydJVydJVydJVydKjnOhELxyFszBTs1E/NGMFIwqI3qiFVhhXXQNH4SxciRZnYYGtsBeGmgeGWlwoC7UZGGpxzWwUzsKVuI/5GasoUXr0xl4ohbtaLLNE+dEbvXAUzsJIiMdBHjUNB7bCXiiFWmiFXjgKZ+KMs4iHYPZCKdTCOIu4QzHmTxyFs3Alxpg/sRX2QimMWp+41DG6o/QoapPeuE7s0aFw7h/i9qhYemMvlMI4ixEYZzED4yxW4K62v673qGN64662v7n3qGOa+5t7jzqmN/ZCKdRCK/TCURhqErgS+1bYCkNNA6VQC6MuKA49nODEiBvXLMa8xCWRVtgLI25cKPH6s6iwCoxxLHH5YhyfqIVW6IWjcBauxPg9PiTi9/jEXiiFWmiFoRZ3M8bxibNwV9O4JDGONW6sl5qXmpeal5qX2lFHeOAonIV1zeJXWuN27yP2jVq4XzONe7yP2DdG3OMfzMKVGL/SJ7bCXiiFWmiFUZkZtztGrMZjFCP2xFYYZxEndBTsxn07KnYPtEIvHIWzcL3xKF46sRXG1fFAK/TCUbjf493PehQvnRgj9sQ4i4gbI/bEuBcrUAut0AtH4SxciTFi95+6HsVLc1/16VG8NPdVnx79Bee+6tOjv+AbrXBX21d9enQdfOMs3NX2taAehU5vbIW9MO7QgVpohV44CmfhSjzqgQ9shXp+H9Kj5mnagV44CuMs4qrHmD8wfrtPbIVxFnFR47fb46LGb7fHRY3fbo+LGmP+xF3N40rGmPe4ZjHmD4wxf2Ir7IVSqIVWGGpx8vHbfeIsXIkxX/d4PGO+fmIvlPOjmt6Ob24OjLhxzcYsXIkz4sa/jV9pjwsV363FBnhRNTVjv8eomnpjK+yFUqiFVuiFIyXim9AT1xujamrG9pJRNfXGXhhqPTDUjj8LNQ30CjYKZ2GpxVdvJ7bCXiiFWjjOj/R61FLN2LQyaqlOjHF8YpxF/NsYxydKoRbGWczAuGYrcL+b566ru9qxaWWM4wNjHMd2lFFLNWccZIzjE6VQC63QC0fhLAy1uL66FbbCXhhqFqiFVujnl409+gueGCM2tqCMAqo545Ic353GuR0fnh44C+PIIkKMzRNbYcSNKxljM3aC7Mf3pxHh+AD1wFLzUvNSOz5CDTy+Qj2wFfbC/Sxit8koq3rjKJyFKzHG5omtsBdKXp2YV59Y1yzm1SeGWhxOzKtPDLW4sTG6T2yFoRZ3M0b3ibtabHcZPQPfGOcW9y1m2yfOwlDbDyfquWZ4VNRzzX0xo0c913G8Uc/1Ri20Qi8chbNwJcZv94n7OA6Xi8qtta+X9KjceqMXjh1b4CxcibEh8r5e0qNya+1rFT0qt94ohaGmgaFmgaHmgaNwFoZaHHpsjXxiK+yFoRYXNbYyP9EKvXAUzsKVqFthK9xHix0YceNKxpbnJ47CPW6LKxm7nh8Y256fuMdtcSVj4/MWVzJ2Pj9RC3e1FlcyNj9vcSVj9/OYP0QfoTeuxNgAvcWVjB3QT+yFUhhqcSVjF/QTvXAUzsKVGFuhn9gKe+HuMDGXix5CKyan0UTojbMw4saVjO3PT2yFe9weVzJ2QO8RN7ZAP9EKd7WYpEdx2OpxJWMb9B5XMvZBPzA2Qj9xV4u3jigOe6MUamGoxZWM7dBPHIWzcL0xegu9sRX2wlDz//XP/6R7o6oeGbD9AkT+64D+BnmDvsHe4G8Yb5hvWCf0d+T+jtzfkfs7cn9H7u/I/R15H6vxZEciKx7syGOdpEmW9PrTeL4jh3XSTFpv2gdjPPGRvzqpJ+0aFqRJluRJ4037IIyHPjJU8WxGgiqepshPneRJr7+N5yeSUyetN0UzsYNaUk+SpF1DgizJ3xQtAOOMYg/oONLYA/qg/S/imGMP6Djm2AP6oJm03hRN/g7aj2oG7UcVd+vYTTZI97agQZbke3/boJE0k9abjr34glpST5IkTbIkTxpJM2mdNLctqSX1JEnSJEvaNTRoJM03HXuNBe3/zYPWm6LJ/UH7vxtB+7+bQa9/F8sfkdg5qSX1JEl6HUuskkSeJtYq5tGkOqgl9SRJ0iRL8qTxpv2HJF7j4xPseF+PT7BPGkkzab0pWk0ftB9LnGW0rV1B+8whjj6mjAdZkieNpH0kH1HWm/Zn/KR9rhj36Gg7FyRJmmRJnjSSZtJ609F2Lig1ZmrM1JipMVNjpka0J4mnJFr6xNU92mAFaZIlxaQ5aCTNpHVSJFJOakk9SZI0yZI8aSTNpNRoqdFS42hUEhQvgUH7usT+dB4pkINiVSKoJ0mSJlmSJ42kmbTedDRECEoNSQ1JDUkNSQ1JDUkNSQ1JDU0NTY1IZfag/d/t9/f4ZFqDWlJPkiRNsiRPGkkzab0pSu89qCX1JEnSJEvypJE0k9abRmqM1BipMVJjpMZIjSNduVOseMazEQueFiRJmmRJnjSSorghaL0pChMOakk9SZKiBjDIkjxpJM2kdZBE8uKkltSTJEmTLMmTRtJMSo2WGi01ouyoBUmSJkWNX5AnjaSZtN50FBMGtaSeJEmalBo9NXpq9NSIOgTdKcoQDmpJPSlq7II0yZI8aSTNpPWmKD7woKgLCupJkhSFKEGW5EkjKUoGgtabovjooMhGB/UkSYo0ZVDkwIJm0nrTkYwMilxOUCxvB0mSJlmSJ8UqbdBMWm+KZcyDWlIsYgZJkiZZUiyEBY2kmbTeFMsmB8VyQpAkWZInjaRYrAhabzoWRoJaUk+SJE2KN+MgTxpJ+2tHXN14C9opkhYntaSeJEmaZEm7hgeNpJm03hSvTQe1pJ4kSbvGCLIkTxpJM2m9KV6gDmpJPUmSUqOnRk+Nnho9NXpqxDLIDGpJPUmSNMmSPGkkzaT1Jk0NTQ1NDU0NTQ1NjVj22J+DyEK0fSlJIt/Q9kUjicxC2xeNJDILb1yJ+0BsW9xbb4W9cH+325eSJLIFbV9KksgWtC1uYUwytziaERHicEa8lMbhDCmM19I4smGFXjgKd7UWB7mPtxP3AffGVhhqcbxTCrXQCkMtTmiOwlm4EleoxRmvVtgLpVALrdALI+5+zSLf8MZW2AulMILNQC8chbNwJbatsBX2QinUwlJrpdZKrYXaCFyJfStshb1QCiPuClyJ+0hr++u/RDrhjb1QCrXQCr0wFjha4CxcibHGsS8TSKQT2r4mIJFOaPuigEQ6oe1rARLphNbjXsSiRo/roLMw4sZZxFrHia1wjytxZLEEcqIWWqEXjsJZuKtF7+9IPbyxFfZCKdTCuGZxL2IcHxjj+MT+HvPx7XaLDt3x7fYb43jjmsXgPXEUxvEeEVZiDN4T43jj+sbgPTHU4lLH4D3RCv1tQZFkeGMaU6QTDu+LdEKTOKEYpidqoRXGWcTdXHEWcd/2X8+mcdVj8AZGOuGNrTBWyHqgFGrhrrZXR0ikE944CkNNA1dijON9uUHi8/A39sJQ80AttMJQG4GhtgJ3NYtDj3FscZAxji0OJ8axxTHEOLZQi3FsEbdrYSwAhkSM7hNH4SxciTHmT2yFvVAKI+4MjLhxFjG6T1yJMbo9zi3G8f5eKpFOeKMVemKM2BN7YUWIEetxdWLEnuiF+5F5XLMYsSeuxBixHlcyRqzH5YsR63GaMWI9TjNGrMcJxYg9cVcbcW779PeNs3AlxpA+sRX2QinUwogbZxzj+MSVGOP4xPNVVo7Pxw+SJE2yJE8aSTNpvSmGb7z5RQ6gxatV5ADeaIVeOApn4Xpj5ABavH9FDuCNvVAKtdAKvXAkxkCNN7LYVOCNvTDiemBEGIFxZPsZx3flb4wIK7AXSqEWWqEXjsJZuI61KIkPyM9DiFEW72/xAXmLF7j4gPyNXjgKZ+FKjLF34n4S8ZYXH5u/UQpDLe5KjMjj3GNEnjgS45c1Xvvis/I39kIpPNcLRc2SPGkkzaT1pmhoe1BL6klxUQ6MixK3MwbiibNwJR4LsQe2wl4YBx93IwbiiVbohaNwFq7EGJ4ntkI9FsQlviuP36T4rPyk8aZIMsRfxG9pvKvG1+MtXjjj6/E3aqEV7ocar5/x9fgbZ+F+qHtVgcQmBW0vD5D4pvyNvXBXi3fP+NK87TUBEl+at3iDjC/N3zgKZ+FKjCEaL3axX0GLd6jYsOCNUhhqK9AKvXBPB8ULV3yV/saVGJsKndgKe6EUaqEVRkYsLlQfhWdWROKj9IP2X9KTImhcO9FCK4ygcUUlDjauqMZhWWBEiGCxz9CJVuiFo3AWrkTbCuMixLWL9F+8Eh57B8Ub37FLULzQxefgb+yFUhgR4iwiu3eiF47CWbgSIwF4YstjiD3ATpRCLbRCL6yziOTgiSsxUoHHpY7dvtqBETeueuz2daIXjsJZuBJjD7AT4yziQV+9UApDLR7/FWpxW5YXjsJQi5u1IvO636z48LvHa1N8+P3GXiiFWrirxStWfA7e4xUrNlF44ywMtf2EYh+FN7bCXhhqHqiFoTYCvXC8H3A/huuBK/EYrge2wl4ohVpohXEWM3AlylYYZ7EC97jxQhdfkb9RC60wktYtcBTOwpW4//z2eEmLr8jf2AtDLe5FjO54HYuvyN/ohaMw1OI0Y3TH61h8Rd7jxyK+Iu9hQfEVeY83qPiK/I27WrwrxVfkb4xpctB60zFJDoppUFBPkiRNsiRPGkkzab0pxnn8HMbWDW/UQiv0wlE4C/crEr+e8ZX5G1thL5RCLQy1uCsx+k8chaEWtyJG/4Ex+k9shWdBiPixPBWkSZbkSSNpJq2TxrFatVMMuHixiqKXN1qhF47CWbgSY8Cd2Ap7Yan1Uuul1kutl1ovtRhw8e4WFTF9T0tKFML0eGGLSpg3zsKV/zbG04mtsBdKYUkcu/Id6IUj8XiQLHAWrsTjQfLAVtgLpVALrTAepBE4CmdhqO1DdhwP0oGtsBeG2grUQiv0wvXGqBx5434MseAQnxj3vWxB4hPjN/ZCKdRCK/TCiNsDZ+FKjOfsxFbYC0NNArXQCr0w1PZhFvUnPV4LogDljVKohRHMA2diPFwnxp+NQC+ciWGqJ8a/nYFaaIkxtYnXvCj8eGMvlEIttEIvHIWzcCXOUpulNkttltostVlqs9Rmqc1Sm6W2Sm2V2iq1VWqr1FaprVJbpbZKbaVaVI+8sRX2QinUQiv0wlE4C0utlVortVZqrdRaqbVSa6XWSq2VWiu1Xmq91Hqp9VLrpdZLrZdaL7Vear3UpNSk1KTUpNSk1KTUpNSk1KTUpNS01LTUtNS01LTUtNS01LTUtNS01KzUrNSs1KzUrNSs1KzUrNSs1KzUvNS81LzUvNS81LzUvNS81LzUvNTKS1Z5ySovWeUlq7xklZes8pJVXrLKS1Z5ySovWeUlq7xklZes8pJVXrLKS1Z5ySovWeUlq7xklZes8pJVXrLKS1Z5ySovWeUlq7xkpZfoll6iW3qJbukluqWX6JZeolt6iW7pJbqll+iWXqLbVmqt1FqptVJrpdZKrZVaK7VWaq3UWqn1Uuul1kutl1ovtV5qvdR6qfVS66UmpSalJqUmpSalJqUmpSalJqUmpXZ6yf/653+yqAl/zz9z9plzz5x59pzl5hw3Z7g5v83Zbc5tc2Zb89o35Jz2HVnfkY+pZtt3EP2nY3YZdhT7I7Y39De8Z6v2nqvae6Zq73mqvWeplgHf82F/z4b9mAu/ronHNXnfkLz5eevzxudtz5uetzxveN7u+uHIIZoDNIdnDs4cmjkwc1jWD3wOybyxb8hHKB+gfHzy4clHJx+cfGzyoXlHzp+D/DHIn4L8IcifgfwRyJ+A/AFI+0/zT+tP40/bT9NPy0/DT7tPs0+rT6NPm0+TT4tPg097T3NPa09jT1tPU09LT0NPO08zTytPI08bTxNPC08DT/tO807rTuNO207TTstOw067TrNu6dUtrbqlU7c06pY+3dKmW7p0S5Nu6dEtLbqlQ7c06Jb+3NKeW7pzS3Nu6c0trbmlM7c05pYDs+XIbDk0W47NloOz5ehsOTxbjs+WA7TlCG05RFuO0ZaDtOUobTlMW47TlgO15UhtOVRbjtWWg7XlaG05XFuO15YDtuWIbTlkW47ZloO25ahtOWxbjtuWA7flyG05dFuO3ZaDt+XobTl8W47flgO45QhuOYRbjuGWg7jlKG45jFuO45YDueVIbjmUW47lloO55WhuOZxbjueWA7rliG45pFuO6ZaDuuWobjmsW47rlgO75chuObRbju2Wg7vl6G45vFuO75YDvJ0j/PULNPZfoPj+IZZO4vuHg45vfOzcgu6knvReQDnegQ+yJE8aSTNpvelYpxnnFnQn9aTQmOcWdCdZkieFxjq3oDvpvYxyvPMepEnvvzjfRrdzU7hYFTnfOtu5KdxJM2m9KVdiVi7EnO+b/dwU7iRNsiRPGkmhIeemcAcdHiTnpnAnhYae277FIsn5Chk0k9ab5L1Wcr4o+rk93EnvhZLzdW+cm72dNJLi381zO7eDjnE/X0/S3J+kOK39YT/+z55s2x+3V3r0n2Oeo69/uN7/0I7/afyv13/8t//4L//yP/71P/79P/+P//Zf/+v+D97/4b//03/63/7nP/3f//Lf/uu//49/+k///v/827/98z/9///l3/6f+Ef//f/+l3+P//s//uW/vf7X1238r//+f7z+7yvg//mv//Zfd/pf/1x/vX39p3NPoMQfv9aN8s/b+OPv29d/Hxu5xN+/Fr8f/H30oI+/H2179Pf9/ff9S/2L84+vcOPvXw/ak7/fn4bj78f66u/967/fd616n8G+VxXOYd49hrZXu71j7IViGcP6HzHm1XFEE4jzOF729SRGj2rZI8beyeVZDEUM10cxZM+2nzFU+7MYe27sHcPkqxj7GX8VpEduJWLsLRQqhN0Osbc5zeMYrwRKBvEfxIhubmeMiXHyoxh5Lnuv0/5FjMtLap6P6evl88tb2y6C9KicPC9pw539h1NZV4/6wqO++Kj/IMgrxZnjdv+u/qsg/cK8XnP9PJBtra+ej8sQUQR7nov4oxDRafII8UqXPAnRW9rw3lvq1yH6+nUIlWchluTjtT07it4qRB8Pj6L/OsT49VHcdK/LUaL4RVA+GT8ZarFP+ts3NnsWJFq+n0HG1+P1MsiY+Xjs/Ox0RnTzOIO8UgZPguzt69IHt9XsWZAlXkG+viZyEcTyOXNO4Ob9o3itjOSp7JuvPjqVfUPUCjLbsyANR/J68f8qiF78UFqf7xjWl391Rfah9eWcOralOSfVnJX/5KJGhc3bTv3h9Yh+jmcQ18dBFEH8aRCpID4eBilP3Nv+fxXErubar/fH9/3dGwLLk3lQ9LM7rej1HvzVPGh/Of566hCfm5xzh9ekqJ4Smz+JMhBlrodRehn0K5XTnkapy/LK4cyvo/jVTbbR8ibb6A+j+IYnH7foZ1GixfwZZfav79Hly534qJc7//Kl6jrGqhdEbf1RDM1X3X1/xGfHYblcsPPDGCKIIY9ixKZFZ4zBX4s/Y+zvK18FUc+lixfql/f2OoZWDLxj/ixGDhv9Yw3mJ8/YzB++fcfGL9/M/Mpeoxf88bDP9tX74VWE1zvQULwPfT12x9WKkI33s/6a8l1c0+sjqTna/pb2LEqLj1fPKHwj+UUUfxpFvdaZ9OI5uY4SbVvPKH7h9NdRBs5oiD6MMmtlZN/Z5GmUnEjv/PCM9ibe+ZO+rYdntDegrDUF7Y+jTESZD6NYTiD3baLHJ6LMp9cldot6v7ut+YEoj5+XHg1w31HGw2OxbeZotLY99BeL72vPKF22h1F6rUKZtK+jrPbr157Vf/3ac30ugisi8+undunvz8X+5nPBsodx2eNnd9et7q4/HccWW3q/o8yHz+tUzyjTnj71vnJ1bOeHnrK2Wpl68eMoXm+Dmz/89ViRBz2jdHt6LLrVGamsp1FwRroePi+v/Gi65LKnv2TLJZ+X5U/nLMvK315R/ANRxtOZz4q9hd9RxtM7PWoErPlw/rTvrJHLIdvc5rM3h5WvuPvm6vrobezPGI/eCjWa+pwxXgnRRzF65pb2jde/XJeJ+fiXl3XUmuow/+I16PowJg5j+aNTkUoLqZg+i9EbYtizGPVGp6+3zGcx5qwYazw8DkGMZ4+YbvWIPVxE+eM4Xs/ps+OoRRTV8eXzEX15/t4oPvPW+Nq+zCtfhli5jukLP6A/CjHqKFZ7svKwer0brD/mfD/yZcHv1Wud+GmUtn0iiuNY5uPZQGYAfjGnGFstt43t6a/eaDUfHrT4n81Bt1o3n8w2/TTKrCj+8C1wRgu8d+a9fz2naHrx6jWjHX9EeaUn57Mgw7IIYFjfPnE++vTaRkuQM0p/+t4zo2bwHWX0T0SZD2d9Uzx/SedrhvP07anX25M+nVNPzGOn96fH4jW/mP70jWV6raXM0R6+a8xR07YX+yei2NPrMmquMsfTd9M/orAk52dRsKg/Xw/Mwzf/tfLZfWU8Hl4X32r12bcpn4iyHo4A115R1B9eF7ctXcqtf30szfsHvPsqyEe8+8/zeTqK3HIq9uKn8yj3LZ/cF68PHIu37SNRHp+R4Iyuru5lpm9Upu9iDe46i1vJgb1R1rMMbC3u7O2vnmWTJ7K425cvqN9k6a3qdfzCs7/J0ueaTL/MRn1zLCguuVqr+uZYWtUdDH1aAzEcZzSeVi94lZi9pu2fubqPzwj1P+PiPeQHUa6u7nWdSkO1y9Ws/bpAa9ax9PVlMdJ1EEHFq7SHtVWV/9mPZD0J0saqKe5Yoz8MsvBu9ux0Xn+oA69mzwo9Xyus9d47H9atrllp7tcy7fpAELUPnM7TILPWrta6KsO9+A37dbnoS1prIX75w3NZK8sjt40/YT8pn92kV5DxsJB31Oh7JYUfHsnM8oMXPzuSPSc+kR9/9rj2VYvG+w4+D4+k3i73Ta+emUmrBc7Rn93i109NfbLy+vH60tb65r/OJ/dt/DqhfH0yWkUqQ5+WwGutTg7t9jAIPiZiMdLPgvxxOg+L8bWm90NXf/i8DlSWrO0TI+fhpxKr1s72DZYeBfFN65Vne1Zs/frDsf1/vqv/Isj8wOk8DdJqaf/1Fvilw/arL2p+/+PnvdVqDCt+fnQuvUzN+7NvJdrrhbYuCKvMfhRER52Orme/W68XvzoSk2df4k2s/umjD9j+CIF30cchxrMQtVw318PvAbH+vh4eRZW3fSDE2h59zPfKWDWUsjwLUZmrP2YzPwlRJWl/TFefhnh6Iig8eXQi+3w3J5n9yxO5/PIFH4r0Ll+uHH0Toz4p7Pbs4+42EWPbfh/DHq2CGRKaWEZYdwNE8+rjjvyRbbsdQPT9eP+ZaL4fIFeaZK3fBdBNngTQrEz8s1rtdgDLtJr1R6dguWZn8ugiWs4tTOWXR/AwQL4O+x+lkD8I0H8XwFHD8WgsVE3c3J6NBcnKR5H15azoajy3+hb/y5/ey9KeKtVtT/4e6bFH+o4yjQd/LzNzSDJZDLv92Y+mu17dhmxWsW8t9TRIXsoXjqdBZgXhe/uPgmiuoovJ1TWZVy8O7wMxrua3H4TwvDV/fM74oxBZ2ej8tflJiKH5bRZ/8X4SolapJj7h/UuIcfGNtuRL1B8P2M9ClFfYwxD5PSXbh/wwhP4+hOQPuD4N0f+/fsJ/dFP9fRSvReaHIbKuiyuGPwuRQ5UvLX8NcTXcLVOS+zYfXw/3KVcDLYuZX1jXY62fxMh3yRfawxjZV8oVOdofxdCaWphcHMf4tf1dhbhpf5ch7tnfVYib9ncV4qb9XX1oddP+rkPcsr/LEPfs7zqE/j7ELfu7DnHL/i5v6j37uwxxz/4uQ9yzv6vRPmyrj68xA/yH0R5p64vl9Molv7g/i7LvgZ5L4Q0P+i+ioMHWD6MMLMujtcXPorT6lG/f9fphFFE0C7T5yNWH5yc7L3z26zLqK/AXPjyOauQwmBb7SYxZ327PDU0c//Gqtn6ZH6jOUC/Wh1F6tR148Xgapdb6XkmC8eyq9HyDeuHDGLW8NLm+9LMYWRMy9em5eL7Z/1Fm/Jerun47B7kMcW8Och3i1hzkMsS9OchliHtzEOn62znINyHuzEGuQ9yag3wTQn8f4s4c5JsQd+Yg1zf11hzkOsStOch1iN/PQebIrwpe+PA3YWYF8gvbsxgrV+fnuvhdkav2wGqV7VD7+h3suyiVR39xexqlEoNqa3sYBR9avHg9urZry6/bFpsm/yzGHBljzocx8tdptfbsOVk9h83rifn6Dl+1DLx9Va+j9GkoAbP15fLFd2EmJvD8TuNnYVY1pu2LaYUfhmlot9f9I0fzizD1dXdfaz1bIVqS8+9Xkvvru23X7xOVr5A/Pj/80Rm9focRpn0mzMXRfDOY8tOpJRcvffYR07WPmK59xHTt7zfdms4v+fqHNT52/Pr5x8cjL34cpc7nxe1pFPQENt8eRvEqru7j6mnpnzBw6x8x8G/C3DXw6zC3DfybMHcN/AdH84swNw38O/O965o/CPPYNTX7UC6W4/7jszfsE675TZSbrvlNlJuueR3lI65pWfO0TL5M5sjcPuGa30S56ZrfRLnpmtdRbrrmN9e2fpFsfP3EzU/c5eso9533mzB3nfc6zG3n/SbMXef9wdH8Isxd570Mc995fxDmsfNWQ9Xl8vVYWh9x3vUR510fcd719zuvp1Et//oFX7dPOO93Ue4573dR7jnvN1FuOu93x1KF5i8eH4jCHpc/PKOODUJkPY0yakcfn0+vS+Ua9ij28Pl3tLPzr5NjP4ny2F3QhVFdH0epL1d+FWVDlPU0CpzOpzyNUuWSOrb2iSjP7zSjyNM52c0x/YMoF2P6u/nhvTH9XZR7Y/q7KDfH9PjImB4fGdPjI2N6fGRMj4+M6fGRMT0+MqbHR8b0+MiY/maN6+aYvh/lakx/s1J2c0x/E+XmmP4mys0xfb2uendM/yCKPF3jvTumvzuW9pEo98b0N1Fujulvotwc0z+I8vxO3xvT1+81LT94XU2eJnPvPrnykSdXPvLkykeeXPnIkysfeXLlI0+ufOTJlb/9yZ2zCsLmfFqakY/cK9zXBZmXZVT5C+JcYvuHKhO1ixD3Cpi+CXGngOk6xK0Cpm9C6O9D3Clg+ibErwuYRq5VjquqtMsQtZt4e1pel8Wk7P7+tELPntZAVd/1KfPZFySzvqx9DVv9dQx2G/xZjNyJ+4X+MIZlTZjO9usYj88F1awXMb6r763FxBfPT0SxZ5W1A4/7+LpS/36M8bROv6MnZe/zcZSGKOtpFEOU52dUjcrl6i5/U+1fqQGR/vibgdr6QOTrr7i+i2KIYo+PpbYJFRnyOEpDFP1ElHnhTePXk5Gr3bduTkauQ9yajFyGuDcZuQ6hvw9xazJyHeLXX3Tdm4xch7g1GbkOcWsycveTxaeTkde7WPZ24L4pP/mR+CNGf/YD7pKvMC5jexhj1XE8nAR4NfL3p5+0/BFD/ffX9GkMfiJ8EeOyr8AtA7S2/dYAvwlxxwCvQ9wywG9C6O9D3DHAb0L8+ov+mwZ4GeKeAV6GuGeAN1tW2NOmAJrTyhc+7UbCIO1pNxIZ9ZSPxx1aFhrl2NPTqTYv2j8RRPQDF/ZxEPSKUfn6dK5aKN3pDnnVDKz2Pu2G81h/9i8yue7ClD8rg0mRn8SYaUDOvcR/FGPlp86+sL3Sz2Lks+4LrXt/FqN+ZhfXUf4xxlXL6/om3rjp6Y9i1E4HL5zPYozsg2rDnl2PseVK/djUH8bI4xjsz/6zGPXbwG1X/zHG1ZZXd+/LZYyb9+Uyxgfui8/qv7Y2ffZ8VMfNFz581ldOxF44HsboeU1XH78/jscx8hl74cMx5/mz8MLx0IPyM62XHT181m/e28sYN+/tdYx79/b2cTyOce/eXo/9T9zbbBvhrGj+mRdmPedrnvz12Pft9154GeOmF17GuOmFlzFuPuuXMW4+69cx7j3rt4/jcYx7z/r1vf39sz4antP1cO7QcwefFz6bW45awhl8G1u3+3y+siW5e4iN+SSCS/ZS9vH1uB96NVbudCS5DHGvI8l1iFsdSS5D3OtIchniXkcSG79O6H8T4tYS0vh1Qv+bEPr7ELeWkMavE/rXN/VWR5LrELc6klyHuNWR5Gqsj2xt3Mf0J25Rm7/0uX39i7auZhr3ekp+E+NWT8lvYtzqKXkd415PSVu/d8/1e/dcv3fP9Xv3XL93z/V791y/d8/1e/dcv3fP9Xv3XL93z/V791y/d8/1a/e8HO03e0rGaPwyU3+3p+R1lLs9JX8S5euKpu+i3Osp+U2Umz0lv4lys6fk9X2+11PyOsa9npLfxLjVU/Iyxs2ekv7NnlP3ekr6d1tG3eop+V2Uez0lr6/KvZ6S1zHu9ZT8JsatnpLXMe71lPTuv52DXIa4Nwe5DnFrDnIZ4t4c5DLEvTmIy6+roL4JcWcOch3i1hzkmxD6+xB35iDfhLgzB7m+qbfmINchbs1BrkP8fg5ys6fkdYx7PSWvY9zrKel6UbJzu13Ed1HutYv4Lsq9dhHfRLnZLuLy2t7sKflNjFs9Jb+Jcaun5HWMez0l3doHrup1lNuNcb4Lc7Mxzjdh7jbG+S7MzcY4PzmaX4S52Rjn+pm511PS7fp94mZPyeszut2j5ydhLo7mm8F0q6ek+0dM1z9iuv4R0/W/33Tv9ZR0v9yK8WaPnu+i3OvR812Uez16volys0fP9WC8b+DrMwa+PmPg6zMGvj5j4OszBr4+YeDfme9t11x/v2ve6ynps3/CNb+JctM1v4ly0zVn/9td815PSb/6sOO+a34T5aZrfhPlpmteR7npmt9c21s9JX194i5fR7nvvOsj3Xy/CXPbeddHuvn+5Gh+Eeau866PdPP9SZjHznuvp+TYPuG830W557zfRbnnvN9E+Yjz3uspObZPOO93Ue4573dR7jnvN1FuOu9VkcOULYscpD0pk5iZ6XhF+PLjhdGu9jKtTe5lQ4HZa3H9doy28iOKtrD6avdD9C3X9fuGRll2/1rkGvIL7cHVfOUUcxV6m48iWC3IW+uPImTp4iuCPIqQC6YvHM/OYlSE+euz+LIAaPTLjRVHfcnGFf35DzGuv5bCF2Try2e72+/Hx9V6/GvlXTMB3rjUev9jpz+uqTy6K9Wa5LUGsZ5EGJLHwG8DfxIhqxLklR345TH8kVT4SYQ6hqZPIswsZpWpT8a5Sq6wqdmTs9BaNNfWtt9G6I+OoecHeNrdH0XI6ZL2+ewYcu6nssmjCFmg94qgv43Q1i+vwx8rrg/vxZfHMK62JLrruWq/91z133uujr/Xc3lNRR7dlSogVXk0K1FN31d99Huu1U5K1dtvj8Ef+Z3mJyqvd6v22wjNf3kW1h59BrFafsSwuv42gjxxqz6ruHqO9ShCpr1eawqPIqytzmJ79DnIyhqc/lrQ+22ER8/kH/fiWQReya8jfPPi0+rFB6s6P3p3qhfJDVNDe3oUX71+jasUzhyWxR5fHsM3b+b3Ojf/IMpF5+bv3u/vdW7+Lsq9zs3fRbnXufmb1aCb/W9/EuXxWtvN/rffHkv7SJQNUdbTKPf6334X5V7/259EeX6n7/W//S7PcW9M/yDKxZj+Lltyb0x/F+XemP4uyr0x/U1u7eaY/kkUeZrnuzmmvz2W9pEot8b0d1Hujenvotwb0z+J8vxO3xzT31R83BzT96Ncjelv6kZujulvotwc099EuTmmr6uM7o7pH0SRpxVPd8f0d8fSPhLl3pj+JsrNMf1NlJtj+gdRnt/pe2P6Ost3b4eFb4qS7z65+pEnVz/y5OpHnlz9yJOrH3ly9SNPrn7kydW//cm9ucPCNzFu7bBw/VHRrZ6e8zJddetznm9C3Pmc5zrErc95vgmhvw9x53Oeb0L8+nOeez09r0Pc6ul5HeJWT8+736vZ0y+C7u2wcB3j3g4Lt2Nc7CjwTYxbOyx8E+PWDgu3Yzw+l3s7LHz3teu9HRZ+EsWefWd6c4eF+zHG06/Wb+6w8G2UWzssfBfl3g4L30W5t8PCd9++39th4dsot3ZY+C7KvR0Wvotyb4eFb6Pc2mHhJ1HmhTfprycjVzu33ZyMXIe4NRm5DHFvMnIdQn8f4tZk5DrEr/ub3JuMXIe4NRm5DnFrMnK3gc/TycjNHRbux+jPfsBv7rDwTYxbOyx8cy63dli4H0P999f0aYx7OyxcN+m7Z4BX29HeNMDrELcM8DLEPQO8DqG/D3HLAK9D/Lo93k0DHL83wPF7Axy/N8DrvqCafX/+mMn9qC9oflEyLsrWrmNUudcLx+9j9Id9Utnj9HGMLAh54dNrmiY6LkrGfhBDfh9DH/a+ryZXQ74uUv1BDP19DP/A9XgcA+PFH/adHtkuwMZFb/PrGL1iiP8+htrDGOxd/YEYj68pzuV5DM0YQ35/bx/H2KpF1tefkHyzv8K9Z+w6xr1n7HaMi2fs/l4RH4hx8XzcPpfnMW49Y7fv7eMY956x671V7j1j1zHuPWO3Y1w8Y/f3iflADNffn8vzGLeesdv39nGMW8/YhRO2repzX8wZv9z+xrLtJ/AOYgNN+H8UZNZXyjbbwyD4DPy1PNIeBvE6nTW3R0F867VMv0l/GKSuiW/69ZEsucoBdzRS7cKvNP4SRq9SyavWgXVhfvezMLbhHm0Xj9x3YfJj1j3MenxtpL6a5rL0X8NclSWpVYcqtW6Pw1T/gVeYp4Ng4dHbnj56jkdv2rMgrYoPXlmth0dSO3y8El7c6PAnQUSr0yzfK34WZFXTW93m0yB1OlwS/cuTcvXllfXsMGGdjjv/Icb1Dqm5gMeWxPe/3XqdgOGK+MMr8keQYU+D4LLOh4+a5rcmzblj0fMgTZ4GqS7N1rffX5PHQSy/BX6x6geCWHsapCHI+MA1eRrE4Gs22yeCzA+czlwPg/Q6ErWHY8d7/pA6i4SfB1F/GqT8xO3hAHT8/vkYHwgy9WmQ8hNf7QPX5GmQUUUJ/sfa/uMgvT8N0hFk/v6aPA6C/j8+no6dP4OsD5yOP3V7THG8Pxw7XeoWd3n42PfGvQEenc5oWU73wkfP6+g5mX7lKx6dymu5I9Mm9ux1cli2PXweIj8FGf5s7I5ZOYLp49chRnsYIm8qd2L8SYjavHCs9ugoZuU6pog/O4rcuOKFjy7n3HKaONtmz0J41mVv49GjNXu2tJhs7vH4RB4Z4GyaR9HMn4XI3W/mw9fVVwirEPLsclbhbH+2cvS6I3lT+7OX99ffrV/e1Nc76vtE+tK6Fq/5PyO06ETy5Q/BqHWewQ/v++3DWPn1Ql/4cf3rYVystWrtdKeCn7R/OIxvgtRbu7Ja5a9BxtVQqT1NvjaNb2LkfGPa0xj72vH7xrSL98K2tatcXG04ZdsaT6NYLtna1avUN1HGqj1+5fGxrHyHea0eXx7Lxfrma6317SN779inUVa+2a0l9oko2p9GmflDs+Z4fF1GRRnj+Rnl5PI3Z2S5Y+TybX0iysWS7zdRfGZj7Ks3ze+iVJtit6dj2rfcs/t1WR47w8pvLl6r2PPxseQ3iq8MytMx/Xrf1Foq9cdRsiGdz4uFwe+iZBrmdc+3iyhymfmrqtoXr/44jta766Yuz+PU5+GbzudxkELZrP8iThb/vfjyV/I6jte3KZtfvGx8F2dULnC7Wq34UZzL34SfxPnF8dTy1jbm8+d5jrrOcz4/nj8z4vahOI/9a2Z+0tmK7IdztVbLxL1dXeOrtoNtjtoddM7NHseZtZL/4v40zusS5zVeV+9838Xp5Rmr918cT/XEX12vro9dPTvd8sd8b9vhz+Ow5cYv4ng2P9sbcFx5mH2kEGF338vcf3nG6wXieZxW+4++EvjtF3Ha3TgfKUZ4xbkuI6jv2/T1DDyO47UGq67z+fMz6zkc/cp//HLnrYHvPMflG9o3cbS+rhx+dV7fbHl1+zp/016k283r/F37ls/cr1GphD4u43zjh/my9uLxPE73Ub56OTe8jqPweZVfxKlqkqXz8e/psioVePHj39PluejY1vW4uI4ztK7PvJyrXn1600arrTVGt6vrc/U500/eUa7j3H9H+SbO7XeU6zj331G+iXP7HeU6zv13lOs4999RfhDn8h3lJ3F+cTy331Gu49x/R7mOc/8d5Sdx5uPxLvW7M+RyXMyr7/IbWkE1v7zv13Hw+96G6+M4q8bF/uNxEed6B6at7rtcr4h9E6e27vpVnFbXWZpcvRcs+8w8/DrO/Xn4d3HuzsOvr0+vZmLS+/PnZ+ZC6It9e/4c1n5ibS1/fjwdxyPPx2ltfr6Pi/E0Tt+w2dQ2nh9P7VzY9hv/+HhaxzKJtudxsP/bVRb42zjuN+Nc+7PXNg3DL9+7fxBn6OM4o7r+jCEfiqPPr8/AfJXbhP0qjj0/r+rz/uLL8f5dnA1xxuM4mCeM6zzi9fvFrHnCmlfvla1drUvMVu9N86o27Ls4VcSz22H/TJwr3/g2jlScq+en9Yvfr5sfB7yCyFWa6dbXAd+dkdaTM/XyTeeycGLki45OrM/+Y+FEu+rPN7MY98/tSv8S42oh3apHmHEh9HkU2ujPouCtzfnB3A+jaBV/Pz8jFxRuf+TqzsdR8NY3+GHYD6M4Pe9pFHzVOPtHoqBpxl+iXA+ilbM/Xai9/Msguv5ETVp9oiasrte/xLmc2yiaiiu97i9x9GqtshoZvf4dfgk2+dHRDGRKBivm/no0F877Soplr8lp8+Jo9Hqrz5o/rsUve+1nYSptsyaWuX8YZuWvUt8aN8z8Sxi/nOzXBqadP7b/8Lnyd2GqFHpvb68XYa4eY/F6jMW5z5Q9DyPyPExt0czCm7+EscueA+8r48zxzh8dyagvcOSPtp5/ORL5/ZH45cDu1XZy6vbwefmHMOthGN3qVUO3bh8JI/o4DBJPr1XFp9dmrfmRo8GH4c+PRteWdqXr6/5S34WZY3wkTJVM/CbMqlTR61dXHoYxrefmZYBPzdO2SsRaa09vuGOG5aNvHwlzNcJ9/b1e4+hg4XOTxydkHwkzFWFsfiTMuAhz9fL/kcu76lfSlz4dS77wqrLm48v7x9E8DzPxIf+aT8fS2Goe/FrOao9Pqj7c+0WYV9IXbxo6HofJnuv7Ys1Tg3gtV294e7p4bubf/AS/VmbqurBy6YcnpDPv0uRC9V/CXL+tzMqL98l85F/eVub8xNvK5Sr1/deMb8Lcfem5DnP7beUyBXT/beU6zO23latmzj94W/lBmKu3le/C3HxbWePXw/L6SG6/razfzyAub/T994MfhLmakV8nMG9P7L85mrsT++swt2fk34TBjHwO/USYXxzN7Yn9ZZj7E/vrMLcn9pdh7k/sfxDmYmLfW/97h+X9if03YewjYW5P7H8Q5mJi39v4my/v7Yn9N2HuTux/cDTPw9ye2F+GuT+x/+ak7k7sL8Pcn9h/E+buxP46zN2Jfe9/8xN8f2J/HeZDE3uXKvhwfZ5cGYJ0hl4mV/wjP7nXOSNttQmhXh1Ov+r52KsM85Xh7l+/r/Srrqld8iOmLqi5XvMfg1y//Vd2ELnXvwb5fRO/V5Dfd/H75nRWjYKFOtkfXZNeVY69oWPEX4Jc9k2+e02u0nAfuSa95S3unZt4zp89+phCG95q//roX5XOvOYcb2N4vbSPp1FiYBxROj8m/FkUSfOe3Jrsh1E8vzWYf5SS/SzKqM39xpSnUao1wR/7m/5jlIs8tGy57ZtsKID4xyYj3a6e2y0nML7hM45/zND3y9ybVv8J1XYRRK+ua1bAvmy/PwuytjyStem8CHKZ8O3VMK5360/DtMkw8vxoal2oy+MwtaHk69HUxycl9SHt6wm/OJrL7+EGvqsbA2+P/qMo1c/qxfY4Si0WjIVKDP/RhbHqvPjS04sLczVVaFmf3Du82/5yRtc3qapmO7eH+muYy3Y7o74ZWuhiZD8JUo1/XqgfCIIi+18EGU+DVL0ty1t/GqR/NMjC+sDPgiytz8f16S2uZj1t4dO7HwXp9Wv2mtX1x0dS1b7j8ZFstZyPZdWfBWnZ7+81jNcHgqg8DbIwqXx6JL1VkD4eH0n/QJDxgSPp2dDxFWNeBLl8IdvQ4X1Dd8qfmbVvA83z13wchkfzPEyT6v3b3L8Os7bfrpN8cyS9Phn7ox3rD09Iavq09+R/GGbgw5jRkeT74S/zHMijrscnpfV5n+vyp2GsoXH840s8pKY+Q+bFrGXND7yHXyXWbr+HX5+Qjvq6VNfTadgatay7JqeEPwszW/UimOjx8pujeR5mVn5jre3rMLLZ32sQC7P/15L1wxPaf+7zZ+mVC/WnYUbOll+Z/C5Pw8z8IOHFT4/m9R5T5Zqv95v++Gjys8vX3KE9vsRL6tqsi/eR2Krzb3xmeqsf2xdjH4WfndBrCa7CMLfx1xPy3zueXCXVPuJ4rx80TDWlPR0ErdrKvFjb8zCKMM+PpuaKjc0h/nKXrr5te82f65vqxV1Gf7Y+MD1/U/pqXy+1xZd9X7+TYzVo62ycYfNncepwts4VyL/GubzGo+Ma6/M4Xk7zyjq258fT7CPHM1Y9gpMNpH4aJ6/zi7mO/o9xrhc2a/uJNezrxSWRiydZPY9Fnb0TfnYoM9+PF/tB//VQLp+/NRSLS/3i+l6l1l6L8dnd3/jN3F+jXB9N5fEb5wA/jPP6/3Kq1vjK/qs4/jyOVjusple3/Js4VtVdzS9d5zrOwHn98Rn+z+L0rT7b7H+0JflhnI5FcW6o/fM4E3Hm4ziGdnx/tFf6TZz5/PoMlP2ONT8S549E+s/i/Fl0tj0ep4bupPbH5/w/jNNridykXcWxD3w+L/aBz+e/OSPBlZF59QSafeKM/G8/o1W7BrxynI+9y2vbkn1/SvlMnPV4LLjWZ4avOfLjMe62YVe4fnU83q9+ibPD3LC+feZo1J/HqSWcfYupx3G86sb8j5b7vzgeb9uH4jw+r6nVSGvacyd9Ze2r5rDJ46d5Vv5n7z1gv4gzK44//sWabas4rV+5xpC/fVT8eTT6/Or0qired+z5TJz52FOn1DLVKz37PA5aO0x9Po975YWrqNL78+NxqRrPP7a1+GmcKk2Yoz2eD05s9zfHc1f9M449vz61L8WLn8/f/4gz2+Nx8Xq7rjZa23h8PKvXPHf15786SxqWnGx7Hqdcfsl8/Ou1tCqilsov4viGeoPHz/Oy+oZl2fPxvryyncufvx8v+MYrjn8kznj+nv1a8UchxC+e59qfav/o8mmcV3KkihC2uc2nS08re+asta4q4W4HGc+C7H2PqsHzH1mjX4SZ/WmYXl8lbl0fh6kt516s8jSMVVPUzZ4fjddi0eYyn4YZ1a/p9ew9vlODnZS38ZEw7fElnlbLp3PY4zBoUz6fP8V/hHn+FK/KUO971DwM83p0BxZz5XGYgTDLPnI0vwhTK57tjwK5n4XptbyzF6M8DSP1uWWT/jxMfTS0ryc9PxpFmKun+LIUPnfFe61wf31K2q87oC0UJfQvi4m1X/5eVnp5o/H97Egw15p4R/vzSK6+MKimp68MKYZj+8fjuPrkaFXWvj8LUdlgZ9nKX0Jc1AX1ni8KXbjl4T/0BFW53F220tIsQ/5rkItyc62PC17PgD8MUt8QKjPSPwyS38j9Kkj7fRBNV1KdT69JPWmvrNe6CHJVGVofOvc/GpSMfwxyUcm2f0f5DuJcyvpLkMu2IrXEwpKZHwXpW6/aJr04Ev11k79vjqOy4K9c68VxyN97HLVNzMvQ/OFF/eMzvedBtt8HqcHX/1gl+MtlvWzAWLMu5R6hPwqi9SKt+pEg42mQmiip++Mg1Rhwtg+czuMgtmGDie0DQeRxEEUjav06iP36A/pvjqM+q/OrkWPr915y6fL1Vbdfedrlx2d3Xf4qyG2X99+76/Vx3HR5t7/3OO66/DdB5BNBtt8HuevyY/uAy18Guevy94OMp0Fuuvw3Qe65/O3TeRzkrsvfDiKPg9x0+fF7d70+jpsuP9vf6/L1uX8f6+KiTvnA4LsMcnfw3Q8ynga5Ofi+CXJv8N0+ncdB7g6+20HkcZCbg2/9uonZN8dxc/At/f3gu1pwWVkM1Fdbz1ZtXqnU94Mm7M75wyB5Z16rJuP3QTp3jli3V+R65jJE0PDmH9fCbLuy1lEfVrIG969B2u8X1Gzrv19Qs01+v6B2HeTmgto3Qe4tqH0XpP0+yM0FtesgNxfUomLvtwtq1rbfL6hZ+8Cr1mWQu69a9vsP2b45jnuvWtbs7z2Om69a3wWRTwTZfh/k5quW9Q+8al0HuTnb+0GQ8TTIvdned0Fuzfbun87jIDdne/eDyOMg92Z71n/9qvXNcdyb7Zm033vJ9vsFNRP5gMtfBbnt8vJ7d70+jpsuL+PvPY67Lv9NEPlEkO33Qe66vPYPuPxlkLsufz/IeBrkpst/E+Sey98+ncdB7rr87SDyOMhNl//9PmvfHMdNlzf5e13+5oKaXX1ednvwXQa5O/juBxlPg9wcfN8EuTf4bp/O4yB3B9/tIPI4yM3B579eyPrmOG4Ovqt+FjeP43LB5eaC2mWQuwtq3wS5t6B2O8jDBbUqVRZjqeg/roWNq6u6tSrXs+0iiHxgQe1q67TbC2rDPrCgdhnk7oLadZCbC2rfBGm/D3J3Qe0yyN0Ftauc1u0Ftdk/sKA2P/GqNT/xqjV//6o1P/GqNcffexx3X7XmJ1615ideteYnXrXWJ1611idetdYnXrXWJ1611idetdYnXrXWJ1611idetdYHXrV8+/2r1vrAq5Zvv3/Vunb5ewtqftWp8a7LXwa56/K+/dpdvzmOey7v2/p7j+Omy38XRD4RZPt9kJsu701/7/LXQW66/A+CjKdB7rn8d0Fuufz903kc5KbL3w8ij4PcdPn+a3f95jhuuny3v9flby6o+dUnVrcH32WQu4PvfpDxNMjNwfdNkHuD7/bpPA5yd/DdDiKPg9wcfPLrhaxvjuPm4Luq7bw5+C4XXO4uqF0Fub2gdh3k5oLa3SAPF9RGfpguY339tabrxWGM3Al7smvvX0LY75fT/Go3wrvLaa7j98tp10FuLqd9E+Tectp3Qdrvg9xcTrsOcnM5za8yWneX0/zqC/S7y2lun3jRsk+8aP3+I61vjuPmi9bvP9K6Po67L1r2iRct+8SLln3iRcs/8aLln3jR8k+8aPknXrT8Ey9a/okXLf/Ei5Z/4kXLP/GiNX7/ouWfeNEa9nsv0Q8sp43xAZcf4wMu//uPtL45jpsu//uPtK6P467LfxNEPhFk+32Quy4//QMufxnkrsvfDzKeBrnp8t8Euefyt0/ncZC7Ln87iDwOctPl1+/d9fo4brr8Gn+vy99dTrvahuz24LsMcnfw3Q8ynga5Ofi+CXJv8N0+ncdB7g6+20HkcZB7g29sv17G+uY47g2+0X696eP1gsvN5bTLIHdXwm4HebgSNnNPEFnevlzGGlefaO3tFN835o89mH8UpHX0x3saRGqvyD86/v0oiOZCSdNxdU0+0Mtt9A/0chv9A73croPcXNr7Jsi9pb3vgrTfB7m5tHcd5ObS3ugf6OUWvZJ/u7Q3+gd6uV0GufvSN37/mdY3x3HvpW+I/L3HcfOl77sg8okg2++D3HzpG/KBXm7XQW7OO38QZDwNcm/e+V2QW/PO+6fzOMjNeef9IPI4yM15p/76Zeub47g579T1ey/5QC+3YR9oMHAZ5LbL//4zrW+O46bLm/29x3HX5e0DDQa+C7L9Pshdl/cPNBi4DnLX5e8HGU+D3HR5/0CDgfun8zjIXZe/HUQeB7np8v57d/UPNBiIrRH+Tpe/ubQ3xgd6uV0HuTv47gcZT4PcHHzjA73c7p/O4yB3B9/tIPI4yM3BN3/dy+2b47g5+Kb+fvB9oJfbZZC7S3u3gzxc2qvNq3Xb/tzV4P/3+n/9y3/51//2n//tP/7Lv/yPf/2Pf//v+x/uOzH/077Fz+vv9p2YwRO8im0LnsEN3MEC1uAVbGAHD3Do7vv97Ls7F/sGbuDQ3dta7RtSgxVsYAcP8ASv4rGBGxi6A7oDugO6A7oDugO6A7rz0LXgBu7gQzeu21SwgR186MZ9mRO8itcGDt39mX1xBwsYugu6C7prgKG7Svf1wIMbuHRfq5pgBZfuawYMHuAJhm6DboNu62DoNug2A4fu/pL04gGe4FXH0DdwA3ew1DF0BRvYwaOOp0/wKhboCnQFuiJg6Ap0BboywNAV6OoGhq5CV6GrCoauQlehqxMMXYOuNTB0DboGXcNzZdA16Bp0Dc+VQ9eh63ieD7/aF5xfrGCrZ8bxXDmeZ8fz7HiuBu7vwPM88DwPPFcD93fgeT786mQ8VwO6A7oTuhP3d0J3QndCd+L+TuhO6E48VxO6C7oLugv3d0F3QXdBd+H+Lugu6K56rmQrXdkauIMFXLqyGdjBAzyhBd22gVs+M3L41ckCVnA9VwK/ktOvNHiCV/HhVyfjfOFX0nG+XcE4X/iVdJxvn2Ccr+B8pYGhC78Sga4YGLrwKxHoSo1fgV+JQlc7GLrwK1HoqoOhC78Sha5tYOgadE3A0IVfiUHXBhi68Ctx6HoDQ9eh6wq2esZOvzp4gCd4FR9+dTyHh1+d3Ot5O/zqZAUbGOc7cL7wK4FfycT5Tpwv/ErgVzJxvtPADobuhC78SuBXsqC7oAu/EviVLOgu6MKvZEF3la7CrxR+pVvp6iZgBRu4dHUb4AmGboNug27rYOg26DboNgdDt0G3lW/o6VctuIE7WMAKLp/U7uDySe0TXD6psoFxvvArhV8p/Eoxv1L4lcKvFH6lmF8p/ErhV4r5lcKvFH6l8CvF/ErhVwq/UviVYn6l8CuFXynmVwq/UviVwq8U8yuFXyn8SuFXivmVwq8UfqUOXYeuQxfzK3XoOnQHdDG/0gHdAd2h4PJJHQ4e4Akun9RZPqmzgcsndQpYwQbG+cKvFH6l8CvF+6DCrxR+pfArXThf+JXCrxTvgwq/UviVwa8M74MGvzL4lcGvbCtdg18Z/MrwPmjwK4NfGfzK8D5o8CuDXxn8yhp04VcGvzK8DxreBw3zK8P8yvA+aHgfNMyvDPMrw/ug4X3QML8yKZ80aeAOFrCCyydNHFw+aTLB5ZOmGxjnC78y+JXBrwzvgwa/MviVwa8M74MGvzL4leF90OBXBr8y+JXhfdDgVwa/MviV4X3Q4FcGvzKHLvzK4FcGvzKHLvzK4FcGv7IBXfiVwa9sQHdAF/Mrw/zKBnQHdDG/MsyvbEJ3QhfzK5vlkzYdPMATXD5pq3zSVgOXT9oSsIINjPOFXxn8yuBXjvUrh185/MrhV471K4dfOfzKsX7l8CuHXzn8yrF+5fArh185/MqxfuXwK4dfeYMu/MrhVw6/8g5d+JXDrxx+5R268CuHX3mHLtavHPMrx/zKBbpYv3LMrxzzKxfoYv3KMb9yLZ90beAOFrCCyyddHVw+6TrB5ZNuGxjnC79y+JXDr9xwvvArh185/MoN5wu/cviVO3ThVw6/cviVO3ThVw6/cviVD+jCrxx+5QO68CuHXzn8ygd04VcOv3L4lU/owq8cfuVYb3estzvmV475lWO93bHe7phfOeZXjvV2x3q7Y37lq3zSl4MHeILLJ8dWPjm2Bi6fHJuAFWzgOt8BvxrwqwG/GlhvH/CrAb8a8KuB9fYBvxrwq9GgC78a8KsBvxoduvCrAb8a8KvRoQu/GvCr0aELvxrwqwG/GgJd+NWAXw341RDowq8G/GoIdBW6mF8NzK+GQlehi/nVwPxqKHQVuphfDSufHNbAHSxgBZdPDnNw+eSwCS6fHL6Bcb7wqwG/GvCr4Thf+NWAXw341XCcL/xqwK/GgC78asCvBvxqDOjCrwb8asCvxoQu/GrArwbygwN+NeBXA341kB8c8KsBvxrwq4H84IBfDfjVQH5wID84ML8amF8N5AcH8oMT86uJ+dVEfnAiPzgxv5pb+eTcHDzAE1w+OVv55GwNXD45m4AVbOA63wm/mvCrCb+aHecLv5rwqwm/mh3nC7+a8KvZoQu/mvCrCb+aAl341YRfTfjVFOjCryb8agp04VcTfjXhV1OhC7+a8KsJv5oKXfjVhF9Nha5BF/OrifnVNOgadDG/mphfTYOuQRfzq+nlk9MbuIMFrODyyYn84PTyyekTXD45xwbG+cKvJvxqwq/mwPnCryb8asKv5sD5wq8m/GpO6MKvJvxqwq/mhC78asKvJvxqLujCryb8ai7owq8m/GrCr+aCLvxqwq8W/GptpbvgVwt+tbbSXahnWJhfLcyv1jYRH7qYXy3Mr1aDLuoZFuZXq5VPrubgAZ7g8snVyydXb+DyydUFrGAD43zhVwt+teBXS3C+8KsFv1rwqyU4X/jVgl8tgS78asGvFvxqKXThVwt+teBXS6ELv1rwq6XQhV8t+NWCXy2DLvxqwa8W/GoZdOFXC361DLoOXcyvFuZXy6Hr0MX8amF+tRy6Dl3Mr9Yon1yjgTtYwAoun1zDweWTa0xw+eSaGxjnC79a8KsFv1qoZ1jwqwW/WvCrNXG+8KsFv1qoZ1jwqwW/WvCrhXqGBb9a8KtVftW3LXVf3MAdnLovVrCBHTwQf4KhW371Yug26JZfvRi6DboNujW/ejF0G3Q7dGt+tX/mUlodujW/enH65IsdPMATvIolffLFDZw++WIBK/jQtWAHD/AEr+Jz/ergBu5gAWcd4/69D9jBAzzBq9g2cAN3sICha9A16Bp0DboGXYeuQ9ezfvLFAlawgfFcOZ6rqr968SoeeK4Gnquqv3qxgPFcVf3Vix0M3QHdAd2qv3oxdCd0J3Sr/urF0J3QrfqrF0N3QndBt+qvXgzdBd0F3aq/ejF0F3Sr/urFK8dLq/WrFzdw+uSLBaxgA6dPvniAJ7h8o1X91YsbuIOhC79q8KsGv2oNuvCrBr9q8KvWoQu/avCr1qHboduhW/OrF0O3Q1egW/OrF0NXoFvzqxdDV6Ar0K351Yuhq9BV6Nb86sXQVejW/Kqf9e3hvWd9+8lZl9vP+vaDa37VW82vejM8V4b7W/Or3mp+1ZvhuTLc35pf9Vbvg705niuHrkPXoeu4vw5dh65D13F/HboDugPP1YDugO6A7sD9HdAd0B3QHbi/E7oTuhPP1YTuhO6E7sRzNaE7oTuhu/BcLegu6C48Vyvnk73VentvC8/VwnO18FzBr8769vgdP+vbT+5gAdf5or69o769o769d/gV6ts76ts76tt7h1+hvr2jvr13+FWHX3XMr3qtX/UOv+rwq475Va/1q97hVx3zq17rV73Drzr8qnfo1vtg7/CrDr/qAt16H+wdftUFuvU+2Dv8qsOvukC33gd7h191+FVX6Nb7YO/wq67QrffBfta3xzP2rm8PrvX23mu9vfdab+9nffvxHJ7r7Qfne3c/69tPHuAJxvk6zhd+1eFX3XG+jvOFX3X4VXecb70P9g6/Qn177wO68KsOv0J9e+8DuvCrDr8669tPLejCr1Df3vuELvyqw69Q3977hC78qsOv+oTugi78CvXtvS/oLugujN8F3QXdBV28DwreBwXvg4L3wbO+PZ6xs779ZAM7eIDLJ9/17cGtfPJd335wBwu4zlfgVwK/EviVYH4l8CuBXwn8SjC/EviVwK8E8yuBXwn8SuBXgvmVwK8EfiXwK8H8SuBXAr8SzK8EfiXwK4FfCeZXAr8S+JXArwTzK4FfCfzqXd9+xIeuQhfzq7O+/Yhv0DXoYn511rcfWgbdWr/qZ3378YxZ+aTUenuXWm/vUuvt/V3fHs+hK7h88l3ffvAATzDOF34l8CuBXwneBwV+JfArgV/JwPnCrwR+JXgfFPiVwK8EfiV4HxT4lcCvBH4lE7rwK4FfCd4HBX4l8CuBXwneBwV+JfArgV9JfY/TFX6l8CvF+6DifVAxv1LMrxTvg4r3QcX8SjG/UrwPKt4HFfMrre9xutb3OF1rvb1rrbd3rfX2rvX9YH/XtwfX9zj9Xd9+cAcLGOcLv1L4lcKvFO+DCr9S+JXCrxTvgwq/UviV4n1Q4VcKv1L4leJ9UOFXCr9S+JXifVDhVwq/UoUu/ErhVwq/UoMu/ErhVwq/OuvbDy34lcKv1KBr0MX8SjG/UoeuQxfzK8X86qxvP7QcuphfaX2P07W+x+la6+1da729a62393d9ezyHQ8Hlk+/69oMHeIJxvvArhV8p/EqxfqXwK4VfKfxKsX6l8CuFXynWrxR+pfArhV8p1q8UfqXwK4VfKdavFH5l8Cur73G6wa8MfmXwK6vvcbrBrwx+ZfAr26ALvzL4lTXoYv3KML8yzK+sQRfrV4b5lWF+dda3H1pYvzLMr6y+x+lW3+N0w3q7Yb3dsN7+rm/vweWTVt/j9Hd9+8EdLGCcL/zK4FcGvzLB+cKvDH5l8CtTnC/8yuBXptCFXxn8yuBXptCFXxn8yuBXZtCFXxn8ygy68CuDXxn8yhy68CuDXxn8yhy68CuDXxnW2w3r7Yb5lWF+ZVhvN6y3G+ZXhvmVYb3dsN5umF9ZfY/Trb7H6Wd9+8kN3MHlk+/69oPLJ9/17QcP8ATjfOFXBr8y+JVhvd3gVwa/MviVYb3d4FcGv/L6Hqc7/MrhVw6/8voepzv8yuFXDr/y+n6wO/zK4VfeoAu/cviVw6+8QRd+5fArh195gy78yuFX3qHboYv5lWN+5R26HbqYXznmVy7QFehifuX1PU73+h6nn/XtJzt4gMsn3/XtwfU9Tn/Xtx/cwQLG+cKvHH7l8CtXnC/8yuFXDr9yw/nCrxx+5QZd+JXDrxx+5QZd+JXDrxx+5Q5d+JXDrxz5QYdfOfzK4VeO/KDDrxx+5fArR37Q4VcOv3LkBx35Qcf8yjG/cuQHHflBx/zKMb9y5Acd+UHH/Mrre5zu9T1OP+vbT27gDi6ffNe3H1w++a5vP3iAJ7jOd8CvBvxqwK9GfY/TB/xqwK8G/GrU94N9wK8G/Go06MKvBvxqwK9Ggy78asCvBvxqNOjCrwb8anTowq8G/GrAr0aHLvxqwK8G/Gp06MKvBvxqCHQFuphfDcyvhkBXoIv51cD8aih0FbqYX436HqeP+h6nn/XtJzt4gMsnB/KDo77H6e/69oM7WMA4X/jVgF8N+NUwnC/8asCvBvxqOM4XfjXgV8OhC78a8KsBvxoOXfjVgF8N+NUY0IVfDfjVGNCFXw341YBfjQld+NWAXw341ZjQhV8N+NWY0EU9w8D8amB+NRZ0Uc8wML8amF+NBV3UMwzMr0Z9j9NHfY/Tz/r2kxu4g8sn3/XtB5dPvuvbDx7gCa7znfCrCb+a8KtZ3+P0Cb+a8KsJv5r1/WCf8KsJv5oduvCrCb+a8KvZoQu/mvCrCb+aHbrwqwm/mgJd+NWEX0341RTowq8m/GrCr6ZAF3414VdToavQxfxqYn41FboKXcyvJuZX06Br0MX8atb3OH3W9zj9rG8/2cEDXD75rm8Pru9x+ru+/eAOFjDOF3414VcTfjVRzzDhVxN+NeFXc+B84VcTfjVRzzDhVxN+NeFXE/UME3414VcTfjUndOFXE341Uc8w4VcTfjXhVxP1DBN+NeFXE341F3ThVxN+NRd0F3Qxv1qYX636Hqev+t65L8yvFuZXq7537qu+d+4L86tV3+P0Vd/j9LO+/eQG7uDyyXd9+8Hlk+/69oMHuOonz/r2qBs869tPbuAOFrCCDezgAZ5g6Ap0BboCXYGuQFegK9A9/SrO8fSrg1fxuX51cPnkgl8t+NWCX636Hqcv+NWCXy341arvB/uCXy341UL91UL91cL8amF+tVB/tVB/tTC/WphfLdRfLYcu5lcL9VcLfrXgVwt+tVB/teBXC3614FcL9VcLfrXgVwvr7ahv76hv7wt+teBXC/OrhffBBb9a8KuF+dXC++CCXy3MrxbeBxf8asGvFuZXC+tXC3614FcL86uF9asFv1qYXy2sX63yK9nKr2Sr90HZ6n1QtvIr2cqvZKv3QdnqfVC28ivZ6n1QtnoflK1Bt0G3QbfeB2Vr0G3QbdCt98EXQ7dBt94HZav+V7JV/yt517f3YAVbHU/lB2Wr/KBsVc8gW61fyVb5QdkqPyhb1TPIVvlB2So/KFvVM8gm0BXoCnQF91ehq9BV6Crur0JXoVv1DLIpdBW6Cl3D/TXoGnQNuob7a9A16BqeK4OuQdeh63iuHLoOXYeu47ly6Dp0Hc9V5Qdlq/ygbAPP1cBzNfBcDTxXlR+UrfKDslV+ULbKDwrq2wX17bJNnO/EOJo434nznTjfiXE0cb4T5zsxjhZ0F3QXdBfG74Lugu6C7sL4XdCt9XZplR98cek2+BXq2wX17dLgV6hvF9S3C+rbpcGvUN8uqG+XBr9Cfbugvl1Q3y4NfoX6dkF9u6C+XRr8CvXtgvp2aZUflFb5QWmVH5RW+UFplR+UVvlBaZUflFb5QWmVH5RW+UFplR+UJjhfwfnCr1DfLk1wvoLzhV+hvl2a4nwrPyiob5em0FXowq8a/KopdA268KsGv2oGXYMu/KoZdA268KsGv2oOXYcu/KrBr5pD16ELv2oOXYeuQ7fyg9IGdAd0B3QrPyhtQHdAt/KD0io/KK3yg9IqPyit8oPSKj8orfKD0io/KK3yg9IqPyit8oPSKj8obeJ84VcNftXgV23hfOFXDX7V4Fdt4XzhVw1+1TG/6vCrDr/q8KuO+VWHX3X4VYdfdcyvOvyqw6865lcdftXhVx1+1TG/6vCrDr/q8KuO+VWHX3X4Ffq3S+/Q7dDF/Ar926V36HboYn7VBboC3coPSq/8oPTKD0qv/KD0yg9Kr/yg9MoPSq/8oPTKD0qv/KD0yg9Kr/ygoH+7dPhVh191+BX6t0uHX3X4VYdfdcP5wq86/Ar926XDrzr8qsOv0L9dOvyqw686/Ko7dOFXHX7VHbrwK/RvF/Rvlz6gC79C/3ZB/3bpA7rwK/Rvlz6gO6CL+RX6t0uf0J3QxfwK/dulT+hO6GJ+1Ss/KL3yg9IrPyi98oPSKz8ovfKD0is/KL3yg9IrPyi98oPSKz8oHe+D6N8u6N8u6N8ugvdB9G8X9G8X9G8Xwfsg+rcL+reL4H1Q4FcCvxL4leB9UOBXAr8S+JXgfVDgVwK/Qv92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92kcoPilR+UKTygyKVHxSp/KBI5QdFKj8oUvlBkcoPilR+UKTyg4L+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7SIOXfiVwK8EfiUOXfiVwK8EfiUDuvArgV+hf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7ugf7tI5QdFKj8oWvlB0coPilZ+ULTyg6KVHxSt/KBo5QdFKz8oWvlBQf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf92Qf920Q5d+JXCrxR+pR268CuFXyn8Sjt04VcKv0L/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dtHKD4pWflC08oOilR8UrfygaOUHRSs/KFr5QdHKD4pWflC08oOC/u2C/u2C/u2C/u2C/u2C/u2C/u2C/u2C/u2C/u2C/u2iA7rwK4VfKfxKB3ThVwq/UviVTujCrxR+hf7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tgv7tYpUfFKv8oFjlB8UqPyhW+UGxyg+KVX5QrPKDYpUfFKv8oFjtjyPo3y7o3y7o3y7o3y7o3y7o3y7o3y7o3y7o3y7o3y7o3y4m0IVfGfzK4Fcm0IVfGfzK4Fcm0IVfGfwK/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dsF/dvFql+fWPXrE6v9ccRqfxyx2h9Hzvr24zn08kmrfn3y7t9+cAcLGOcLv0L/dkH/dkH/dkH/dkH/dkH/dkH/dkH/dkH/drEJXfiVwa8MfmUTuvArg18Z/MoWdOFXBr9C/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3ZB/3bx6tcnXv36xGt/HHHkBx35QUd+0JEf9OrXJ+/+7QcP8ATjfOFX6N8u6N8u6N8u6N8u6N8u6N8u6N8u6N8u6N8urtCFXzn8yuFXrtCFXzn8yuFXrtCFXzn8Cv3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bxatfn3j16xOv/XHEa38c8dofR8769uM5HOWTXv365N2//eAOFjDOF36F/u2C/u2C/u2C/u2C/u2C/u2C/u2C/u2C/u3iC7rwK4dfOfzKqz+DDPjVgF8N+NWo/qIy4FcDfoX+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7TKqX5+M6tcno/bHkVH748io/XHkrG+P5/Csbz+5fPLdv/3gAZ5gnC/8Cv3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bBf3bZaCeYcCvBvxqwK8G6hkG/GrArwb8ahh04VcDfoX+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7YL+7XLWtx/P2FSwgR08wOWTZ337wat88t2//eAOPnQtOOsJ5d2//WAHD/AEZx2jvPu3H9zAHSxgBRvYwQM8wdBt0G3QPf3KggWsYAOXT6J/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u6B/u0yst7/r2w9u4Bq/E341Mb+aeB9E/3aZ8KuJ+dXE++CEX03MrybeByf8CvXtgvp2QX27TPgV6tsF9e2C+naZ8CvUtwvq2wX92wX17YL6dkF9u6B/u6C+XVDfLqhvlwm/Qn27oL5d0L9dUN8uqG8X1LcL+rcL6tsF9e2C+naZmF+hvl1Q3y6z+vXJrH59Mqtfn8zq1yeob5eF/OBCfnChngH17bKQH1zIDy7UMyzkBxfygwv1DAvr7Qvr7Qv5wYV6hoX19oX19oX84EI9w8J6+0J+cKGeYWH9amG9fSE/uFDPsLB+tbDevpAfXKhnWFhvX8gPLtQzLKxfLay3L+QHF+qvFtavFtbbF/KDC/VXC+vtC/nBhfqrhfzgQn5wIT+4kB9cyA8u+NVCfnAhP7iQH1zID6K+XVDfLgv5wYX8IOrbBfXtspAfXMgPor5dFvKDC/lB1LcL6ttlYb19IT+I+nZBfbssrLcv5AdR3y4L6+0L+cEFv0J9u6C+XVDfLgt+hfp2QX27oL5dFvwK9e2C+nZZ8CvUtwvq2wX17bLgV6hvF9S3C+rbZcGvUN8uqG+XhfzgqvygbpUf1K3yg7pVflC3yg/qVvlB3So/qFvlB3Wr/KBulR/Urd4HFfXtivp2RX27bvU+qKhvV9S3K+rbdav1qxdP8Cru0O3Q7dAtv9KtQ7dDt0O3/Eq3Dt0O3fIr3QS6Al2BbvmVbgJdga5At/xKN4GuQrf8SjeFrkJXoVv5Qd0UugpdhW7lB3Uz6Bp0Kz+oW+UHdav8oG6VH9St8oO6VX5Qt8oP6lb5Qd0qP6hb5Qd1q/ygbpUf1M1xvo7zLb9S9G/XzXG+jvMtv1L0b9dt4HzLrxT923Ub0B3QHdAtv9JtQHdCd0K3/Eq3Cd0J3fIr3SZ0J3QndCfG74Lugu6C7sL4XdBd0C2/0m1Bd0G31tu11fzqxaXbav1KW623a6v5lbZav9JW6+3aKj+orfKD2io/qK3yg9oqP6it8oPaKj+orfKD2io/qK3yg9oqP6it8oPaGs4XftXgVw1+1TrOF37V4FcNftU6zhd+1eBXTaALv2rwqwa/agJd+FWDXzX4VRPowq8a/KopdOFXDX7V4FdNoQu/avCrBr9qCl34VYNfoX+7on+7NoNuza8U/dsV/du1GXRrfqXo367NoVvzK22VH9RW+UFtlR/UVvlBbZUf1Fb5QW2VH9RW+UFtlR/UVvlBbZUfVPRvV/Rv1wa/avAr9G9X9G/XBr9q8Cv0b9cGv2rwK/RvV/Rv1wa/avAr9G9X9G/XBr9q8Cv0b9cGv2rwq7agC79q8KsGv+q13q4dftXhVx1+1Wu9XTv8qsOv0L9de623a8f8qmN+hf7t2ht0Mb/qmF/1Bt0GXcyveuUHtVd+UHvlB7VXflB75Qe1V35Qe+UHtVd+UHvlB7VXflB75QcV/du1w686/KrDr9C/XTv8qsOvOvyqC84XftXhV+jfrh1+1eFXHX6F/u3a4VcdftXhV12hC7/q8Ktu0IVfdfhVh191gy78qsOvOvyqG3ThVx1+hf7t2h26mF91zK/Qv127Qxfzq475VR/QHdDF/KpXflB75Qe1V35Qe+UHtVd+UHvlB7VXflB75Qe1V35Qe+UHtVd+UNG/XTv8qsOvOvwK/du1w686/KrDr/rC+cKvOvwK/du1w686/KrDr9C/XQV+JfArgV9J5QdV4FcCv5LKD6rArwR+JfAradCFXwn8SuBX0qALvxL4Ffq3qzToYn4lmF+hf7tKhy7mV4L5lXToduhifiWVH1Sp/KBK5QdVKj+oUvlBlcoPqlR+UKXygyqVH1Sp/KBK5QcV/dtV4FcCvxL4Ffq3q8CvBH4l8CtRnC/8SuBX6N+uAr8S+JXAr9C/XQV+JfArgV+JQRd+JfArcejCrwR+JfArcejCrwR+JfArcejCrwR+hf7tKgO6mF8J5lfo364yoIv5lWB+JRO6E7qYX0nlB1UqP6hS+UGVyg+qVH5QpfKDKpUfVKn8oErlB1UqP6hnffvJOF/4lcCvBH6F/u0q8CuFXyn8Smu/CVX4lcKv0L9dFX6l8CuFX6F/uyr8SuFXCr/SBl34lcKvtEEXfqXwK4VfaYcu/ErhVwq/0g5d+JXCr9C/XbVDF/MrxfwK/dtVBbqYXynmVyrQFehifnXWt8cz9q5vD9YN3MAdXD757t9+cPnkWd9+8gBPMM4XfqXwK4VfoX+7KvxK4VcKv1LD+cKvFH6F/u2q8CuFXyn8Cv3bVeFXCr9S+JU6dOFXCr/SAV34lcKvFH6lA7rwK4VfKfxKB3ThVwq/Qv921QldzK8U8yv0b1ed0MX8SjG/0gXdBV3Mr8769uMZq/28VGs/L9XKD6pWflC18oOqlR9Uq/281Go/L7Xaz0ut9vNS9G9Xg18Z/MrgV+jfrga/MviVwa+s9ptQg18Z/Ar929XgVwa/MvgV+rerwa8MfmXwK+vQhV8Z/Mo6dOFXBr8y+JUJdOFXBr8y+JUJdOFXBr9C/3Y1gS7mV4b5Ffq3qyl0Mb8yzK9MoavQxfzKaj8vtdrPS63281Kr/bzUaj8vtdrPS63281Kr/bzUaj8vtdrPS63281L0b1eDXxn8yuBX6N+uBr8y+JXBr8xxvvArg1+hf7sa/MrgVwa/Qv92NfiVwa8MfmUDuvArg1/ZhC78yuBXBr+yCV34lcGvDH5lE7rwK4NfoX+72oIu5leG+RX6t6st6GJ+ZZhfefWTUa/9cdQxv/Laz0u99vNSr/281Gs/L/Xaz0u99vNSr/281Gs/L/Xaz0u99vNSr/28FP3b1eFXDr9y+BX6t6vDrxx+5fAr7zhf+JXDr9C/XR1+5fArh1+hf7s6/MrhVw6/coEu/MrhVy7QhV85/MrhV67QhV85/MrhV67QhV85/Ar929UVuphfOeZX6N+ubtDF/Moxv3KDrkEX8yuv/bzUaz8v9drPS73281Kv/bzUaz8v9drPS73281Kv/bzUaz8vPevb9xpIfde3y85jAzdwBwtYwQZ28ABPMHQndCd0J3QndCd0J3QndE+/inM8/ergVXyuXx1cPunwK4dfOfzKq5+MOvzK4VcOv/LqJ6MDfjXgV+jfrqPqr3RgfjUwv0L/dh1Vf6UD86uB+dVo0G3QxfwK/dt1wK8G/GrAr9C/XQf8asCvBvxqdOjCrwb8amC9/V3ffrCDa/wO+NXA/GrgfXDArwb8amB+NfA+OOBXA/OrgffBAb9Cfbuivl1R364DfoX6dkV9u6K+XQf8CvXtivp2HfAr1Lcr6tsV9e064Feob1fUtyvq23XAr1Dfrqhv14H5FerbFfXtivp2HZhfob5dUd+uqG/XgfkV6tsV9e06ql+fjurXp6P69ekYeK6wfoX+7Yr+7Yr+7Yr6dkX/dkX/dkX/dh3ID6J/u6J/uw6st6N/u6J/u6J/uw6st6N/u6J/u6J/uw6st6N/u6J/uw6sXw2stw/kByfqGSbWrybW2yfygxP1DBPr7RP5wYl6hon1K/RvV/RvV/Rv14n1K/RvV/RvV/Rv14n1dvRvV/Rv14n84ER+cCI/OJEfnMgPTvjVRH5wIj84kR+cyA+ivl1R367o367o366ob1fUtyv6tyv6tyvq23UiP4j+7Yr6dkV9u6J/u6J/u6K+XVHfrujfrujfrqhv14n1dvRv1wm/Qn27or5dUd+uE36F+nZFfbuivl0n/Ar17Yr6dp3wK9S3K+rbFfXtOuFXqG9X1Lcr6tt1wq9Q366ob9eJ/OBEfnAiPziRH5zID07kByfygxP5wYn84ER+cCI/OPE+iPp2RX27or5dJ94HUd+uqG9X1LfrxPoV6tsV9e068T44sd6O/u2K/u068T64sN6O/u2K/u26sN6+sN6O/u26sH61sH614FcLfrWwfrWwfrXgVwt+tbB+tbDevuBXC++DC+tXC+vtC/nBhffBhfWrhfX2hfzgwvrVwnr7Qn5wIT+4kB9cyA8u5AcX8oML+cGF/OBCfnAhP7iQH1zIDy7Mrxb8Cv3bFf3bdWF+teBX6N+u6N+uC/OrBb9C/3ZdmF8t+BX6tyv6t+vC/GrBr9C/XdG/XRfmVwt+hf7tujC/WvAr9G9X9G/XhfnVgl+hf7uif7suzK8W/Ar923Vh/Wph/WphvX1hfrWwfrWwfrWw3r4wv1pYv1pYb1/IDy7kBxfygwv5wYX84EJ+cCE/uJAfXMgPLuQHF/KDC/nBhffBBb9a8KsFv1p4H1zlV7aVX9lWfmVbrV/ZVn5lW/mVbfU+aFv5lW3lV7aVX9m2QbdBt0G3/Mq2Bt0G3fIr2xp0G3QbdMuvXmkE6HboduiWX9nWoduhW35l6N9u6N9uW4duza8M/dsN/dttE+jW/MrQv902gW7Nr2yr/KBtlR+0rfKDtlV+0LbKD9pW+UHbKj9oW+UHbav8oG2VH7St8oOG/u2G/u22lV/ZVn5l6N9u6N9uW/mVbeVXhv7ttpVf2VZ+ZejfbujfbptDt/zK0L/d0L/dNodu+ZWhf7ttDt3yK9sGdAd0B3TLr2wb0B3QHdAtv7JtQHdCt/zK0L/dtgndCd2J8TuhO6E7oTsxfhd0F3QXfKPyg7ZVftC2yg/aVvlB2yo/aFvlB22r/KC1yg++uIE7WMB1vg1+1eBXDX6F/u3W4FcNftXgV63Wr6zBrxr8Cv3brcGvGvyqwa/Qv90a/KrBrxr8qnXowq8a/Kp16MKvGvyqwa+aQBd+1eBXDX7VBLrwqwa/Qv92awJdgW7Nrwz9260pdBW6Nb+yptBV6Nb8ylrlB61VftBa5QetVX7QWuUHrVV+0FrlB61VftBa5QetVX7QWuUHDf3brcGvGvyqwa/Qv90a/KrBrxr8qjnOF37V4Ffo324NftXgVw1+hf7t1uBXDX7V4FdtQBd+1eBXbUIXftXgVw1+1SZ04VcNftXgV21CF37V4Ffo325tQXdBd2H8Lugu6C7oYn7Va73deq23W8f8qld+0HrlB61XftB65QetV37QeuUHrVd+0HrlB61XftB65QetV37Q0L/dOvyqw686/Ar9263Drzr8qsOvesf5wq86/Ar9263Drzr8qsOv0L/dOvyqw686/KoLdOFXHX7VBbrwqw6/6vCrrtCFX3X4VYdfdYUu/KrDr9C/3bpCF/OrjvkV+rdbN+hiftUxv+oGXYMu5le98oPWKz9ovfKD1is/aL3yg9YrP2i98oPWKz9ovfKD1is/aGd9+8k4X/hVh191+BX6t1uHX3X4VYdf9YHzhV91+BX6t1uHX3X4VYdfoX+7dfhVh191+FWf0IVfdfhVX9CFX3X4VYdf9QVd+FWHX3X4Va/8oAn8SuBX6N9uUvlBE8yvBPMr9G83qfygCeZXgvmVNOg26GJ+dda3xzP2rm8/2MAOHuDyyXf/9uBePnnWt5/cwQLG+cKvBH4l8Cv0bzeBXwn8SuBXIjhf+JXAr9C/3QR+JfArgV+hf7sJ/ErgVwK/EoUu/ErgV6LQhV8J/ErgV2LQhV8J/ErgV2LQhV8J/Ar9200MuphfCeZX6N9u4tDF/EowvxKHrkMX86uzvv14xmo/L5Paz8uk8oMmlR80qfygSeUHTWo/L5Paz8uk9vMyqf28DP3bTeBXAr8S+BX6t5vArwR+JfArmThf+JXAr9C/3QR+JfArgV+hf7sJ/ErgVwK/kgVd+JXCr7T6yZjCrxR+pfArrX4ypvArhV8p/Eo36MKvFH6F/u2mDbqYXynmV+jfbtqgi/mVYn6lHboduphfae3nZVr7eZnWfl6mtZ+Xae3nZVr7eZnWfl6mtZ+Xae3nZVr7eZnWfl6G/u2m8CuFXyn8Cv3bTeFXCr9S+JUqzhd+pfAr9G83hV8p/ErhV+jfbgq/UviVwq/UoAu/UviVGnThVwq/UviVOnThVwq/UviVOnThVwq/Qv92U4cu5leK+RX6t5sO6GJ+pZhf6YDugC7mV1r7eZnWfl6mtZ+Xae3nZVr7eZnWfl6mtZ+Xae3nZVr7eZnWfl6mtZ+XoX+7KfxK4VcKv0L/dlP4lcKvFH6lC+cLv1L4Ffq3m8GvDH5l8Cv0bzeDXxn8yuBXVv2vzOBXBr+yBl34lcGvDH5lDbrwK4NfGfzKGnThVwa/Qv92sw5dzK8M8yv0bzfr0MX8yjC/MoGuQBfzK6v9vMxqPy+z2s/LrPbzMqv9vMxqPy+z2s/LrPbzMqv9vMxqPy8769v3Gkh717dLsIEdPMATvIptAzdwBwsYugZdg65B16Br0HXoOnRPv4pzPP3qYAUbuHzS4FcGvzL4lVU/GTP4lcGvDH5l1U/GDH5l8Cv0bzcb0MX8yjC/Qv92swldzK8M8yub0J3QxfwK/dvN4FcGvzL4Ffq3m8GvDH5l8Ctb0IVfGfzKsN7+rm8/uIFr/Dr8yjG/crwPOvzK4VeO+ZXjfdDhV475leN90OFXqG831Lcb6tvN4VeobzfUtxvq283hV6hvN9S3m8OvUN9uqG831Lebw69Q326obzfUt5vDr1DfbqhvN8f8CvXthvp2Q327OeZXqG831Lcb6tvNMb9Cfbuhvt28+vWZV78+8+rXZ654rrB+hf7thv7thv7thvp2Q/92Q/92Q/92c+QH0b/d0L/dHOvt6N9u6N9u6N9ujvV29G839G839G83x3o7+rcb+rebY/3Ksd7uyA/6wP3F+pVjvd2RH/SB+4v1dkd+0CeeK6xfoX+7oX+7oX+7Odav0L/d0L/d0L/dHOvt6N9u6N9ujvygIz/oyA868oOO/KDDrwbygwP5wYH84EB+EPXthvp2Q/92Q/92Q327ob7d0L/d0L/dUN9uA/lB9G831Lcb6tsN/dsN/dsN9e2G+nZD/3ZD/3ZDfbsNrLejf7sN+BXq2w317Yb6dhvwK9S3G+rbDfXtNuBXqG831LfbgF+hvt1Q326ob7cBv0J9u6G+3VDfbgN+hfp2Q327DeQHB/KDA/nBgfzgQH5wID84kB8cyA8O5AcH8oMD+cGB90HUtxvq2w317TbwPoj6dkN9u6G+3QbWr1Dfbqhvt4H3wYH1dvRvN/Rvt4H3wYH1dvRvN/Rvt4H19oH1dvRvt4H1q4H1qwG/GvCrgfWrgfWrAb8a8KuB9auB9fYBvxp4HxxYvxpYbx/IDw68Dw6sXw2stw/kByfWrybW2yfygxP5wYn84ER+cCI/OJEfnMgPTuQHJ/KDE/nBifzgRH5wYn414Vfo327o324T86sJv0L/dkP/dpuYX034Ffq328T8asKv0L/d0L/dJuZXE36F/u2G/u02Mb+a8Cv0b7eJ+dWEX6F/u6F/u03Mryb8Cv3bDf3bbWJ+NeFX6N9uE+tXE+tXE+vtE/OrifWrifWrifX2ifnVxPrVxHr7RH5wIj84kR+cyA9O5Acn8oMT+cGJ/OBEfnAiPziRH5zID068D0741YRfTfjVxPvghF9N+NWEX02sX0341YRfTbwPTvjVhF9N+NXE++CEX0341YRfTay3T/jVhF9NvA9O+NWEX0341cT74IRfTfjVhF9NrF8t+NWCX6F/u6F/uy3MrxbmV+jfbujfbgvzq4X5Ffq328L74ML8aiE/uJAfXMgPLuQHF/KDC/nBhfzgQn5wIT+4kB9cyA+if7uhf7st+NWCX6F/u6F/uy341YJfoX+7LfjVgl+hf7uhf7st+NWCX6F/u6F/uy341YJfoX+7LfjVgl8trLcv+NWCXy341cJ6+4JfLfjVgl8trLcv+NWCX6F/uy2sty/MrxbmV+jfbgvr7Qvzq4X51cJ6+8J6+8L8aiE/uJAfXMgPLuQHF/KDC/nBhfzgQn5wIT+4kB9cyA+if7st+NWCXy34Ffq324JfLfjVgl8trF8t+NWCX6F/uy341YJfLfgV+rfbgl8t+NWCXy2sX63yK9/Kr3yr9Xbfyq98K7/yrfzKt1pv9638yrfyK9/Kr3zboNugW37l6N/uW4Nug27Nrxz9231r0G3QrfnVa1kOuh26Nb/yrfKDvlV+0LfKD/pW+UHfKj/oW+UHfav8oG+VH/St8oO+VX7Qt8oPOvq3+yY43/Ir38qvHP3bfROcb/mVb+VXvinOt/zKt/IrR/923xS6Ct3yK0f/dt8Mugbd8ivfDLoG3fIr3wy6Bl2DbvmVbw5dh65Dt/zKN4euQ7f8ytG/3TeHrkO35leO/u2+DegO6Nb8yrcB3QHdml/5VvlB3yo/6FvlB32r/KBvlR/0rfKDvlV+0LfKD/pW+UHfKj/oW+UHHf3bfVs43wXfWBi/C+e7cL4LvrEwfhfOt/zKN/gV+re/uIE7WMCl2+BXDX7V4Fet8oPe4FcNftUadOFXDX7V4FetQRd+1eBXDX7VGnThVw1+hf7t3jp0O3RrfuXo3+6tQ7dDt+ZX3gS6At2aX3mr/KC3yg96q/ygt8oPeqv8oLfKD3qr/KC3yg96q/ygt8oP+lnffjLOF37V4FcNfoX+7d7gVw1+1eBXzXC+8KsGv0L/dm/wqwa/avAr9G/3Br9q8KsGv2oOXfhVg181hy78qsGvGvyqDejCrxr8qsGv2oAu/KrBr9C/3duA7oDuxPid0J3QndCdGL8TuhO6Nb/ys779eMZm+eS7vv3gBu7g8sl3//aDyyfP+vaTB3iC63w7/KrDrzr8Cv3bvcOvOvyqw6969WfwDr/q8Cv0b/cOv+rwqw6/Qv927/CrDr/q8KveoAu/6vCr3qELv+rwqw6/6h268KsOv+rwq96hC7/q8Cv0b/cu0MX8qmN+hf7t3gW6mF91zK+6Qlehi/nVWd8ez1iv/by8135e3is/6L3yg94rP+i98oPeaz8v77Wfl/faz8t77efl6N/uHX7V4VcdfoX+7d7hVx1+1eFX3XG+8KsOv0L/du/wqw6/6vAr9G/3Dr/q8KsOv+oDuvCrDr/qA7rwqw6/6vCrPqELv+rwqw6/6hO68KsOv0L/du8Tuphfdcyv0L/d+4Iu5lcd86u+oLugi/lVr/28vNd+Xi61n5dL7eflUvt5udR+Xi61n5dL7eflUvt5udR+Xi61n5ejf7sL/ErgVwK/Qv92F/iVwK8EfiXVT8YFfiXwK/Rvd4FfCfxK4Ffo3+4CvxL4lcCvpEMXfiXwKxHowq8EfiXwKxHowq8EfiXwKxHowq8EfoX+7S4KXcyvBPMr9G93UehifiWYX4lB16CL+ZXUfl4utZ+XS+3n5VL7ebnUfl4utZ+XS+3n5VL7ebnUfl4utZ+XS+3n5ejf7gK/EviVwK/Qv90FfiXwK4FfycD5wq8EfoX+7S7wK4FfCfwK/dtd4FcCvxL4lUzowq8EfiUTuvArgV8J/EoWdOFXAr8S+JUs6MKvBH6F/u0uC7qYXynmV+jf7lr9ZFwxv1LMr7T6ybhW/ytXzK+09vNyrf28XGs/L9faz8u19vNyrf28XGs/L9faz8u19vNyrf28/Kxv32sg/V3fLjv3DdzAHSxgBRvYwQM8wdAV6Ap0BboCXYGuQFege/pVnOPpVwev4nP96uDySYVfKfxK4Vda/WRc4VcKv1L4lVY/GVf4lcKv0L/d1aCL+ZVifoX+7a4GXcyvFPMrdeg6dDG/Qv92V/iVwq8UfoX+7a7wK4VfKfxKB3ThVwq/0oHn+ZxfHezgGr8Kv1LMrxTvgwq/UviVYn6leB9U+JVifqV4H1T4FerbHfXtjvp2V/gV6tsd9e2O+nZX+BXq2x317a7wK9S3O+rbHfXtbvAr1Lc76tsd9e1u8CvUtzvq290wv0J9u6O+3VHf7ob5FerbHfXtjvp2N8yvUN/uqG93q359btWvz6369blVvz5Hfbujf7ujf7ujf7ujvt3Rv93Rv93Rv92t8oOO/u2O/u1uWG9H/3ZH/3ZH/3Y3rLejf7ujf7ujf7sb1tvRv93Rv90N61eG9XZT6BruL9avDOvtZtA13F+st5tB1/BcYf0K/dsd/dsd/dvdsH6F/u2O/u2O/u1uWG9H/3ZH/3a3yg+6VX7QbeC5GniuBp4r+JVVftCt8oNulR90q/ygo77dUd/u6N/u6N/uqG931Lc7+rc7+rc76tvdJs53YhzBr1Df7ujf7ujf7qhvd9S3O/q3O/q3O+rb3bDejv7t7vAr1Lc76tsd9e3u8CvUtzvq2x317e7wK9S3O+rb3eFXqG931Lc76tvd4Veob3fUtzvq293hV6hvd9S3uyM/6MgPOvKDjvygIz/oyA868oOO/KAjP+jIDzryg473QdS3O+rbHfXt7ngfRH27o77dUd/ujvUr1Lc76tvd8T7oWG9H/3ZH/3Z3vA861tvRv93Rv90d6+2O9Xb0b3fH+pVj/crhVw6/cqxfOdavHH7l8CvH+pVjvd3hV473Qcf6lWO93ZEfdLwPOtavHOvtjvygY/3Ksd7uyA868oOO/KAjP+jIDzryg478oCM/6MgPOvKDjvygIz/omF85/Ar92x39290xv3L4Ffq3O/q3u2N+5fAr9G/3gfnVgF+hf7ujf7sPzK8G/Ar92x39231gfjXgV+jf7gPzqwG/Qv92R/92H5hfDfgV+rc7+rf7wPxqwK/Qv90H1q8G1q8G1tsH5lcD61cD61cD6+0D86uB9auB9faB/OBAfnAgPziQHxzIDw7kBwfygwP5wYH84EB+cCA/OJAfHHgfHPCrAb8a8KuB98EBvxrwqwG/Gli/GvCrAb8aeB8c8KsBvxrwq4H3wQG/GvCrAb8aWG8f8KsBvxp4HxzwqwG/GvCrgffBAb8a8KsBvxpYvxrwqwG/Qv92R/92H5hfDcyv0L/d0b/dB+ZXA/Mr9G/3gffBgfnVQH5wID84kB8cyA8O5AcH8oMD+cGB/OBAfnAgPziQH0T/dkf/dp/wqwm/Qv92R/92n/CrCb9C/3af8KsJv0L/dkf/dp/wqwm/Qv92R/92n/CrCb9C/3af8KsJv5pYb5/wqwm/mvCrifX2Cb+a8KsJv5pYb5/wqwm/Qv92n1hvn5hfTcyv0L/dJ9bbJ+ZXE/OrifX2ifX2ifnVRH5wIj84kR+cyA9O5Acn8oMT+cGJ/OBEfnAiPziRH0T/dp/wqwm/mvAr9G/3Cb+a8KsJv5pYv5rwqwm/Qv92n/CrCb+a8Cv0b/cJv5rwqwm/mli/mvCrCb+aWG+f8KsJv5rwq4n19gm/mvCrCb+aWG+f8KsJv0L/dp9Yv5qYX03Mr9C/3SfWrybmVxPzq4n19on1q4n51UR+cCI/uJAfXMgPLuQHF/KDC/nBhfzgQn5wIT+4kB9E/3Zf8KsFv1rwK/Rv9wW/WvCrBb9ayA8u+NWCX6F/uy/41YJfLfgV+rf7gl8t+NWCXy3kBxf8asGvFvKDC3614FcLfrWQH1zwqwW/WvCrhfzggl8t+BX6t/vCevvC/GphfoX+7b6w3r4wv1qYXy2sty+sty/Mrxbygwv5wYX84EJ+cCE/uJAfXMgPLuQHF/KDC/nBhfwg+rf7gl8t+NWCX6F/uy/41YJfLfjVwnr7gl8t+BX6t/uCXy341YJfoX+7L/jVgl8t+NVCfnDBrxb8aiE/uOBXC3614FcL+cEFv1rwqwW/WsgPLvjVgl+hf7sv5AdXza/GVvOrgf7tY6v84NhqfjW2ml+NrfKDY6v84NhqfjW2yg+OrfKDY6v84NgqPzi2yg+OrfKDY6v84NgqPzi2yg+OrfKDL55gnG/H+ZZfja38aqB/+9g6zrf8amzlV2PrON/yq7GVXw30bx+bQFegW3410L99bAJdgW751dgEugLd8quxKXQVugrd8quxKXQVugrd8quxKXQNuuVXA/3bx2bQNejW/Gqgf/vYDLoG3Zpfjc2h69Ct+dU469uPZ8wVbGAHD3D65Hj3bw8e6ZPjrG8/uYMFjPMdON/yq7GVXw30bx/bwPmWX41tYvxOnG/51djKrwb6t49tQndCt/xqoH/72BZ0F3QXfGNBd0F3wTcWdBd0F3ThV632m3hxA3ewgEu3wa8a/Ar920er/SZG26Bb86uB/u2jNeg26Nb8arQG3Qbdml+Ns749nrFW+3mNVvt5jVb5wdEqPzha5QdHq/zgaLWf12i1n9dotZ/XaLWf10D/9tHgVw1+1eBX6N8+Gvyqwa8a/KoJzhd+1eBX6N8+Gvyqwa8a/Ar920eDXzX4VYNfNYUu/KrBr5pBF37V4FcNftUMuvCrBr9q8Ktm0IVfNfgV+reP5tB16Nb8aqB/+2gOXYduza9GG9Ad0K351Wi1n9dotZ/XaLWf12i1n9dotZ/XaLWf12i1n9dotZ/XaLWf12i1n9dotZ/XQP/20eBXDX7V4Ffo3z4a/KrBrxr8qi2cL/yqwa/Qv300+FWDXzX4Ffq3jw6/6vCrDr/qtT/O6PCrDr/q1U9mdPhVh191+FVv0IVfdfhVh1/1Bl34VYdfoX/76A26mF91zK/Qv330Dl3MrzrmV71Dt0MX86te+3mNXvt5jV77eY1e+3mNXvt5jV77eY1e+3mNXvt5jV77eY1e+3mNXvt5DfRvHx1+1eFXHX6F/u2jw686/KrDr7rifOFXHX6F/u2jw686/KrDr9C/fXT4VYdfdfhVN+jCrzr8qjt04VcdftXhV92hC7/q8KsOv+oOXfhVh1+hf/voA7qYX3XMr9C/ffQBXcyvOuZXfUJ3Qhfzq177eY1e+3mNXvt5jV77eY1e+3mNXvt5jV77eY1e+3mNXvt5/b9M3VGW4zgORNEtCSRIAPvfWHemnaX75xjPaYVl10tCYBC13nle9d3f/rMHsv72t+/f14fXl9fF6+b1v32M9d3f/n0dvF683rxOXh9eX14Xr5vXXDe4bnDdL6/O7+vN6+T14fXLyQ2vNrza8Gq/58nUhlcbXm14td/zZGrDqw2vOL+99uK6rK826yvOb6+9uS7rq836am+uu7ku6yvOb68Nrza82vCK89trw6sNrza82sl14dWGV/t93l5/+9s/r4PX77/fDa8266tNPbjh1YZXm/XVph7c8GqzvtrUgxtesb+92N9e7G+vDa/Y317sby/2t9eGV+xvL/a314ZX7G8v9rcX+9trwyv2txf724v97bXhFfvbi/3ttVlfsb+92N9e7G+vzfqK/e3F/vZif3tt1lfsby/2t9d+z+ur/Z7XV/s9r6/2e15fsb+9OL+9OL+9OL+92N9enN9enN9enN9e+fYHi/Pbi/PbK4PrBtcNrvvuZ6gMrhtcN7juu5+hMrju4rrvfoZKnl/l4rqL6777GSp5fpWL6y6u++5nqNxcd3Pddz9DJc+vOL+9OL+9OL+9kudXnN9enN9enN9emVw3ue67/6ry7Q9Wvv3Byrc/WPn2Byvf/mAlvMq3P1j59gcr3/5g5dsfLPa3F/vbi/Pbi/Pbi/3txf724vz24vz2Yn975eXzvv3BYn97sb+9OL+9OL+92N9e7G8vzm8vzm8v9rdXFtd9+4OV8Ir97cX+9mJ/eyW8Yn97sb+92N9eCa/Y317sb6+EV+xvL/a3F/vbK+EV+9uL/e3F/vZKeMX+9mJ/e+XbH6x8+4N13v5gnbc/WOftD9Z5+4N13v5gnbc/WOftD9Z5+4N13v5gHepB9rcX+9uL/e11qAfZ317sby/2t9fh+RX724v97XWoBw/P2zm/vTi/vQ714OF5O+e3F+e31+F5++F5O+e31+H51eH51YFXB14dnl8dnl8deHXg1eH51eF5+4FXh3rw8Pzq8Lz9vP3BOtSDh+dXh+ft5+0P1uH51eF5+3n7g3Xe/mCdtz9Y5+0P1nn7g3Xe/mCdtz9Y5+0P1nn7g3Xe/mCdtz9Y5+0P1mF9deAV57cX57fXYX114BXntxfnt9dhfXXgFee312F9deAV57cX57fXYX114BXntxfnt9dhfXXgFee312F9deAV57cX57fXYX114BXntxfnt9dhfXXgFee31+H51eH51eF5+2V9dXl+dXl+dXnefllfXZ5fXZ63X/qDl/7gpT946Q9e+oOX/uClP3jpD176g5f+4KU/eOkPXurBC68uvLrw6lIPXnh14dWFV5fnVxdeXXh1qQcvvLrw6sKrSz144dWFVxdeXZ63X3h14dWlHrzw6sKrC68u9eCFVxdeXXh1eX514dWFV5zfXpzfXpf11WV9xfntxfntdVlfXdZXnN9el3rwsr669Acv/cFLf/DSH7z0By/9wUt/8NIfvPQHL/3BS3+Q89uL89vrwqsLrzi/vTi/vS68uvCK89vrwqsLrzi/vTi/vS68uvCK89uL89vrwqsLrzi/vS68uvDq8rz9wqsLry68Kp63F7wqeFXwqnjeXvCq4BXnt1fxvL1YXxXrK85vr+J5e7G+KtZXxfP24nl7sb4q+oNFf7DoDxb9waI/WPQHi/5g0R8s+oNFf7DoD3J+exW8KnhV8Irz26vgVcGrglfF86uCVwWvOL+9Cl4VvCp4xfntVfCq4FXBq+L5VcGrglfF8/aCVwWvCl4Vz9sLXhW8KnhVPG8veFXwivPbq3h+VayvivUV57dX8fyqWF8V66vieXvx/KpYXxX9waI/WPQHi/5g0R8s+oNFf7DoDxb9waI/WPQHOb+9Cl4VvCp4xfntVfCq4FXBq6I/WPCq4BXnt1fBq4JXBa84v70aXjW8anjV9AcbXjW8avqDDa8aXjW8avqDDa8aXjW8avqDDa8aXnF+ezXP25v1VbO+4vz2ap63N+urZn3VPG9vnrc366umP9j0B5v+YNMfbPqDTX+w6Q82/cGmP9j0B5v+IOe3V8OrhlcNrzi/vRpeNbxqeNU8b2941fCK89ur4VXDq4ZXnN9eDa8aXjW8avqDDa8aXjX9wYZXDa8aXjX9wYZXDa8aXjX9wYZXDa84v72a/mCzvmrWV5zfXk1/sFlfNeurpj/Y9Aeb9VXTH2z6g01/sOkPNv3Bpj/Y9Aeb/mDTH2z6g9/97d/XfF541fCq4RXnt1fDq4FXA6/mnTdRA68GXnF+ew28Gng18Irz22vg1cCrgVcTXBdeDbwa+oMDrwZeDbwa+oMDrwZeDbwa+oMDrwZecX57Df3BYX01rK84v72G/uCwvhrWV0N/cOgPDuur7/7239/Y3/7239f58Dp4vXj9cvLv/PbP65eT3/3t39fF6+Y1nxdeDbwaeMX57TXwauDVwKs5fF54NfCK89tr4NXAq4FXnN9eA68GXg28mst14dXAqymuC68GXg28muK68Grg1cCrKa4LrwZecX57TXNd1lfD+orz22ua67K+GtZXM1x3uC7rq+/+9s9v7J3nVfPO86qhPzj0B4f+4Lz9wX7eeV79vPO8+nnnefXzzvNqzm/v5+VVPy+v+nl51Zzf3s/Lq35eXvXz8qqfd95EPy+v+nl51Zzf3k9w3eC6L6/+f811F9ddXPflVT+L6y6u+/Kqn8V1F9ddXPflVT+b626uu7nuy6t+NtfdXPflVXN+ez+b626u+66vmvPb+0mum1z3XV/1k1w3ue67vurnnefVzzvPq593nlc/7zyvft55Xv2887z6eed59fPO8+rnnefVzzvPq593nldzfns/l8/78qqfl1fN+e39XD7vy6t+Xl71c/m8L6/6eXnVnN/eT3Hd4rovr5rz2/sprltc9+VVP8V1i+u+vOqnuW5z3ea6zb/f5rrNdZvrNv9+m+sO13151Zzf3s9w3eG6w7/f4brDdYfrvuurjvc8mf9fB68Xr/9xsuOd59XxzvPqeOd5dbzzvDreeV4d7zyvjneeV8c7z6vjnefV8c7zas5v74BXAa8CXnF+ewe8CngV8CoWnxdeBbzi/PYOeBXwKuAV57d3wKuAVwGvYnNdeBXwKjbXhVcBrwJeRXJdeBXwKuBVJNeFVwGvOL+9I7luct13fdWc395xuO7huu/6quNw3cN13/VVxzvPq+Od59XxzvPqeOd5dbzzvDreeV4d7zyvjneeV8c7z6vjnefV3/3tP3sg+29/+/55XQ+vg9eL15vXyevD68vr4nXzmus2122u21y3uW5z3ea6zXW/vPr9jF9efV7P+/r7/Orz+uVkwKuAVwGv4j1PpgNeBbwKeBXveTK94NWCV5zf3uvdf9WL9dVifcX57b3e/Ve9WF8t1lcruG5wXdZXnN/eC14teLXgFee394JXC14teLUW14VXC16t93l7/+1v/7y+vH7//S54tVhfrbce7AWvFrxarK/WWw/2gleL9dV668Fe8Ir97c3+9mZ/ey94xf72Zn97s7+9F7xif3uzv70XvGJ/e7O/vdnf3gtesb+92d/e7G/vBa/Y397sb+/F+or97c3+9mZ/ey/WV+xvb/a3N/vbe7G+Yn97s7+913teX6/3vL5e73l9vYrfVfF7Ln7Pxe+q+H6L33Pze25+V8332/ye3/5gc357r+a6zXWb6zbf73Dd4brDdYfvd7jucN3hdzVcd7ju2x/s/e5n6P0+v+r9Pm/v/fYHe7/7GXq/z9t7v/3B3u9+ht7v86vm/Pbm/Pbm/PbewXWD6wbXffdf9Q6uG1z33X/V++0P9n77g73f/mDvtz/Y++0P9oZX++0P9n77g73f/mDvtz/Y7G9v9rc357c357c3+9ub/e3N+e3N+e3N/vbem8/79geb/e3N/vbm/Pbm/PZmf3uzv705v705v73Z3947ue7bH+wNr9jf3uxvb/a394ZX7G9v9rc3+9t7wyv2tzf723vDK/a3N/vbm/3tveEV+9ub/e3N/vbe8Ir97c3+9t5vf7D32x/s/fYHe7/9wd5vf7D32x/s/fYHe7/9wd5vf7D32x/s/fYHe1MPsr+92d/e7G/vTT3I/vZmf3uzv7338Hnf/mCzv7039eAerguvOL+9N/Vgvs/bm/Pbm/PbO9/n7Z3v8/bm/PZOnl8lz68SXiW8Sp5fJc+vEl4lvEqeX2VwXXiV1IPJ86sMrvv2BzupB5PnV7m47tsf7OT5VS6u+/YHO9/+YOfbH+x8+4Odb3+w8+0Pdr79wc63P9j59gc73/5g59sf7Hz7g52srxJecX57c357J+urhFec396c397J+irhFee3d7K+SnjF+e3N+e2drK8SXnF+e3N+eyfrq4RXnN/eyfoq4RXntzfnt3eyvkp4xfntzfntnayvEl5xfnsnz6+S51dZXJf1VfL8Knl+lcV1WV8lz6+yue7bH+x8+4Odb3+w8+0Pdr79wc63P9j59gc73/5g59sf7Hz7g51vf7Dz7Q92Ug8mvEp4lfAqqQcTXh14deDV4fnVgVcHXh3qwQOvDrw68OpQDx54deDVgVeH5+0HXh14dagHD7w68OrAq0M9eODVgVcHXh2eXx14deAV57c357f3YX11WF9xfntzfnsf1leH9RXnt/ehHjysr87bH+zz9gf7vP3BPm9/sM/bH+zz9gf7vP3BPm9/sM/bH+zz9gf7vP3B5vz25vz2PvDqwCvOb2/Ob+8Drw684vz2PvDqwCvOb2/Ob+8Drw684vz25vz2PvDqwCvOb+8Drw68OjxvP/DqwKsDrw7P2w+8OvDqwKvD8/YDrw684vz2PjxvP6yvDusrzm/vw/P2w/rqsL46PG8/PG8/rK/O2x/s8/YH+7z9wT5vf7DP2x/s8/YH+9AfvPQHL/3BS3/w0h/k/Pa+8OrCqwuvOL+9L7y68OrCq8vzqwuvLrzi/Pa+8OrCqwuvOL+9L7y68OrCq8vzqwuvLry6PG+/8OrCqwuvLs/bL7y68OrCq8vz9guvLrzi/Pa+PL+6rK8u6yvOb+/L86vL+uqyvro8b788v7qsry79wUt/8NIfvPQHL/3BS3/w0h+89Acv/cFLf/DSH+T89r7w6sKrC684v70vvLrw6sKrS3/wwqsLrzi/vS+8uvDqwivOb+8Lry68uvDq0h+88OrCq0t/8MKrC68uvLr0By+8uvDqwqtLf/DCqwuvOL+9L8/bL+ury/qK89v78rz9sr66rK+K5+3F8/ZifVX0B4v+YNEfLPqDRX+w6A8W/cGiP1j0B4v+YNEf5Pz2LnhV8KrgFee3d8GrglcFr4rn7QWvCl5xfnsXvCp4VfCK89u74FXBq4JXRX+w4FXBq6I/WPCq4FXBq6I/WPCq4FXBq6I/WPCq4BXnt3fRHyzWV8X6ivPbu+gPFuurYn1V9AeL/mCxvir6g0V/sOgPFv3Boj9Y9AeL/mDRHyz6g0V/8Lu//fuazwuvCl4VvOL89i54VfCq4FUVnxdeFbzi/PYueFXwquAV57d3wauCVwWvqrkuvCp4VfQHC14VvCp4VfQHC14VvCp4VfQHG141vOL89m76g836qllfcX57N/3BZn3VrK+a/mDTH2zWV9/97b+/sb/97Z/Xh9eX18Xrl5N/57f/vl4vJ7/727+vF683r/m88KrhVcMrzm/vhlcNrxpe9ebzwquGV5zf3g2vGl41vOL89m541fCq4VUn14VXDa86uS68anjV8KoP14VXDa8aXvXhuvCq4RXnt3cfrsv6qllfcX579+W6rK+a9VVfrnu5Luur7/72z2/snefV/c7z6qY/2PQHm/5g0x/sd55X9zvPq/ud59X9zvNqzm/vhlcNrxpecX57N7xqeNXwqpvPC68aXnF+eze8anjV8Irz27vhVcOrhlc9XBdeDbya9zyZHng18Grg1bznyfTAq4FXA6/m4brwauAV57f3sJ9hWF8N6yvOb+9hP8OwvhrWV7O4LvsZhvXVvPO8et55Xj3vPK+ed55XzzvPq+ed59XzzvPqeed59bzzvHreeV497zyv5vz2Hng18GrgFee398CrgVcDryb5vPBq4BXnt/fAq4FXA684v70HXg28Gng1h+vCq4FXc7guvBp4NfBqLteFVwOvBl7N5brwauAV57f3XK7L+mpYX3F+e09xXdZXw/pqiusW12V9Ne88r553nlfPO8+r553n1fPO8+p553n1vPO8et55Xj3vPK+ed55XzzvPqzm/vQdeDbwaeMX57T3wauDVwKsZPi+8mpdXw/nt87y8mufl1Twvr4bz2+d5eTXPy6t5Xl7N855/Nc/DdV9ezRNcN7hucN2XV/ME1w2uG1z35dX/r7nu4rovr4bz2+dZXHdx3Xd9NZzfPs/iuovrvuureTbX3Vz3XV/N887zmued5zXPO89rnnee1zzvPK953nle87zzvOZ553nN887zmued5zXf/e0/eyDnb3/7/n19eH15XbxuXs/7+jy8Dl4vXm9ec93DdQ/XPVz3cN3DdS/XvVz3y6vfz/jl1ed18vrw+r7f9cureV5ezfPyap73PJl5Xl7N8/JqnpdX87znyczz8mqel1fD+e3zFNctrtv8+22u21y3uW7z77e5bnPdd301nN8+T3Pd4brDv9/husN1h+sO/36H6w7XHbjxPm+fv/3tn9fB6/ffb8CreNdXE289OAGvAl7Fu76aeOvBCXgV7/pq4q0HJ+AV+9uH/e3D/vYJeMX+9mF/+7C/fQJesb992N8+Aa/Y3z7sbx/2t0/AK/a3D/vbh/3tE/CK/e3D/vaJzXU3191c960HJzbXTa6bXPetByeS6ybXfevBife8von3vL6J97y+ieR39T6/Gs5vH85vH85vH/a3D+e3D+e3D+e3T7z9weH89uH89onLdS/XvVz38v1ernu57uW6l+/3ct3iusXvqrhucd3iusX3W1y3uG5x3eL7ba7bXLf5XTXXba7bXLf5XTXXba7bXHf4XQ3XHa47/K7e/uDE2x+cGH5Xw+9q+F3Bq/X2B2e9/cFZb39w1tsfHPa3D/vbh/Pbh/Pbh/3tw/724fz24fz2YX/7rLc/OJzfPuxvH/a3D+e3D+e3D/vbh/3tw/ntw/ntw/72WYvrvv3BWfCK/e3D/vZhf/sseMX+9mF/+7C/fRa8Yn/7sL99Frxif/uwv33Y3z4LXrG/fdjfPuxvnwWv2N8+7G+f9fYHZ739wVlvf3DW2x+c9fYHZ739wVlvf3DW2x+c9fYHZ739wVlvf3DW4fNePi+8Yn/7rMvnvXxeeMX+9lmXz/v2B4f97bOK6xbXhVec3z6ruG5xXXjF+e2ziusW14VXq7luc114teDVaq7bXBdeLXi1musO14VXa7jucN3husO/3+G6w3WH6779wdnv86vZ7/P22W9/cPbbH5z99gdnv/3B2W9/cPbbH5z99gdnv/3B2W9/cPbbH5z99gdnv/3B2ayvNrzi/Pbh/PbZrK82vOL89uH89tmsrza84vz22ayvNrzi/Pbh/PbZrK82vOL89uH89tmsrza84vz22ayvNrzi/Pbh/PbZrK82vOL89uH89tmsrza84vz22cl1k+sm12V9tQ/XPVz3cF3WV/tw3cN13/7g7Lc/OPvtD85++4Oz3/7g7Lc/OPvtD85++4Oz3/7g7Lc/OPvtD85++4OzqQc3vNrwasOrTT244dWGVxte7eLzwqsNrzb14IZXG15teLWpBze82vBqw6vdXBdebXi1qQc3vNrwasOrTT244dWGVxtebZ5fJbxKeMX57cP57ZOsr5L1Fee3D+e3T7K+StZXnN8+ST2YrK/y7Q9Ovv3Bybc/OPn2Byff/uDk2x+cfPuDk29/cPLtD06+/cHJtz84nN8+nN8+Ca8SXnF++3B++yS8SnjF+e2T8CrhFee3D+e3T8KrhFec3z6c3z4JrxJecX77JLxKeJXJdeFVwquEV3m4LrxKeJXwKg/XhVcJrzi/ffJwXdZXyfqK89snL9dlfZWsr/Jy3ct1WV/l2x+cfPuDk29/cPLtD06+/cHJtz84+fYHJ9/+4OTbH5x8+4OTb39wOL99El4lvEp4xfntk/Aq4VXCq+T5VcKrhFec3z4JrxJeJbzi/PZJeJXwKuFV8vwq4dWBV4fn7QdeHXh14NXhefuBVwdeHXh1eN5+4NWBV5zfPofnV4f11WF9xfntc3h+dVhfHdZXh+fth+dXh/XVefuDc97+4Jy3Pzjn7Q/OefuDc97+4Jy3Pzjn7Q/OefuDc97+4Jy3Pzic3z4HXh14deAV57fPgVcHXh14dZLPC68OvOL89jnw6sCrA684v30OvDrw6sCrc7guvDrw6hyuC68OvDrw6lyuC68OvDrw6lyuC68OvOL89jk8bz+srw7rK85vn8Pz9sP66rC+OjxvPzxvP6yvztsfnPP2B+e8/cE5b39wztsfnPP2B+e8/cE5b39wztsfnPP2B+e8/cHh/PY58OrAqwOvOL99Drw68OrAq8Pz9gOvDrzi/Pa58OrCqwuvOL99Lry68OrCq0t/8MKrC68u/cELry68uvDq0h+88OrCqwuvLv3BC68uvOL89rn0By/rq8v6ivPb59IfvKyvLuurS3/w0h+8rK8u/cFLf/DSH7z0By/9wUt/8NIfvPQHL/3BS3/wu7/9+5rPC68uvLrwivPb58KrC68uvLqHzwuvLrzi/Pa58OrCqwuvOL99Lry68OrCq3u5Lry68OrSH7zw6sKrC68u/cELry68uvDq0h+88OrCK85vn0t/8LK+uqyvOL99Lv3By/rqsr669Acv/cHL+uq7v/3zG+uXk3/72z+vg9eL1y8n/85v/7x+Ofnd3/59XbxuXr+ft+BVwauCV5zfPgWvCl4VvKr3fIYpeFXwivPbp+BVwauCV5zfPgWvCl4VvKrguvCq4FUtrguvCl4VvKrFdeFVwauCV7W4LrwqeMX57VOb67K+KtZXnN8+tbku66tifVXJdZPrsr767m///Y3VO89r6p3nNUV/sOgPFv3Boj9Y7zyvqXee19Q7z2vqnec1nN8+Ba8KXhW84vz2KXhV8KrgVV0+L7wqeMX57VPwquBVwSvOb5+CVwWvCl5VcV14VfCqiuvCq4JXBa+quS68KnhV8Kqa68Krglec3z7FfoZifVWsrzi/fYr9DMX6qlhf1XBd9jMU66t653lNvfO8pt95XtPvPK/pd57X9DvPa/qd5zX9zvOafud5Tb/zvKbfeV7D+e3T8KrhVcMrzm+fhlcNrxpe9XuezDS8anjF+e3T8KrhVcMrzm+fhlcNrxpe9eK68KrhVW+uC68aXjW86s114VXDq4ZXvbkuvGp4xfnt08l1WV816yvOb59Orsv6qllf9eG6h+uyvup3ntf0O89r+p3nNf3O85p+53lNv/O8pt95XtPvPK/pd57X9DvPa/qd5zWc3z4NrxpeNbzi/PZpeNXwquFVF58XXjW84vz2aXjV8KrhFee3T8OrhlcNr7q5LrxqeNXsZ2h41fCq4VWzn6HhVcOrhlc9XBdeNbzi/Pbp4bqsr4b1Fee3z7znycywvhrWV/OeJzPznn81w/pq3nleM+88r5l3ntfMO89r5p3nNfPO85p553nNvPO8Zt55XjPvPK/57m//3QP5t7/9Z9/g3/ntn9fB68Xrzevk9eH15XXxunnNdTfX3Vx3c93NdTfX3Vx3c90vr34/45dXn9fzvv4+v/q8fjk58Grg1cCrec+TmYFXA68GXs17nswMvBp4xfntM+y/GtZXw/qK89tn2H81rK+G9dWw/2ou12V9xfntM/Bq4NXAK85vn4FXA68GXg37rwZeDbwanrf/7W//vL68fv/9Drwa1ldDPTjwauDVsL4a6sGBV8P6aqgHB16xv33Y3z7sb5+BV+xvH/a3D/vbZ+AV+9uH/e0zL6/iYYP7jwjFUvy79o9IxVFcxb/r/4hWDCJ0EDoIHbzV4Y/QQeggdPBWiD9CB6GDt0j8Ef/o+SOW4h8/f0QqDt7e1uGPKEUrBm9v+/BHhGIpNkbfFuKPOAodbB1sHWx/B6mD1EHqIP0dpA5SB+/2hx+hg9RB6uD4Ozg6ODo4Ojj+Do4Ojg6Ov8Sjg6ODq4PrL/Hq4Org6uD6S7w6uDq4/hLfLuP/4m0z/gh/ieUvsfwllr/Et9f4I66iFK3wHrT3oL0H7b/G9h6096C9B+2/xvYetPeg/dc4OhgdjA5GHowORgejg5EHo4PBAYfE/wgchExkH/2PSAUOQiayl/5HtEIHoYO3H/kjdCAT2VL/I45CBzKRbfU/AiKFTGRn/Y9Yin810o9IxVFcRSn+FUo/YhBvi/JHhGIptsJ7sL0HMjFkYmzvwfYeyMSQiZHeg9yKVOggdSATQyZG6uDoQCaGTIyjg6MDmRhHB0cHMjFkYlwdXB3IxJCJcXVwdSAT4+rg6uDqoB6FDkoHpYNKhQ5KB1WKf6XVj4DK0Y8iFEsBlaNTAZWjr6IUrfAeyMSQiSETY7wHMjFkYsjEGO+BTAyZuFwnLpm4ZOKSict14pKJSyYumbhcJy6ZuGTicp24ZOKSiUsmLteJSyYumbhk4nKduGTikolr6WDpYOnAdeJaOlg6WDpwnbi2DrYO9lJA5bVTcRRXUQqovDZUXgmVV4ZiKbbCeyATl0xcMnGl90AmLpm4ZOI63gOZuGTiOjqQiUsmLpm4jg5k4pKJSyauqwOZuGTiujqQiUsmLpm4SgcyccnEJRNX6UAmLpnIqfY/QgeuE5frRE62/xE6cJ24XCdyuv2P0IHrxNVQeTVUXvMoQrEUUHlNKqDymqsoRSu4B1smbpm4ZeK2dt4yccvELRO3tfOWiVsmbmvnLRO3TNwycVs7b5m4ZeKWidvaecvELRP30oFM3DJxy8S9dCATt0zcMnEvHcjELRM5DP9H6MB14nadyIH4P0IHrhO368SdOkgduE7cCZV3puIorqIUUHknVN4HKu8TiqXYCu+BTNwycctEjsn/Ed4Dmbhl4r7eA5m4ZSKn5f8IHcjELRM5Mf9/IRO3TNwycZcOZOKWibt0IBO3TNwycbcOZOKWiVsm7taBTNwykTP0f4QOXCdu14mco/8jdOA6cbtO3KOD0YHrxD1QeQ9UzudRhGIpoHI+qYDK+VxFKVrBPUiZmDIxZSKn6/+IVBzFVXAPUiamTOSQ/R+hA5mYMpGD9n+EDmRiysRcOpCJKRNz60AmpkxMmZhbBzIxZWLKxNw6kIkpEzl6/0fowHViuk7k+P0foQPXiek6MY8Ojg5cJ+aBynlScRRXUQqonAcq54XKeUOxFFvhPZCJKRNTJnIo/4/wHsjElIlZ3gOZmDKRs/l/hA5kYspEzuf/X8jElIkpE7N1IBNTJmbrQCamTEyZmKMDmZgyMWVijg5kYspETuz/ETpwnXhcJ3Jq/49Yiq1IBQ7OcxWlgMrngconHkUolgIqn0gFVD5xFaVohfdAJh6ZeGQiZ/n/CO+BTDwy8SzvgUw8MpEj/X+EDmTikYkc6/8jdCATj0w8Wwcy8cjEkzqQiUcmHpl4Ugcy8cjEIxNP6kAmHpnIQf8/QgeuE4/rRA77/xE6cJ14XCeeq4OrA9eJ30zE92d5U3EUV1EKqPx38v9HFFT+ZiP+xFJshfdAJh6ZeGQiIwB+hPdAJh6ZeNp7IBOPTGQSwI/QgUw8MpFpAP8LmXhk4pGJZ3QgE49MPKMDmXhk4pGJ98HBlYlXJl6ZeB8cXJl4ZSLzAX5EK3TgOpEZAT9CB64Tr+vEGzoIHbhO/EYpPj/LG1D5rkcRiqWAyte+811Q+a6rKEUrvAcy8crEKxOZHPAjvAcy8crEu70HMvHKRAYI/AgdyMQrExki8CN0IBOvTLypA5l4ZeI9OpCJVyZemXiPDmTilYlXJt6jA5l4ZSJjBX6EDlwnXteJjBb4ETpwnXhdJ97SQenAdeItqHwrFUdxFaWAyreg8m2ofDsUS7EV3gOZeGXilYkMHPgR3gOZeGXiHe+BTLwykbkDP0IHMvHKRGYP/N8aloklE0sm1oODkoklE+vBQcnEkoklEyt0IBNLJpZMrNCBTCyZyDSCH6ED14nlOpGJBD9CB64Ty3ViLR0sHbhOrAWVa0Hl2o8iFEsBlWunAirXvopStMJ7IBNLJpZMLPfilEwsmVgysdJ7IBNLJpZ7cUomlkwsmVjuxSmZWDKxZGIdHcjEkonlXpySiSUTSyaWe3FKJpZMLJlYVwcysWQiQwx+hA5cJ5brRAYZ/AgduE4s14nVOmgduE6shsrVqTiKqygFVK6GyjVQuSYUS/FxcD7i31bbH3EUV1GKVswrvgGQPxGKpdiKVBzFVZSiFToIHYQOvkw8H7EVqTgKqNwysWViy8ReULllYsvElom9oHLLxJaJ7f7Edn9iu05s14nt/sR2f2K7TmzXie3+xN46cJ3Y7k9smdgysWViuz+xZWLLxJaJ7f7EloktE9sey19k5CtCAQ9aJrbrxLZ2bpnYMrFdJ7a1c8vEdp3Y1s4tE1smtuvE9nliy8SWie06sX2e2DKxXSe2zxNbJrZMbGvntnZumdgysa2d29q5ZWJbO7e1c7tObNeJ7TqxrZ3bdWK7TmzXiW3t3K4T23ViWzv3QOWeUkDlHn6J4/PEse889p3HvTjj88Sx7zz2nce9OGPfeew7j3txxh7L2GMZ+87jXpyxxzL2WMa+87gXZ+yxjH3ncS/O+Dxx7LGMfedxL874PHHssYx953EvzthjGfvO416c8Xni2GMZ+87j/sTxeeLYYxn7zuP+xLHHMvadx/2JY9957DuPfeex7zz2nUcmjn3nse889p3HvvPIxJGJY9957DuPTByZOPadx77zyMSx7zz2nUcmjkwceyxj33lk4sjEsccy9p1HJo49lrHvPDJxZOLYYxn7ziMTRyaOPZax7zwyceyxjH3nkYkjE8cey9h3Hpk4MnHssYx955GJY49l7DuPfeeh7xwPfed46DvHQ985HvrO8dB3joe+czz0neOh7xwPfed4qJ3DHEuYYwlzLPFQO4c5ljDHEuZY4uF54s//phjE0sHSwdIBTIxn6WDpYOkAJsazdLB0ABPj2TrYOtg6gInxbB1sHWwdwMR4tg5SBzAxntRB6iB1QN85ntRB6iB1QN85nqODowP6zvHQd46HvnM89J3joe8cD33neOg7x0PfOR76zvHQd46HvnM89J3jud6D6z2AicGshx/hPbjeA5gYzHv4Ed4DmBiMfPgROigdlA5gYjylg9ZB6wAmxtM6aB3AxHhaB62D1kHLg9HB6GB0MPJgdDA6gInxjA5GB/RYIlgn/qDivU7wPDGCHksE68QInidG0GOJoO8cQd85gr5zBH3nCPrOEfSdI+g7R9B3jqDvHEHfOYK+cwR954jwHsjEkIkhE2N5D2RiyMSQibG8BzIxZGJsHcjEkIkhE2PrQCaGTAyZGFsHMjFkYqQOZGLIxJCJkTqQiSETQyZG6kAmhkxkgMSP0MHRAevEYIjEj9DB0QHrxGCQxI/QAevECPrOEfSdI+g7R9B3jqDvHEHfOYK+cwR95wj6zhH0nSPoOwdjJX6E90AmhkxktMSP8B7IxJCJjJf4EVuRCh3IxJCJIROZMvHzL1MHMjFkIpMmfoQOZGKMDmRiyMSQiYseSyyZuGTikomLHkssmbhkInMnfkQrdOA6kdkTP0IHrhOX68QVOggduE5c9J1j0XeORd85Fn3nWPSdY9F3jkXfORZ951j0nWPRd45F3zmYRvFDW++BTFwykYkUP8J7IBOXTFzbeyATl0xkMMWP0IFMXDKR4RQ/QgcyccnElTqQiUsmrqMDmbhk4pKJ6+hAJi6ZuGTiOjqQiUsmMq7iR+jAdeJyncjIih+hA9eJy3XiKh2UDlwnLvrOseg7x6LvHIu+cyz6zrHoO8ei7xyLvnMs+s6x6DvHou8cDLH4Ed4DmbhkIoMsfoT3QCYumbjGeyATl0xknsWP0IFMXDKRmRY/C5RHEYqlwMGWiVsmbvrOsWXilolbJu7QgUzcMnHLxB06kIlbJjLl4kfowHXidp3IpIsfoQPXidt14l46WDpwnbjpO8em7xybvnNs+s6x6TvHpu8cm75zbPrOsek7x6bvHJu+czD74mfR6T2QiVsmMv/iR3gPZOKWiTu9BzJxy0TGYPwIHcjELRMZhfEjdCATt0zcRwcyccvEfXUgE7dM3DJxXx1cHcjELRP31YFM3DKR4Rg/QgeuE7frRAZk/AgduE7crhN366B14Dpx03eOTd85Nn3n2PSdY9N3jk3fOTZ959j0nWPTd45N3zm+OZY/4T2QiVsmbpnI2IwfwT1ImZgyMR/uQcrElIlMz/gRV1GKVuhAJqZMTJmYoQOZmDIxQwcyMWViysRcOpCJKRNTJubSgUxMmchMjR+hA9eJ6TqRuRo/QgeuE9N1Ym4dbB24TvzmWD4/y78cy0fkowjFUkDlvyEbXwGVvzmWP1GKVngPZGLKxJSJTNv4Ed4DmZgyMY/3QCamTGToxo/QgUxMmcjgjR+hA5mYMjGvDmRiysQsHcjElIkpE7N0IBNTJqZMzNKBTEyZyCiOH6ED14npOpFxHD9CB64T03Vijg5GB64TvzmW789yUnEUV1EKqJz0neM8UPk8oViKreAeHJl4ZOKRiQzp+BHcgyMTj0w8wT04MvHIRGZ1/AgdyMQjE5nX8fO4Sgcy8cjEs3QgE49MPEsHMvHIxCMTz9aBTDwy8cjEs3UgE49MZILHj9CB68TjOpEpHj9CB64Tj+vEkzpIHbhOPAmVT0Llcx5FKJYCKp+TCqh8zlWUohXeA5l4ZOKRicz2+BHeA5l4ZOK53gOZeGQiIz5+hA5k4pGJjPn4ETqQiUcmntKBTDwy8bQOZOKRiUcmntaBTDwy8cjE0zqQiUcmMvjjR+jAdeJxncjwjx+hA9eJx3Xi5aywuE8olgIq3ycVR3EVpYDK94HKN6DyjVAsxVZwD65MvDLxykRGgvwI74FMvDLxLu+BTLwykckgP0IHMvHKRKaD/Dy114FMvDLxbh3IxCsT79aBTLwy8crEmzqQiVcmXpl4Uwcy8cpE5oX8CB24TryuE5kZ8iN04Drxuk68RwdHB64T74HK90Dlex9FKJYCKt+bCqh871WU4uPgfMS7Vzf+xoh8RSiWYitScRRXUYpW6KB10DpoHbQOWgetg9bBl4mfj/1l4lcM4vs88Sug8pWJVyZemXg5KyyuTLwy8crEy1lhUTKxZCJjRn7EVqTiKHBQ7E+Mcp1YrhMrdBA6cJ3IxJEfoQOZWDKRqSM/QgcysWRiLR3IxJKJZY/lL8fyFVcBD0omluvEsnYumVgysVwnlrVzycRynVjWziUTzbGEOZYwxxIlE82xhDmWMMcSJRPNsYQ5liiZaI4lzLGEOZYomWiOJcyxhDmWKJlojiXMsUS5TjTHEuZYwhxLlOtEcyxhjiXMsUS5TjTHEuZYojhTNoozZaM4Uzaq/CX6PLHsO5d953IvjjmWKPvOZd+53ItT9p3LvnO5F6fssZQ9lrLvXO7FKXssZY+l7DuXe3HKHkvZdy734pTPE8seS9l3bvfitM8T2x5L23du9+K0PZa279zuxWmfJ7Y9lrbv3O5PbJ8ntj2Wtu/c7k9seyxt37ndn9j2ndu+c9t3bvvObd+5ZWLbd277zm3fue07m2MJcyzR9p3bvrM5ljDHEm3fue07m2OJtu/c9p3NsYQ5lmh7LG3f2RxLmGOJtsfS9p3NsUTbY2n7zi0TzbGEOZYwxxItE82xhDmWMMcSLRPNsYQ5lmiZaI4lzLGEOZZomWiOJcyxhDmWaJlojiXMsUTbd277zm3fue07t33ntu/c9p3bvnPbd277zm3fua2dzbGEOZYwxxJt7WyOJcyxhDmWaJ8nmmMJcyzR1s5tj6VlYsvEtnYeeywjE0cmjj2WsccyMnF8njg+TxyZODJxfJ44Pk8cmTgycXyeOPZYRiaOtfP4PHHssYx957F2Hp8njj2Wse88Pk8ceyxj33nsO49957HvPPadx77z2Hce+85j33nsO49957HvPK4TRyaOTByZOK4TRyaOTByZOK4TRyaOTBzXiSMTRyaOTBzXiSMTRyaOTBzXiSMTRyaO68SRiSMTRyaO68SRiSMTRyaO68SRiSMTx+eJ4/PEsccyrhPH54nj88SxxzKuE8fniWOPZew7j33nse889p3HvvPYdx77zmPfeew7j33nse889p3H2nlk4sjEkYlj7TwwcT0wcT0wcT08T1wPTFwPTFwPtfN6YOJ6YOJ6YOJ6Hh2EDkIHMHE9oYPQAUxcT+ggdBA6gInrWTpYOlg6gInrWTpYOoCJy3ksy3ks61k6YJ24nMeynMeynq0D1onLeSzr2Tpgnbge+s7roe+8HvrO66HvvB76zuuh77we+s7roe+8HvrO66HvvB76zst5LMt5LOuBieuBict5LMt5LOuBieuBict5LOuBieuBict5LMt5LOu5OoCJy3ksy3ks67k6gInLeSzruTqAiespHZQOSgcwcT2lg9JB6QAmrqd00DqAict5LOtpHbQOWh60DloHrYOWB6OD0cFIJPrO66HvvB76zuuh77we+s7roe+8HvrOK+g7/y9CsRRbwT0ImRgyMWSi81hWyMSQiSETg+eJK2RiyETnsayQiSETQyY6j2WFTAyZGDIxlg5kYsjEWDqQiSETQybG1oFMDJkYMjG2DmRiyETnsazYOtg6YJ24nMeyInWQOmCduCJ1kDpgnbiCvvMK+s4r6DuvoO+8gr7zCvrOK+g7r6DvvIK+8wr6zivoOy/nsayQiSETQyY6j2WFTAyZGDIxrvdAJoZMdB7LCpkYMjFkovNYVsjEkIkhE6N0IBNDJkbrQCaGTAyZGK0DmRgyMWRitA5kYshE57GsGB2MDkYejA5GB6MD14mLHsta9FjWcp246DuvRd95LfrOa9F3Xou+81r0ndei77wWfee16DuvRd95LfrOy3ksa8nEJROXTHQey1oyccnEJRPX8h7IxCUTnceylkxcMnHJROexrCUTl0xcMnFtHcjEJRPX1oFMXDJxycSVOpCJSyYumbhSBzJxyUTnsayVOnCduFwnOo9lraMD14nLdeI6Ojg6cJ246DuvRd95LfrOa9F3Xou+81r0ndei77wWfee16DuvRd95fXMsf8J7IBOXTFwy0Xksa8nEJROXTFzlPZCJSyY6j2Utmbhk4pKJzmNZSyYumbhk4modyMQlE9foQCYumbhk4hodyMQlE5dMXPSd15aJWyY6j2Vt+s5ru07crhOdx7I2fee1XSdu14k7dBA6cJ34zbF8fpZ/OZavOIqrKAVU/pvH8hELKn9zLH9iKbbCeyATt0zcMtF5LGvLxC0Tt0zc23sgE7dMdB7L2jJxy8QtE53HsrZM3DJxy8SdOpCJWybu1IFM3DJxy8R9dCATt0zcMnEfHcjELROdx7L20YHrxO060Xksa18duE7crhP31cHVgevEb47l+7NklunazDJdm77z2vSd16bvvDZ957WZZbo2s0zXZpbp2swyXc5jWVsmbpm4ZaLzWNaWiVsmbpm423sgE7dMdB7L2jJxy8QtE53HsrZM3DJxy8Q9OpCJKROTs8JWysSUiSkTk7PCVsrElIkpE/PRgUxMmeg8lpWhA9eJ6TrReSwrQweuE9N1Yi4dLB24Tkxmma5klulKZpmuZJbpSmaZrmSW6Upmma5klulKZpmuZJbpSmaZLuexrJSJKRNTJjqPZaVMTJmYMjHTeyATUyY6j2WlTEyZmDLReSwrZWLKxJSJeXQgE1Mm5tGBTEyZmDIxrw5kYsrElIl5dSATUyY6j2Xl1YHrxHSd6DyWlaUD14npOjFLB6UD14nJLNOVzDJdySzTlcwyXcks05XMMl3JLNOVzDJdySzTlcwyXcks0+U8lpUyMWViykTnsayUiSkTUybmeA9kYspE57GsIxOPTDwy0Xks68jEIxOPTDycn7iOTDwy8YQOZOKRiUcmntCBTDwy8cjEEzqQiUcmOo9lnaUD14nHdaLzWNZZOnCdeFwnnq2DrQPXiYdZpuswy3QdZpmuwyzTdZhlug6zTNdhluk6zDJdh1mm6zDLdH1zLL/bjddfjmV/xFFcRSlaMYjzKEKxFFuhg6ODo4Ojg6ODo4Org6uDLxM/H/vLxK9IxVFA5SMTj0w8MvFwVtg6MvHIxCMTD2eFrSMTj0x0Hss6pQPXicd1ovNY1mkduE48rhNP66B14DrReSzryMQjE49MdB7LOjLxyMQjE8/oQCYemXjssfzlWL4iFPDgysTrOvFaO1+ZeGXidZ14rZ2vTLyuE6+185WJ5liWOZZljmVdmWiOZZljWeZY1pWJ5liWOZZ1ZaI5lmWOZZljWVcmmmNZ5liWOZZ1ZaI5lmWOZV3XieZYljmWZY5lXdeJ5liWOZZljmVd14nmWJY5lnU5U3ZdzpRdlzNl101/iT5PdB7Lch7Lch7LMseynMeynMeynMeyrn1n57Es57Gsa4/FeSzLeSzLeSzr2mNxHstyHstyHsu69licx7Kcx7KuzxOvPZZr3/mWvwOfJ157LNe+8y1/B/ZYrn3n2/4SfZ7oPJblPJblPJZ1fZ7oPJblPJblPJZ17bE4j2U5j2Vd+87XvvO173ztO1/7zlcmln3nsu9c9p3LvrM5lmWOZTmPZTmPZZljWeZYlvNYlvNYljmWVfadnceyzLEscyzLeSzLeSzLHMsyx7Kcx7Kcx7LMsayyx+I8llUy0RzLMseyzLGskonmWJY5lmWOZZVMNMeyzLGskonmWJY5lmWOZZVMNMeyzLEscyyrZKI5lmWOZZV957LvXPady75z2Xcu+85l37nsO5d957LvXPady9rZHMsyx7LMsayydjbHssyxLHMsq3yeaI5lmWNZZe1c9licx7Kcx7LK2rnssTiPZTmPZZU9lrLH4jyWVT5PLJ8nlkwsmVg+TyyfJ5ZMLJlYPk8seywlE8vauXyeWPZYyr5zWTuXzxPLHkvZd26fJ7Y9lrbv3Pad275z23du+85t37ntO7d957bv3Pad275z23du14ktE53HspzHstp1YstE57Es57Gsdp3YMtF5LKtdJ7ZMdB7Lch7LateJLROdx7Kcx7LadWLLROexrHad2DLReSzLeSyrXSe2THQey3Iey2rXiS0Tncey2ueJ7fPEtsfSrhPb54nt88S2x9KuE9vniW2Ppe07t33ntu/c9p3bvnPbd277zm3fue07t33ntu/c9p3b2rllYsvElolt7dwysWViy8T2eWLLxJaJbe3cMrFlYsvEtnZumdgysWVi22Npmdgysa2dWya2TGyZ2NbOLRNbJrZMbJ8njkwcmeg8luU8ljWuE8d1ovNYlvNY1rhOHNeJzmNZY+08rhPHvvPYdx77zmPfeew7j33nse889p3HvvPYdx77zs5jWc5jWSMTRyY6j2U5j2WNTByZ6DyWNTJxZKLzWJbzWNbIxJGJzmNZzmNZIxNHJjqPZY1MHJk49lhGJo5MHJk49lhGJo5MHJk49lhGJo5MdB7LGnss4zpxXCc6j2WNPZZxnTiuE8cey9hjGdeJY9957DuPfeex7zz2nce+89h3HvvOY9957DuPfWfnsayRiSMTRyY6j2WNTByZODJxfJ44MnFkovNY1sjEkYkjE53HskYmjkwcmTg+TxyYuB+YuB96LPuBifuBifuBifuhx7IfmLgfmLgfmLifRwehA5i4nceyn9BB6IB14nYey35CB6ED1on7WTpYOmCduB/6zvuh77wf+s77oe+8H/rO+6HvvB/6zvuh77wf+s77oe+8H/rO23ks+9neA5i4H5i4nceyn+09gIn7gYn7Se8BTNwPTNzOY9lP6iB1ABO381j2c3RwdAAT93N0cHQAE/dzdHB0cHQAE/dzdXB1cHUAE/dzdXB1ABO381j2c3VwdcA6cTuPZT+lg9IB68T9lA5KB6wT90PfeT/0nfdD33k/9J33Q995P/Sd90PfeT/0nfdD33k/9J33Q995O49lP+M9GIk08mC8B+M9GIk08mC8BzBxPzLReSz/i1AsxVbgIGRiyMSQiUHfeYdMDJkYoQOZGDIxZGKEDmRiyMSQiRE6kIkhE53HsmPpYOmAdeJ2HsuOpYOlA9aJO7YOtg5YJ+6g77yDvvMO+s476DvvoO+8g77zDvrOO+g776DvvIO+8/7mWP6E90AmhkwMmeg8lh0yMWRiyMQ43gOZGDLReSw7ZGLIxJCJzmPZIRNDJoZMjKsDmRgyMa4OZGLIxJCJUTqQiSETQyZG6UAmhkx0HsuO0kHpoOVB66B10DpoedA6aB2wTtzfHMv3Z9lQ+S/H8hWhWAqo/DeP5Sug8jfH8idK0QruwZKJSyYumeg8lr1k4pKJSyYuzsXZSyYumeg8lr1k4pKJSyY6j2Uvmbhk4pKJK3QgE5dMXEsHMnHJxCUT19KBTFwyccnEtXQgE5dMdB7LXlsHrhOX60Tnsey1deA6cblOXKmD1IHrxG+O5fOzXMwy3YtZpnvRd96LvvNe9J33ou+8F7NM92KW6V7MMt2LWabbeSx7ycQlE5dMdB7LXjJxycQlE9f1HsjEJROdx7KXTFwycclE57HsJROXTFwycZUOZOKSiat0IBOXTFwycbUOZOKSiUsmrtaBTFwy0Xkse7UOXCcu14nOY9lrdOA6cblOXKOD0YHrxMUs072YZbo3s0z3Zpbp3swy3ZtZpnszy3RvZpnuzSzTvZllujezTLfzWPaWiVsmbpnoPJa9ZeKWiVsmbs4K21smbpnoPJa9ZeKWiVsmOo9lb5m4ZeKWiXvpQCZumbi3DmTilolbJu6tA5m4ZeKWiXvrQCZumeg8lr1TB64Tt+tE57HsnTpwnbhdJ+6jg6MD14mbWaZ7M8t0b2aZ7s0s072ZZbo3s0z3Zpbp3swy3ZtZpnszy3RvZplu57HsLRO3TNwy0Xkse8vELRO3TNzlPZCJWyY6j2Vvmbhl4paJzmPZWyZumbhl4m4dyMQtE3frQCZumbhl4h4dyMQtE7dM3KMDmbhlovNY9h4duE5M14nOY9nJWWE7XSem68TkrLCdnJ+403ViMst0J7NMdzLLdCezTHcyy3Qns0x3Mst0J7NMdzLLdCezTPc3x/K73Xj/5Vj2r1iPIhRLsRWpOIqrKEUrdLB1sHWwdbB1sHWwdbB18GXi52N/mfgVg/g+T/wKqJwyMWViysTkrLCdMjFlYsrE5KywnTIxZaLzWHYeHbhOTNeJzmPZeXTgOjFdJ+bVwdWB60TnseyUiSkTUyY6j2WnTEyZmDIxSwcyMWVilv8WvuvEr7gKeJAyMV0nprVzysSUiek6Ma2dUyam68S0dk6ZaI5lm2PZ5lh2ykRzLNscyzbHslMmmmPZ5lh2ykRzLNscyzbHso9MNMeyzbFscyz7yERzLNscyz6uE82xbHMs2xzLPq4TzbFscyzbHMs+rhPNsWxzLPtwpuw+nCm7D2fK7sOZstscy3Yey3Yey3YeyzbHsp3Hsp3Hsp3Hsg995+08lu08ln3ssTiPZTuPZTuPZR97LM5j2c5j2c5j2ccei/NYtvNY9vF54rHHclIHx9+BzxOPPZZzdHD8HdhjOUcHx1+izxOdx7Kdx7Kdx7KPzxOdx7Kdx7Kdx7KPPRbnsWznsexD33kf+s77lL/E8pdY/hJl4qHvvA99533oO+9D33mbY9nmWLbzWLbzWLY5lm2OZTuPZTuPZZtj2ae9B+2/RplojmU7j2U7j2WbY9nmWLbzWLbzWLY5ln3ssTiPZV+ZaI5lm2PZ5lj2lYnmWLY5lm2OZV+ZaI5lm2PZVyaaY9nmWLY5ln1lojmWbY5lm2PZVyaaY9nmWPa173ztO1/7zte+87XvfO07X/vO177zte987Ttf+87X2tkcyzbHss2x7GvtbI5lm2PZ5lj29XmiOZZtjmVfa+drj8V5LNt5LPtaO197LM5j2c5j2dcey7XH4jyWfX2eeH2eeGXilYnX54nX54lXJl6ZeH2eeO2xXJl4rZ2vzxOvPZZr3/laO1+fJ157LNe+8/V54rXHcu07X/vO177zte987Ttf+87XvvO173ztO1/7zte+87XvfF0nXpnoPJbtPJZ9XSdemeg8lu08ln1dJ16Z6DyWXa4TSyY6j2U7j2WX68SSic5j2c5j2eU6sWSi81h2uU4smeg8lu08ll2uE0smOo9lO49ll+vEkonOY9nl88TyeWLZYynXieXzxPJ5YtljKdeJ5fPEssdS9p3LvnPZdy77zmXfuew7l33nsu9c9p3LvnPZdy77zmXtXDKxZGLJxLJ2LplYMrFkYvk8sWRiycSydi6ZWDKxZGJZO5dMLJlYMrHssZRMLJlY1s4lE0smlkwsa+eSiSUTSyaWzxNLJpZMdB7Ldh7LLteJ5TrReSzbeSy7XCeW60Tnseyydi7XiWXfuew7l33nsu9c9p3LvnPZdy77zmXfuew7l31n57Fs57HsloktE53Hsp3Hslsmtkx0Hstumdgy0Xks23ksu2Viy0TnsWznseyWiS0TnceyWya2TGx7LC0TWya2TGx7LC0TWya2TGx7LC0TWyY6j2W3PZZ2ndiuE53HstseS7tObNeJbY+l7bG068S279z2ndu+c9t3bvvObd+57Tu3fee279z2ndu+s/NYdsvEloktE53Hslsmtkxsmdg+T2yZ2DLReSy7ZWLLxJaJzmPZLRNbJrZMbJ8ntkxsmdj2WFomtkxsmdj2WFomtkxsmdj2WFomtkx0Hstunye268R2neg8lt0+T2zXie06se2xtM8T23Vi23du+85j33nsO49957HvPPadx77z2Hce+85j39l5LHtk4sjEkYnOY9kjE0cmjkwc+84jE0cmOo9lj0wcmTgy0Xkse2TiyMSRiWPfeWTiyMSx7zwycWTiyMSx7zwycWTiyMSx7zwycWSi81j22GMZ14njOtF5LHvssYzrxHGdOPZYxh7LuE4c+85j33nsO49957HvPPadx77z2Hce+85j33nsOzuPZY9MHJk4MtF5LHtk4sjEkYljj2Vk4shE57HskYkjE0cmOo9lj0wcmTgycew7j0wcmTj2nUcmjkwcmTj2nUcmjkwcmTj2nUcmjkx0Hsse+87DOjEf1onpPJZ86DvnwzoxH9aJ+dB3zoe+cz6sE/Oh75wPfed86DvnQ985H/rO+dB3zoe+cz70nfOh75wPfef/RSu8B8t7ABPzgYnpPJZ8lvcAJuYDE/NZ3gOYmA9MTOex5LN1sHUAE9N5LPlsHWwdwMR8tg62DmBiPqmD1EHqACbmkzpIHaQOYGI+qYOjA5iYzmPJ5+jg6IB1YjqPJZ+jg6MD1on5XB1cHbBOzG+O5fuzvKk4iqsoxUvl/JvH8hH1Ujm/OZY/sRRb4T0o7wFMzAcmpvNY8invAUzMp+VBew9gYj4wMZ3Hkk/roHUAE9N5LPmMDkYHI5FGB6ODkUijg9HB6EAmBjOq/hehWIqtwEHIxJCJzmPJYEZVxqMD1onpPJaM0EHogHViRuggdMA6Mb85ls/PMphlmsEs0wz6zhn0nTPoO2fQd85glmkGs0wzmGWawSzTdB5LhkwMmRgy0XksGTIxZGLIxNjeA5kYMtF5LBkyMWRiyETnsWTIxJCJIRMjdSATQybG0YFMDJkYMjGODmRiyMSQiXF0IBNDJjqPJePq4OqAdWI6jyXj6uDqgHViRumgdMA6MYNZphnMMs1glmkGs0wzmGWawSzTDGaZZjDLNINZphnMMs1glmk6jyVDJoZMDJnoPJYMmRgyMWRijPdAJoZMdB5LhkwMmRgy0XksuWTikolLJi7m9uWSiUsmLs4KyyUTl0xcMnGFDmTikolLJq7QgUxcMtF5LLlCB64Tl+tE57HkWjpwnbhcJ66lg6UD14mLWaa5mGWai1mmuZhlmotZprmYZZqLWaa5mGWai1mmuZhlmotZpuk8llwyccnEJROdx5JLJi6ZuGTiSu+BTFwy0XksuWTikolLJjqPJZdMXDJxycR1dCATl0xcVwcyccnEJRPX1YFMXDJxycR1dSATl0x0Hkuu0oHrxOU60XksuUoHrhOX68TVOmgduE5czDLNxSzTXMwyzcUs01zMMs3FLNNczDLNxSzTXMwyzcUs0/zmWH63G+dfjmV/xFFcRSla8e4Wzm+O5U+EYim2IhVHcRWlaIUOQgehgy8Tz0dsRSqOAipvmbhl4paJm7PCcsvELRO3TNycFZZbJm6Z6DyW3EsHrhO360TnseTeOnCduF0n7q2DrQPXic5jyS0Tt0zcMtF5LLll4paJWybu1IFM3DJx02PJvxzLV4QCHmyZuF0nbmvnLRO3TNyuE7e185aJ23XitnbeMtEcS5pjSXMsuWWiOZY0x5LmWHLLRHMsaY4lt0w0x5LmWNIcS26ZaI4lzbGkOZbcMtEcS5pjye060RxLmmNJcyy5XSeaY0lzLGmOJbfrRHMsaY4lN2fK5uZM2dycKZubM2XTHEs6jyWdx5LOY0lzLOk8lnQeSzqPJZO+czqPJZ3Hkhk6CB2EDtiLkxk6CB2EDtiLkxk6WDpgL06mzxNz6WDpgL04mT5PzKWDpQP24mRuHWwdsBcn0+eJzmNJ57Gk81gyfZ7oPJZ0Hks6jyUzdZA6YH9iJn3nTPrOmfSdM+k7Z9J3zpSJSd85k75zJn3nTPrOaY4lzbGk81jSeSxpjiXNsaTzWNJ5LGmOJfN6D+g7pzmWNMeSzmNJ57GkOZY0x5LOY0nnsaQ5lszSAX3nTJlojiXNsaQ5lkyZaI4lzbGkOZZMmWiOJc2xZMpEcyxpjiXNsWTKRHMsaY4lzbFkykRzLGmOJZO+cyZ95zz0nfPQd85D3zkPfec89J3z0HfOQ985D33nPPSd81g7m2NJcyxpjiWPtbM5ljTHkuZY8vg80RxLmmPJY+187LE4jyWdx5LH2vnYY3EeSzqPJY89lmOPxXkseXyeeHyeeGTikYnH54nH54lHJh6ZeHyeeOyxHJl4rJ2PzxOPPZZD3zmPtfPxeeKxx3LoO+fxeeKxx3LoO+eh75yHvnMe+s556Dvnoe+ch75zHvrOeeg756HvnIe+cx76znlcJx6Z6DyWdB5LHteJRyY6jyWdx5LHdeKRic5jyeM68chE57Gk81jyuE48MtF5LOk8ljyuE49MdB5LHteJRyY6jyWdx5LHdeKRic5jSeex5HGdeGSi81jy+Dzx+Dzx2GO5rhOvzxOvzxOvPZbrOvH6PPHaY7n2na9952vf+dp3vvadr33na9/52ne+9p2vfedr3/nad77WzlcmXpl4ZeK1dr4y8crEKxOvzxOvTLwy8Vo7X5l4ZeKVidfa+crEKxOvTLz2WK5MvDLxWjtfmXhl4pWJ19r5ysQrE69MvD5PvDLxykTnsaTzWPK6TryuE53Hks5jyes68bpOdB5LXmvn6zrx2ne+9p2vfedr3/nad772na9952vf+dp3vvadr31n57Gk81jyysQrE53Hks5jySsTr0x0HktemXhlovNY0nkseWXilYnOY0nnseSViVcmOo8lr0y8MvHaY7ky8crEKxPLHkvJxJKJJRPLHkvJxJKJzmPJssdSrhPLdaLzWLLssZTrxHKdWPZYyh5LuU4s+85l37nsO5d957LvXPady75z2Xcu+85l37nsOzuPJUsmlkwsmeg8liyZWDKxZGL5PLFkYslE57FkycSSiSUTnceSJRNLJpZMLJ8nlkwsmVj2WEomlkwsmVj2WEomlkwsmVj2WEomlkx0HkuWzxPLdWK5TnQeS5bPE8t1YrlOLHss5fPEcp1Y9p3LvnPZdy77zmXfuew7l33nsu9c9p3LvnPZd3YeS5ZMLJlYMtF5LFkysWRiycSy71wysWSi81iyZGLJxJKJzmPJloktE1smtn3nloktE9u+c8vEloktE9u+c8vEloktE9u+c8vElonOY8m2x9KuE9t1ovNYsu2xtOvEdp3Y9ljaHku7Tmz7zm3fue07t33ntu/c9p3bvnPbd277zm3fue07O48lWya2TGyZ6DyWbJnYMrFlYttjaZnYMtF5LNkysWViy0TnsWTLxJaJLRPbvnPLxJaJbd+5ZWLLxJaJbd+5ZWLLxJaJbd+5ZWLLROexZNt3bteJ7TrReSzZ9p3bdWK7Tmz7zm3fuV0ntn3ntu/c9p3bvnPbd277zm3fue07t33ntu/8zbH8Ce+BTGyZ2DLReSzZMnFk4sjEYUZVjkwcmeg8lhyZODJxZKLzWHJk4sjEkYkTOpCJIxPHvvPIxJGJIxPHvvPIxJGJIxPHvvPIxJGJzmPJse88rhPHdaLzWHLsO4/rxHGdOPadx77zuE785lg+P8u/HMtH5KMIxVJA5b95LF8Blb85lj9RilZ4D2TiyMSRic5jyZGJIxNHJs7xHsjEkYnOY8mRiSMTRyY6jyVHJo5MHJk4VwcycWTilA5k4sjEkYlTOpCJIxNHJk7pQCaOTHQeS07rwHXiuE50HktO68B14rhOnNHB6MB14jfH8v1ZMss0h1mmOfadx77z2Hce+s7nYZbpeZhleh5mmZ6HWabHeSzngYnngYnngYnHeSzngYnngYnngYnnYUbVeWDieWDicR7LeUIHoQOY+L/QwdLB0gFMPM/SwdIBTDzP0sHSwdIBTDzP1sHWwdYBTDzP1sHWAUw8zmM5z9bB1gHrxOM8lvOkDlIHrBPPkzpIHbBOPA+zTM/DLNPzMMv0PMwyPQ+zTM/DLNPzMMv0PMwyPQ+zTM/DLNPzMMv0OI/lPNd7ABPPAxOP81jOc70HMPE8MPE813sAE88DE4/zWM5TOigdwMTjPJbzlA5KBzDxPKWD0gFMPE/roHXQOmh50DpoHbQOWh60DkYHMPE4j+U8o4PRwciD0cHoYHTAOvEEZ4X9L0KxFC+VTzDL9ASzTE8wy/QEs0xPMMv0BLNMTzDL9ASzTE8wy/QEs0yP81hOyMSQiSETncdyQiaGTAyZGMt7IBNDJjqP5YRMDJkYMtF5LCdkYsjEkImxdSATQybG1oFMDJkYMjFSBzIxZGLIxEgdyMSQic5jOZE6SB2wTjzOYzlxdHB0wDrxxNHB0QHrxBPMMj3BLNMTzDI9wSzTE8wyPcEs0xPMMj3BLNMTzDI9wSzT882x/G43Pt8cy/p8hO868StCsRRbkYqjuIpStEIHrYPWQeugddA6aB20DloHrYPWwehgdDA6GB2MDkYHo4PRwehgcPDNsfyJUCzFx8F8RCqO4ip+Hez4iFYM4sPEP/HrYK+PWIqtSMWvg70/4ipK8XFwPmIQHyb+iY+D+xFLsRWp+Fy0PqIUrfhc9HNHPxj8E6FYiq1IxVFcRSlaoYPUQeogdZA6SB18MLg/3/YHg/l8RCl+HeTnC/5g8Cs+GPwToViKrfh1kJ/v9IPBv3euohQ6+GDw+x+4Org6uDq4Org6uDq4Org6uDq4OigdlA5KB6WD0kHpoHRQOigdlA5aB62D1kHroHXQOmgdtA5aB62D0cHoYHQwOhgdjA5GB6OD0cHg4Btd+bzzja78iaXYivQ/cHznKkrRCh2EDkIHoYPQQeggdBA6CB2EDkIHSwdLB0sHSwdLB0sHSwdLB0sHSwcfJmZ+RCiWYitScRRXUYpWDCJ1kDpIHaQOUgepg9TBl4n3I1oxiC8T+yNCsRQfB/MRvw7O545+mPgnrqIUvw7O+YhBfJj4J34dnI+3DxP/xFak4iiuohQfB/URg/gw8U+EYim2IhVHcRWl0EHp4MPE+3xEKJZiK34d3M+3/WHin7iKXwf3c3s/TPwTvw7u5+58mPgnPg4+3j5M/BMfB58fxYeJ9/Oj+DDxT/w6qI/RDxP/RCvmFd/oSsVHhGIptiIVR3EVpWjFIEIHoYPQQeggdBA6CB2EDkIHoYOlg6WDpYOlg6WDpYOlg6WDpYOlg62DDxNrf8RSbEUqjuIqStGKQXyY+Cd0kDpIHaQOUgepg9RB6uDDxPr9+X+jK38iFEvxcVAfkYqjuIqPg/6IVgziw8T+/MP4MPFPLMWvg/58WR8m/omjuIrfi/b6iEF8MNifG/LB4J9Yiq1IxVFcRSlaMYjWQeugddA6aB20DloHHwx2fsTHwfmIQXww2J8v+IPBP7EUW5GKo/g4+HynHwz+vdOKecU3rfIn4v0PfNMqf+9sRSqO4vofKN9phQ5CB6GD0EHoIHQQOggdhA5CB6GDpYOlg6WDpYOlg6WDpYOlg6WDpYOtg62DrYOtg62DrYOtg62DrYOtg9RB6iB1kDpIHaQOUgepg9RB6uDo4Ojg6ODo4Ojg6ODo4Ojg6ODo4Org6uCDwXk+Yit+HUx8xFFcRSl+Hcz+iEF8mPgnQvFx8PH2YeKfSMXHQX3EVZSiFR8Hn0/6YeKfCMVSbEUqjuIqStEKHXyYOPMRoViKrfhx8P/j4484iquoX7E+ohXzik9a5Z+IX/F8xFJsRSrO+8190yp/ohSt4HfwTav8iXi/4G9a5U9sRSqOgt/BN63yJ1oxiMXv4JtW+RNLsRWpOIqrKEUr+B180yp/gt/BN63yJ7YiFZ/fwecm7qsoRb+/kE9a5U/kowjFUmx+LpmKo7iK4ueSrRjEeRTw4JtW+RNbkQp/icdf4oeJ31/Ih4l/YhAfJv4Jf4lfJn5+Ll8mfkUqjsLfwfV3cP0dXH8H5e+g/CWWv8Tyl1j+EstfYungy8TPz+XLxK8YRD+K4LfTS7EVEOmTVvknrqIU/hJbIo1EmlAshUQaifRl4ldchUQaiTQQ6ZtW+ROhWAqI9E2r/ImjuIpSQKRvWuUrvkz8ilDwO/imVf5EKo7iKkrRCn6JJRNLJpZM/KZVPj+Xb1rlTxzFVUCkT1rlnxjEhkiftMo/sRSf30F+RCo+v4PPvf4y8StK8XHwub1fJn4+3JeJn//bl4lfsRRbkfzXvkz8/td0kDr4MvErBvFl4ue/doL/2tHB0cFJhffgXP9r5X9NB0cH13twvQd38V+7m//a1cHVwfUeXO/B9Vu4fgulg9JBeQ/Ke1B+C+W3UDooHZT3oLwH7bfQfgutg9ZBew/ae9B+C+230DpoHYz3YLwH47cwfgujg9HBeA/GezB+C8O30A8O+gnFUmwF38InrfLvv3b9v5WiFdyDT1rl778WfAuftMq//5sOIhVHcf2vlf+1XwfxfefXwWd7xyet8k+EYim2IhVHcRWl+HXw2XbxSav8iQ8T/0QolmIrUnEUV1EKHWwdpA5SB6mD1EHqIHWQOkgdpA5SB0cHRwdHB0cHRwdHB0cHRwdHB0cHVwdXB1cHVwdXB1cHVwdXB1cHVwelg9JB6aB0UDooHXyY+Nnr8Umr/BO/DvbzEYP4MPFPhOLXwWcXyCet8k+k4iiuohQfB+sjBvFh4tfoh4l/4uNgf8RWJEY/TPwTV1GKxs6HiR/xSav8E6FYiq3I9yN80ir/BN/CJ63yT/T7ET5plT8RfAuftMo/sRRbwbfwSav8E1dRilZ4Dz5M/H6EDxP/xOIjfJj4J5KP8GHin+Bb+KRV/olW8Ev8pFX+7Gy/he23sP0Wtvdgew8+TPx+hA8T/0TzEb5M/IgPE78f4cPEP+G3kH4LmYqj8FtIv4X0W0i/heM9ON6DDxO/H+HDxD+RfIQvE7/i8hE+TPwTfgvHb+H6S7z+Eq/fwvVbuH4L12/heg+u9+DCg09a5U8UPJgKBTz4pFX+Cb+F8lsof4nlL7H8Fspvof0W2m9BJo5MnJYHLQ9aHrQ8aHnQ8mD8FsZvYfwljr/E8VsYv4XxWxi/BZk4MPE+z8uD+zyheHlwP2mVf+LlwX2eo3i/hftJq/wTrRhEPNiJUCzFVqTiKC4fIUrRfIQYxHr4CCsUC6NrK1JxFBc7qxSt8FvY3oPtPdiLj7C3IvkI+yguH2GXwm9h+y3kowiF30L6LaTfQvotpPcgvQfZfIQcxHn4CCcUi49wtsJv4fgtHH+Jx1/i8Vs4fgvXb+H6LVzvwfUe3OQj3KO4fIRbiuYj3EGU30L5LZS/xPKXWH4L5bdQfgvlt1Deg/IetDxoedDyoOVBy4OWB+230H4L7S+x/SWO38L4LYzfwvgtjPdgvAcjD0YejDwYeBAPPIgnFHwL8WxFKo6CbyGeUrSCbyFkYsjECHgQsRXw4JNW+SfgQUQp+BYi+BZiPYpQ8C3E2opUHIX3QCbGggex4EFseBA7FPAg9lb4LWy/hX0VpfBb2H4L6beQfgsyMWRiJDyIPAp4EFkKeBAJD+L4LRy/heMv8fhLPH4Lx2/h+C0cvwWZGDIxLjyIG4qPg/yIrfg4OB9xFFdRilYM4svErwjFUmyFDkoHpYPSQemgdNA6aB20DloHrYPWQeugddA6aB2MDkYHo4PRwehgdPBl4v2IUvw6yO//bV7xSav8E6FYiq1IxVFcRSlaoYPQQeggdBA6CB2EDkIHHyZmfUQrBvFh4p8IxVJsRSqO4ip0sHSwdLB1sHWwdbB1sHWwdfBh4lkfUYpWDOLDxD8RiqXYilQchQ5SB6mD1MHRwdHB0cGHiSc/4tfB7+7a+4mu/E+Fj7iKUrRiEB8m/olQLMVWpEIHVwdXB1cHVwelg9JB6aB0UDooHZQOSgelg9JB66B10DpoHbQOWgetg9bBh4m/OxfvJ7oS/Xnnw8TvOx8m/r2zfGf7TvrO8Z3rO+U7OhgcfKIr33c+0ZV/7yzf2b6TvnN85/pO+U77jg5CB6GD0EHoIHQQOggdhA5CB6GDpYOlg6WDpYOlg6WDpYOlg6WDpYOtg62DrYOtg62DrYOtg62DrYOtg9RB6iB1kDpIHaQOUgepg9RB6uDo4Ojg6ODo4Ojg6ODDxK6P+HXwu6PwfqIr/8QgPkz8E6FYiq1IxVFchQ6uDq4OSgelg9JB6aB0UDr4MHE+d+fDxD/RikF8mPgnQrEUW5GKo9BB66B10DoYHYwORgejg9HBh4m/m0XuJ7ryT5SiFfOKT3TlnwjFUmxFKo7iKkrRCh2EDkIHv0xcv3uL7ie6sn5nVN1PdGXF9/92FFdRilYM4peJ/0QolmIrdLB0sHSwdLB0sHSwdbB1sHWwdbB1sHWwdbB1sHWwdZA6SB2kDlIHqYPUQergl4n/L58/4tfB+r4zvPPLxL93fpn4753lO9t30neO71zf0cHRwdHB1cHVwdXB1cHVwdXB1cHVwdXB1UHpoHRQOigdlA5KB6WD0kHpoHTQOmgdtA5aB62D1kHroHXQOmgdjA5GB6OD0cHoYHQwOhgdjA4GB58cy/edT47l3zvLd7bvpO8c37m+U77TvqOD0EHoIHQQOggdfJj4ecL0ybF8/1B+ciz/RCv46/zJsfwToViKrUjFUehg6WDpYOlg62DrYOtg62DrYPPX+ZNj+SdK0Qr+On9yLP9EKJZiK1Khg9RB6iB1kDo4Ojg6ODo4Ojj8df7kWP6JqyhFK/jrfO6jCMVSbIUOrg6uDq4Org6uDkoHHyZ+lgSfHMt3SfDJsXz/5HxyLP/EUVxFKVrB38ZPjuWfCMVS6KB10DpoHbQOWgetg9HB6GB0MDoYHYwORgejg9HB4OCTY/knQrEUW5GKo7gvuO6Xid932neGd75M/LzzZeL3neU723fSd47v6CB0EDoIHSwdLB0sHSwdLB0sHSwdLB0sHSwdbB1sHWwdbB1sHWwdbB1sHWwdbB2kDlIHqYPUQeogdZA6SB2kDlIHRwdHB0cHRwdHB0cHRwdHB0cHRwdXB1cHVwdXB1cHVwdXB1cHVwdXB6WD0kHpoHTwYeJnSXCtnW9dRSlawV/n248iFEuxFanQQeugddA6aB2MDkYHo4PRgbXzN8fyJ66iFK3gr3M9jyIUS7EVqTiKqyhFK3QQOggdhA6Cv86fHMs/cRRXUYpW8Ne51qMIxVLoYOlg6WDpYOlg6WDp4MPEz5KgvrXz52NbO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7f3Is/4QOUgdHB0cHRwdHB0cHRwdHB0cHRwdHB1cHVwdXB1cHVwfWzmXtXNbOZe1c1s5l7VzWzmXtXNbOZe1c1s5l7VzWzmXtXNbOZe1c1s5l7VzWzmXtXNbOZe1c1s5l7VzWzmXtXNbOZe1c1s5l7VzWzmXtXNbOZe1c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3KGD0EHoIHQQOlg6WDpYOlg6WDpYOlg6WDpYOlg62DrYOtg6+DDxsyRoa+dvjuVPXEUpWsFf52+O5U+EYim2Qgepg9RB6iB1kDo4Ojg6ODqwdv7mWP7EUVxFKVrBX+dvjuVPhGIpdHB1cHVwdXB1cHVwdVA6KB0Uf52/OZY/kYqjuIpStIK/zt8cy58IhQ5aB62D1kHroHXQOvgw8bMk6G/t/PnY1s5t7dzWzm3t3NbObe3c1s5t7dzWzmPtPNbOY+081s5j7TzWzp8cyz9RilboIHQQOggdhA7ssYw9lrHHMvZYxh7L2GMZeyxjj2XssYw9lrF2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnKR2UDkoHpYPSQemgddA6aB20DloHrYPWQeugddA6GB2MDj5M/CwJxtr5m2P5E0dxFaVoxfvXub45lj8RiqXYilQcxVWUohU6CB2EDqid65tj+ROpOIqrKEUrBrEeRSh0sHSwdLB0sHSwdLB0sHSwdbDfv871zbH8ia1IxVFcRSlaMYh8FDpIHaQOUgepg9RB6uDDxOfzBX9r58/Hpnauh9q5Hmrneqid66F2rofauR5q53qoneuhdq6H2rmeq4Org6uDq4Org6uDq4Org6uDq4PSQemgdFA6KB2UDkoHpYPSQemgddA6aB1QO9dD7VwPtXM91M71UDvXQ+1cD7VzPdTO9VA710PtXM/oYHQwOhgdjA5GB9TOFdTOFdTOFdTOFdTOFdTOFdTOFdTOFdTOFdTOFY8OQgehg9BB6CB0EDoIHYQOQgehg6WDpYOlg6WDpYOlg6WDpYOlg6WDrYOtg62DrYOtg62DrYOtg62DrYPUQeogdZA6SB2kDlIHqYPUQerg6ODDxN8lQQW1c31zLH8iFUdxFaVoBX+dg/2JFexPrLg6uDq4Org6uDq4Org6uDooHVA71zfH8ie2IhVHcRWlaAV/nYP9iRWtg9ZB66B10DpoHbQOWgetg+Gv8zfH8ieWYitScRRXUYpWsD5Y7E+sxf7EWuxPrMX+xFrsT6zF/sRa7E+sT47luyRY39p5fwR/mRa1cy1q51rUzrWonWtRO9eidq5F7VyL2vl/0QodLB0sHSwdLB0sHSwdLB0sHSwdLB1sHWwdbB1sHWwdbB1sHWwdbB1sHaQOUgfUzrWonWtRO9eidq5F7VyL2rkWtXMtauda1M61qJ1rHR0cHRwdHB0cHRwdHB0cHVwdXB1cHVwdXB1cHVwdXB1cHVwdlA5KB6WD0kHpoHRQOigdlA5KB62D1kHroHXQOmgdtA5aB62D1sHoYHQwOhgdjA5GB6OD0cHoYHCwHxzsJ3xn+c72nfSd4zvXd8p32nd08GHiZ0mwrZ2/OZY/sRWpOIqrKEUr+Ou82Z9Ye+lg6WDpYOlg6WDpYOlg6WDpwNr5m2P5E0uxFak4iqsoRSv467xTB6mD1EHqIHWQOkgdpA5SB8lf52+O5U+EYim2IhVHcRWlaIUOrg6uDq4Org6uDq4OPkz8LAn2t3b+fGxr523tvK2dt7Xztnbe1s7b2nlbO29r523tvK2dt7Xztnbe1s7b2nm3DloHrYPWQeugddA6GB2MDkYHo4PRwehgdDA6GB3QY6mkx1Jp7ZzWzmntnNbOae2c1s5p7ZzWzmntnNbOae2c1s5p7ZzWzmntnNbOae2c1s5p7ZzWzmntnNbOae2c1s5p7ZzWzmntnNbOae2c1s5p7ZzWzmntnNbOae2c1s5p7ZzWzmntnNbOae2c1s5p7ZzWzmntnNbO5ljKHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZYylzLGWOpcyx1DfH8lkSpLVzku2rJNtXSbavkmxfJfsTK9mfWMn+xEr2J1ayP7GyddA6aB20DloHrYPWQeugdWDtnGT7Ksn2VZLtqyTbV8n+xEr2J1ayP7GS/YmV7E+sZH9iHfYn1mF/Yh32J9Zhf2Id9ifWYX9iHfYn1mF/Yh2yfXXI9tUh21eHbF+dWIqtSMVRXEUpdBA6WDpYOlg6WDpYOvgw8bMkON/a+fOxrZ2PtfOxdj7Wzsfa+Vg7H2vnY+18rJ2PtfOxdj7Wzsfa+Vg7H2vnkzpIHaQOUgepg9RB6iB1YI/l2GM59liOPZZjj+XYYzn2WI49lmOP5dhjOdbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2vtbO19r5Wjtfa+dr7Xytnc2xlDmWMsdS5ljKHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZY6lvjuWzJLjWzpdsX12yfXXJ9tUl21eX/Yl12Z9Yl/2JddmfWJf9iXW3DlIHqYPUQeogdZA6SB2kDqydL9m+umT76pLtq0u2ry77E+uyP7Eu+xPrsj+xLvsT6x4dHB1cHVwdXB1cHVwdXB1cHZDtq0u2ry7Zvrpk++pWKJZiK1JxFFehg9JB6aB10DpoHbQOPkz8LAnut3b+fGxr52vtfK2dr7XztXa+1s7X2vlaO19r52vtfK2dr7XztXa+1s5l7VzsT6xif2IV+xOr2J9Yxf7EKvYnVrE/sYr9iVX2WMoeS9ljKXssZY+l7LGUPZayx1L2WMoeS1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtbM5ljLHUuZYyhxLmWMpcyxljqXMsZQ5ljLHUuZYyhxLmWMpcyxljqXMsZQ5ljLHUuZYyhxLmWMpcyz1zbF8lgRl7Vxk+6rI9lWR7asi21fF/sQq9idWsT+xiv2JVexPrBoduD+x3Z/Y7k9s9ye2+xPb/Ynt/sR2f2JbOzfZvmqyfdVk+6rJ9lW7P7Hdn9juT2z3J7b7E9v9ie3+xHZ/Yrs/sd2f2O5PbPcntvsT2/2JTbavmmxfNdm+arJ99Z3H8idCsRRbkYqj0IH7E9v9ie3+xHZ/Yrs/sd2f+MmxfJcE/a2dPx/b2rmtndvaua2d29q5rZ3b2rmtndvaua2d29q5rZ3b2rmtndvaud2f2O5PbPcntvsT2/2J7f7Edn9iuz+x7bG0PZa2x9L2WNoeS9tjaXssbY+l7bG0PZa2dm5r57Z2bmvntnZua+e2dm5r57Z2bmvntnZua+e2dm5r57Z2bmvntnZua+e2dm5r57Z2bmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmvnsXYea+exdh5r57F2HmtncyxljqXMsZQ5ljLHUuZYyhxLmWMpcyxljqXMsZQ5ljLHUuZYyhxLmWMpcyxljqXMsZQ5ljLHUuZY6ptj+SwJxtp5yPbVkO2rIdtXQ7avxv2J4/7EcX/iuD9x3J847k8c9yeO+xPH/Ynj/sRxf+K4P3HcnzjuTxxr5yHbV0O2r4ZsXw3Zvhr3J477E8f9ieP+xHF/4rg/cdyfOO5PHPcnjvsTx/2J4/7EcX/iuD9xyPbVkO2rIdtXQ7avvvNYvsL9ieP+xHF/4rg/cdyfOO5PHPcnjvsTx/2Jw/7Eftif2A/7E/uTY/ksCfr51s77I96/TP1QO/dD7dwPtXM/1M79UDv3Q+3cD7VzP9TO/VA79xM6CB2EDkIHoYPQwdLB0sHSwdLB0sHSwdLB0sHSwdLB1sHWwdbB1sHWwdbB1gG1cz/Uzv1QO/dD7dwPtXM/1M79UDv3Q+3cD7VzP9TO/aQOUgepg6ODo4Ojg6ODo4Ojg6ODo4Ojg6ODq4Org6uDq4Org6uDq4Org6uDq4PSQemgdFA6KB2UDkoHpYPSQemgddA6aB20DloHrYPWQeugddA6GB2MDkYHo4PRwehgdDA6GB2QY2lzLG2Opc2xtDmWNsfS3xzL75Kgg9q5g2xfB9m+DrJ9HWT7Otif2MH+xA72J3awP7GD/YkdoYPQQeggdLB0sHSwdLB0sHRA7dxBtq+DbF8H2b4Osn0d7E/sYH9iB/sTO9if2MH+xI6tg62DrYOtg62D1EHqIHWQOiDb10G2r4NsXwfZvv7OY/kT/HUO9id2sD+xg/2JHexP7Dg6ODo4Ojg6ODo4Org6+DDxsySIb+38+djUzh3Uzh3Uzh3Uzh3Uzh3Uzh3Uzh3Uzh3Uzh3Uzh2lg9JB6aB0UDooHZQOWgetg9ZB66B10DpoHbQOWgetg9HB6GB0MDoYHYwOqJ07qJ07qJ07qJ17UTv3onbuRe3ci9q5F7VzL2rnXtTOvaide1E793p0EDoIHYQOQgehg9BB6CB0EDoIHSwdLB0sHSwdLB0sHSwdLB0sHSwdbB1sHWwdbB1sHWwdbB1sHWwdbB2kDlIHqYPUQeogdZA6SB2kDlIHRwdHB0cHRwdHB0cHRwdHB0cHRwdXB1cHVwdXBx8mfpYEi9q5F9m+XmT7epHt60W2rxf7E3uxP7EX+xN7sT+xF/sTe5UOSgelg9JB6aB10DpoHbQOqJ17ke3rRbavF9m+XmT7erE/sRf7E3uxP7EX+xN7sT+x1+hgdDA6GB2MDtif2Jv9ib3Zn9ib/Ym9yfb1JtvXm2xfb7J9vZk90Jv9ib3Zn9ib/Ym92Z/Ym/2JvUMHoYPQQeggdBA6CB18mPhZEuxv7fz52NbO29p5Wztva+dt7bytnbe187Z23tbO29p5Wztva+dt7bytnbe189462DrYOkgdpA5SB6mD1EHqIHWQOkgdpA6ODo4Ojg6ODo4OrJ23tfO2dt7WztvaeVs7b2vnbe28rZ23tfO2dt7WztvaeVs7b2vnbe28rZ23tfO2dt7WztvaeVs7b2vnbe28rZ23tfO2dt7WztvaeVs7b2vnbe28rZ23tfO2dt7WztvaeVs7b2vnbe28rZ23tfO2dt7WztvaOa2dzbG0OZY2x9LmWNocS5tjaXMsbY6lzbG0OZY2x9LmWNocS5tjaXMsbY6lzbG0OZY2x9LmWNocS5tj6W+O5bMkSGvnJNvXSbavk2xfJ9m+TvYndrI/sZP9iZ3sT+xkf2Ln1sHWwdbB1sHWwdZB6iB1kDqwdk6yfZ1k+zrJ9nWS7etkf2In+xM72Z/Yyf7ETvYndh4dHB0cHRwdHB0cHRwdXB1cHZDt6yTb10m2r5NsXyezBzrZn9jJ/sRO9id2sj+xk/2JnaWD0kHpoHRQOigdlA4+TPwsCb7zWD5LgrR2TmvntHZOa+e0dk5r57R2TmvntHZOa+e0dk5r57R2TmvntHbO0cHoYHTA/sQ+7E/sw/7EPuxP7MP+xD72WI49lmOP5dhjOfZYjj2WY4/l2GM59liOPZZj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9rZHEubY2lzLG2Opc2xtDmWNsfS5ljaHEubY2lzLG2Opc2xtDmWNsfS5ljaHEubY2lzLG2Opc2xtDmW/uZYPkuCY+18yPb1IdvXh2xfH7J9fdif2If9iX3Yn9iH/Yl92J/YZ3QwOhgdjA5GB6MD9if2ZX9iX/Yn9rV2vmT7+pLt60u2ry/Zvr7sT+zL/sS+7E/sy/7EvuxP7Bs6CB2EDkIHoYPQQeggdLB0QLavL9m+vmT7+pLt68vsgb7sT+zL/sS+7E/sy/7EvuxP7Lt1sHWwdbB1sHWwdbB18GHiZ0nwncfyWRJca+dr7Xytna+187V2vtbO19r5Wjtfa+dr7Xytna+187V2vtbO19r5Hh0cHRwdHB0cHVwdXB1cHdhjufZYrj2Wa4/l2mO59liuPZZrj+XaY7n2WK6187V2vtbO19r5Wjtfa+dr7Xytna+187V2vtbO19r5Wjtfa+dr7Xytna+187V2vtbO19r5Wjtfa+dr7Xytna+187V2vtbOZe1c1s5l7VzWzmXtXNbOZe1c1s5l7VzWzmXtXNbOZe1c1s5l7VzWzmXtXNbOZe1sjqXNsbQ5ljbH0uZY2hxLm2NpcyxtjqXNsbQ5ljbH0uZY2hxLm2NpcyxtjqXNsbQ5ljbH0uZY2hxLf3MsnyVBWTsX2b4usn1dZPu6yPZ1sT+xi/2JXexP7GJ/Yhf7E7uODo4Ojg6ODo4Ojg6ODo4Org6snYtsXxfZvi6yfV1k+7rYn9jF/sQu9id2sT+xi/2JXaWD0kHpoHRQOigdlA5KB6UDsn1dZPu6yPZ1ke3rYvZAF/sTu9if2MX+xC72J3axP7FrdDA6GB2MDkYHo4PRwYeJnyXBdx7LZ0lQ1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzu3+xHZ/Yrs/sd2f2O5PbPcntvsT2/2JbY+l7bG0PZa2x9L2WNoeS9tjaXssbY+l7bG0tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7m2NpcyxtjqXNsbQ5lv+FDloHrYPWQeugddA6GB2MDkYHo4PRwejAvTjmWNocS5tj6W+O5bMk+ORYIs9HLMVWpOIorqIUrRjEp3b+EzoIHYQOQgehg9BB6CB0EDr41M5ZHxGKpdiKVBzFVZSiFYPYOtg62DrYOtg62DrYOtg62Dr49FjO+hWfHsufCMVSbEUqjuIqStEKHRwdHB0cHRwdHB0cHXzWiSc/4tdBfX7kn3Vifb76zzrxKz7rxD8RiqXYilQcxVWUQgdXB6WD0kHpoHRQOigdlA5KB6WD0kHroHXQOmgdtA5aB62D1kHroHUwOvisE3t/xK+D/r6zfSd95/jO9Z3ynfad+ffOfHMsv+/MN8fy987yne076TvHd67vlO+07+ggdBA6CB2EDkIHoYPQQeggdBA6WDpYOlg6WDpYOlg6WDpYOlg6WDrYOtg62DrYOtg62DrYOtg62DrYOkgdpA5SB6mD1EHqIHWQOkgdpA6ODo4Ojg6ODo4Ojg6ODo4Ojg4+TOz6FdTO85Dtm4ds3zxk++Yh2zcP+xPnYX/iPOxPnIf9ifOwP3Ge0kHpoHRQOigdlA5KB6WD0gG18zxk++Yh2zcP2b55yPbNw/7EedifOA/7E+dhf+I87E+cp3UwOhgdjA5GB6OD0cHoYHRAtm8esn0TZPsmyPZNMHtggv2JE+xPnGB/4gT7EyfYnzjB/sSJRwehg9BB6CB0EDr41M6/TwnmO4/l9ynBBLXzBLXz/2IQ1M7/i1AsxVak4iiuQgdLB0sHWwdbB1sHWwdbB1sHWwdbB1sHWwepg9RB6iB1kDpIHaQOUgepg9QBtfMEtfMEtfMEtfMEtfMEtfMEtfMEtfMEtfMEtfPE1cHVwdXB1cHVwdXB1cHVwdXB1UHpoHRQOigdlA5KB6WD0kHpoHTQOmgdtA5aB62D1kHroHXQOmgdjA5GB6OD0cHoYHQwOhgdjA6oncccy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hj+V/8Ovh9SjDfHMueX/Fh4p8IxVJsRSqO4ipK0QodbB1sHWwdbB1sHWwdbB1sHWwdbB2kDlIHqYPUQeogdZA6SB2kDlIHRwdHB0cHRwdHB0cHRwdHB0cHRwdXB1cHVwdXB1cHVwdXB1cHVwdXB6WD0kHpoHRQOigdlA5KB6WD0kHroHXQOmgdtA4+TMz9EVfx6yA//zQ/TPwTg/gw8U+EYim2IhVHcRU6GB0MDr7zWP5EKJZiK1JxFFdRilboIHQQOggdhA5CB6GD0EHoIHTwYeLvg7X55lj+RCiWYitScRRXUYpW6GDrYOtg62DrYOtg62DrYOvgw8Tsj/g4+P0pf3MsfyIUS7EVqTiKqyhFK3RwdHB0cHRwdHB0cHRwdHB0cHRwdHB1cHVwdXB1cHVwdXB1cHVwdXB1UDooHZQOSgelg9JB6aB0UDooHbQOWgetg9ZB66B10DpoHbQOWgejg9HB6GB0MDoYHYwORgejg8HBN8fyJ0KxFFuRiqO4ilK0Qgehg9BB6CB0EDoIHYQOQgehg9DB0sHSwdLB0sHSwdLB0sHSwdLB0sHWwdbB1sHWwdbB1sHWwdbB1oFMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE49MPDLxyMQjE785lvN8xK+DEx/x6+Ccj0jFUVxFKVoxiA8T/0QolkIHRwdHB0cHRwdHB0cHVwdXB1cHVwdXB1cHVwdXB1cHVwelg9JB6aB0UDooHZQOSgelg9JB66B10DpoHbQOWgetg9ZB66B1MDoYHYwORgejg9HB6GB0MDoYHHznsfyJUCzFVqTiKK6iFK34OPit577zWP5EKJZiK1JxFB8H/REfB/MRrdDB0sHSwdLB0sHSwdLB0sHSwdLB0sHWwdbB1sHWwdbB1sHWwdbB1sHWQeogdZA6SB2kDlIHqYPUQeogdXB0cHRwdHB0cHRwdHB0cHRwdHB0cHVwdXB1cHVwdXB1cHVwdXB1cHVQOigdlA5KB6WD0kHpoHRQOigdtA5aB62D1kHroHXQOmgdtA5aB6OD0cHoYHQwOhgdjA5GB6ODwcE3x/InQrEUW5GKo8DBN8fyueg3x/IndCATSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWXiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMT52Xiep6XiT8iFEuxFak4in8OfsQ/Bz+iFToIHYQOQgehg9BB6CB0EDoIHYQOlg6WDpYOlg6WDpYOlg6WDpYOlg62DrYOtg62DrYOtg62DrYOtg62DlIHqYPUQeogdZA6SB2kDlIHqYOjg6ODo4Ojg6ODo4Ojg6ODo4Ojg6uDq4Org6uDq4Org6uDq4Org6uD0kHpoHRQOigdlA5KB6WD0kHpoHXQOmgdtA5aB62D1kHroHXQOhgdjA5GB6OD0cHoYHQwOhgdyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSQiSETQyaGTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxCsTr0y8MvHKxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmmmMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDH8r/QgUw0xxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWH7+Ny4qE5dMNMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlz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kjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSO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KR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErH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tI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L74MT2EQdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bH8PjiBTQybqGO5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6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8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQs7+NY7s/fw/rwb4Ib/x7+mvh9OD6ED/8muPn3UD60D9eH8WF9eDz8NfH7cHwIH5zgOsF1gusE1wmuE1wnGCcYJxgnGCcYJxgnGCcYJxgnGCdYJ1gnWCdYJ1gnWCdYJ1gnWCdYJ3hO8JzgOcFzgucEzwmeEzwneE7wmODjWL4Px4fwIX0oH9qH68P4sD44wXGC4wTHCY4THCc4TnCc4DjBcYLjBOEE4QThBOEE4QThBOEE4QThBOEE6QTpBOkE6QTpBOkE6QTpBOkE6QTlBOUE5QTlBOUE5QTlBOUE5QTlBO0E7QTtBDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cT3/03Mn5//b+L/Ho4P4UP6UD60D9eH8WF9cILjBMcJjhMcJzhOcJzgOMFxguMExwnCCcIJwgnCCcIJwgnCCcIJwgnCCdIJ0gnSCdIJ0gnSCdIJ0gnSCdIJygnKCcoJygnKCcoJygnKCcoJygnaCdoJ2gnaCdoJ2gnaCdoJ2gnaCa4TXCe4TnCd4DrBdYLrBNcJrhNcJxgnGCcYJxgnGCcYJxgnGCcYJxgnWCdYJ1gnWCdYJ1gnWCdYJ1gnWCd4TvCc4DnBc4LnBM8JnhM8J3hOYBOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0Tr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dnEZxOfTXw28dlEHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvvgxPYRB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcv//o8PTmATdSxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0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Y0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pY8utY9u/h3wRz/j38NXHq7+H4k/An6U/Kn7Q/uf5k/Mn6Eye4TnCd4DrBdYLrBNcJrhNcJ7hOcJ1gnGCcYJxgnGCcYJxgnGCcYJxgnGCdYJ1gnWCdYJ1gnWCdYJ1gnWCd4DnBc4LnBM8JnhM8J3hO8JzgOcH7/wnq41j+/aQ+juX7k/An6U/Kn7Q/uf5k/Mn6Eyc4TnCc4DjBcYLjBMcJjhMcJzhOcJwgnCCcIJwgnCCcIJwgnCCcIJwgnCCdIJ0gnSCdIJ0gnSCdIJ0gnSCdoJygnKCcoJygnKCcoJygnKCcoJygnaCdoJ2gnaCdoJ2gnaCdoJ2gneA6wXWC6wTXCa4TXCe4TnCd4DrBdYJxgnGCcYJxgnGCcYJxgnGCcYJxgnWCdYJ1gnWCdYJ1gnWCdYJ1gnWC5wTPCZ4TPCd4TvCc4DnBc4LnBDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDbx2MRjE49NPDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2cRnE59NfDbx2UQdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWH4fnMAm6lhax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LL8PTmATdSy/D05gE3UsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUs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8nEs39c8Bb9j+TiW72ueQnkK7Sl4T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T7zeE6/3xOs98XpPvN4Tr/fE6z3xek+83hOv98TrPfF6T7zeE6/3xOs98XpPvN4Tr/fE6z3xek+83hOv98TrPfG6O1935+vufN2dr7vzdXe+7s7X3fm6O1935+vufN2dr7vzdXe+7s7X3fm6O1935+vufN2dr7vzdXe+7s7X3fm6O1935+vufN2d/xzLfw9O0E7QTuB3LNfvWK7fsVy/Y7l+x3L9juX6Hcv1O5brdyzX71iu37Fcv2P5OJbva/4mXn8Tx9/E8Tdx/E2c9LXytfa162vja+tr9mDtwdqDtQdrD9YerKewnsJ6CusprKfwPIXnKTxP4XkKz1N4nsLzFJ6n8DyFxyl8HMvfa+O/xfk4lu9r6Wvla+1r19fG19bXOIXxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuvuvO7O6+7851j+eygf2ofrw/jA38J6T1zvies9cb0nrvfE9Z643hPXe+J6T1zvies9cb0nrvfE9Z64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fp64fu+8fu+8fu+8fu+8fu+8fu+8fu+8fu+8fu+8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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use jwt::JWT;\nuse std::hash::pedersen_hash;\n\n// Max length of the signed JWT data (header.payload in base64)\nglobal MAX_DATA_LENGTH: u32 = 1024;\n// Max email length (e.g., \"alice@example.com\")\nglobal MAX_EMAIL_LENGTH: u32 = 64;\n// Merkle tree depth (supports 2^20 = 1M users)\nglobal TREE_DEPTH: u32 = 20;\n\n/// Compute Pedersen hash of email bytes (1 byte = 1 Field)\nfn hash_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> Field {\n    let storage = email.storage();\n    let mut fields: [Field; MAX_EMAIL_LENGTH] = [0; MAX_EMAIL_LENGTH];\n    for i in 0..MAX_EMAIL_LENGTH {\n        fields[i] = storage[i] as Field;\n    }\n    pedersen_hash(fields)\n}\n\n/// Compute leaf hash: pedersen(identity_commitment, amount)\nfn compute_leaf(identity_commitment: Field, amount: Field) -> Field {\n    pedersen_hash([identity_commitment, amount])\n}\n\n/// Verify Merkle proof and return computed root\nfn verify_merkle_proof(\n    leaf: Field,\n    siblings: [Field; TREE_DEPTH],\n    path_indices: [Field; TREE_DEPTH],\n) -> Field {\n    let mut current = leaf;\n    for i in 0..TREE_DEPTH {\n        let sibling = siblings[i];\n        let is_right = path_indices[i];\n        // If is_right == 1, current is on right, so hash(sibling, current)\n        // If is_right == 0, current is on left, so hash(current, sibling)\n        let left = if is_right == 1 { sibling } else { current };\n        let right = if is_right == 1 { current } else { sibling };\n        current = pedersen_hash([left, right]);\n    }\n    current\n}\n\n/// Compute secret hash from secret code field\n/// The secret is already converted to Field by the prover (frontend)\n/// Secret = Pedersen hash of 8-char alphanumeric code\nfn hash_secret(secret: Field) -> Field {\n    pedersen_hash([secret])\n}\n\n/// Compute IdentityCommitment = Pedersen(emailHash, secretHash)\n/// This creates an unlinkable identity - same email with different secrets\n/// produces completely different commitments\nfn compute_identity_commitment(email_hash: Field, secret_hash: Field) -> Field {\n    pedersen_hash([email_hash, secret_hash])\n}\n\nfn main(\n    // Private inputs - JWT data\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    expected_email: BoundedVec<u8, MAX_EMAIL_LENGTH>,\n    // Private inputs - Merkle proof\n    amount: Field,\n    merkle_siblings: [Field; TREE_DEPTH],\n    merkle_path_indices: [Field; TREE_DEPTH],\n    // Private input - recipient (returned as public output)\n    recipient: Field,\n    // Private input - Secret code (ADR-012: for unlinkable identity)\n    secret: Field,\n    // Public inputs\n    pubkey_modulus_limbs: pub [u128; 18],\n    merkle_root: pub Field,\n) -> pub (Field, Field) {\n    // 1. Initialize and verify the JWT\n    let jwt: JWT<MAX_DATA_LENGTH> = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n    jwt.verify();\n\n    // 2. Verify the email claim in JWT matches private expected_email\n    jwt.assert_claim_string(\"email\".as_bytes(), expected_email);\n\n    // 3. Compute email hash (intermediate value, NOT exposed publicly)\n    let email_hash = hash_email(expected_email);\n\n    // 4. Compute secret hash (ADR-012)\n    let secret_hash = hash_secret(secret);\n\n    // 5. Compute IdentityCommitment (ADR-012)\n    // This replaces the raw email_hash as the public identity\n    // Same email + different secret = different identity (unlinkability)\n    let identity_commitment = compute_identity_commitment(email_hash, secret_hash);\n\n    // 6. Compute leaf from identity_commitment, amount\n    // Note: Leaf now uses identity_commitment instead of email_hash\n    // REFACTOR: Removed 'salt' input\n    let leaf = compute_leaf(identity_commitment, amount);\n\n    // 7. Verify Merkle proof - computed root must match public merkle_root\n    let computed_root = verify_merkle_proof(leaf, merkle_siblings, merkle_path_indices);\n    assert(computed_root == merkle_root, \"Merkle proof verification failed\");\n\n    // 8. Return identity_commitment and recipient as public outputs\n    // identity_commitment replaces email_hash (ADR-012 privacy upgrade)\n    // Contract verifies msg.sender == recipient to prevent front-running\n    (identity_commitment, recipient)\n}\n\n#[test]\nfn test_hash_email() {\n    // Test with a simple email\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"test@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    let hash = hash_email(email);\n    // Just check it doesn't panic\n    assert(hash != 0);\n}\n\n#[test]\nfn test_hash_secret() {\n    // Test that secret hashing works\n    let secret: Field = 12345678; // Simulated secret code as Field\n    let hash = hash_secret(secret);\n    assert(hash != 0);\n    assert(hash != secret); // Hash should differ from input\n}\n\n#[test]\nfn test_identity_commitment() {\n    // Test that identity commitment is computed correctly\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"alice@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    \n    let email_hash = hash_email(email);\n    let secret: Field = 98765432;\n    let secret_hash = hash_secret(secret);\n    \n    let commitment = compute_identity_commitment(email_hash, secret_hash);\n    assert(commitment != 0);\n    assert(commitment != email_hash); // Commitment should differ from email_hash\n}\n\n#[test]\nfn test_identity_unlinkability() {\n    // CRITICAL TEST: Same email with different secrets = different commitments\n    // This proves the unlinkability property of ADR-012\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"bob@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    \n    let email_hash = hash_email(email);\n    \n    // Two different secrets\n    let secret1: Field = 11111111;\n    let secret2: Field = 22222222;\n    \n    let secret_hash1 = hash_secret(secret1);\n    let secret_hash2 = hash_secret(secret2);\n    \n    let commitment1 = compute_identity_commitment(email_hash, secret_hash1);\n    let commitment2 = compute_identity_commitment(email_hash, secret_hash2);\n    \n    // MUST be different - this is the core privacy property\n    assert(commitment1 != commitment2, \"Unlinkability failed: same email with different secrets must produce different commitments\");\n}\n","path":"/Users/yaman/dev/zarf/zarf/circuits/src/main.nr"},"52":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/yaman/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/lib.nr"},"55":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"56":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"95":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"98":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"99":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"102":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"110":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"139":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr"},"142":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/yaman/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"158":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"159":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"}},"expression_width":{"Bounded":{"width":4}}}