{"noir_version":"1.0.0-beta.17+0d6984c7c643b690e6559351f0cb36ce62b44b26","hash":"8495637966062400922","abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":1024,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"expected_email","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_path_indices","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2707472466662157409":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"6587586420081008171":{"error_kind":"string","string":"Merkle proof verification failed"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"8784292831194001448":{"error_kind":"string","string":"data length is too long"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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sms7QdcOD7t2WHbtIOja6WHXTsuunQRduzzs2mXZtYuga7eHXbstu3YTdO3xsGuPZdcegq69HnbttezaS9C1z8OufZZd+wi69nvYtd+yaz9B1wEPuw5Ydh0g6DroYddBy66DBF2HPOw6ZNl1iKDrsIddhy27DhN0HfGw64hl1xGCrqMedh217DpK0HXMw65jll3HCLqOe9h13LLrOEHXCQ+7Tlh2nSDoOulh10nLrpMEXac87Dpl2XWKoOu0h12nLbtOE3Sd8bDrjGXXGYKusx52nbXsOkvQdc7DrnOWXecIus572HXesus8QdcFD7suWHZdIOi66GHXRcuuiwRdlzzsumTZdYmg67KHXZctuy4TdF3xsOuKZdcVgq6rHnZdtey6StB1zcOua5Zd1wi6rnvYdd2y6zpB1w0Pu25Ydt0g6LrpYddNy66bBF23POy6Zdl1i6Drtoddty27bhN03fGw645l1x2Crrsedt217LpL0HXPw657ll33CLrue9h137LrPkHXAw+7Hlh2PSDoeuhh10PLrocEXY887Hpk2fWIoOuxh12PLbseE3Q98bDriWXXE4Kupx52PbXsekrQ9czDrmeWXc8Iup572PXcsus5QdcLD7teWHa9IOh66WHXS8uulwRdrIF/XaEmm67QDmf4j01XmIddYZZdYQRdb3jY9YZl1xsEXdE87Ipm2RWNoCu6h13RLbuiE3TF8LArhmVXDIKumB52xbTsiknQFcvDrliWXbEIumJ72BXbsis2QdebHna9adn1JkFXHA+74lh2xSHoiuthV1zLrrgEXfE87Ipn2RWPoCu+h13xLbviE3Ql8LArgWVXAoKutzzsesuy6y2CroQediW07EpI0JXIw65Ell2JCLoSe9iV2LIrMUFXEg+7klh2JSHoSuphV1LLrqQEXW972PW2ZdfbBF3JPOxKZtmVjKAruYddyS27khN0pfCwK4VlVwqCrpQedqW07EpJ0JXKw65Ull2pCLre8bDrHcuudwi6UnvYldqyKzVBVxoPu9JYdqUh6ErrYVday660BF3vetj1rmXXuwRd3MMubtnFCbrSediVzrIrHUFXeg+70lt2pSfoyuBhVwbLrgwEXRk97Mpo2ZWRoCuTh12ZLLsyEXRl9rArs2VXZoKuLB52ZbHsykLQldXDrqyWXVkJurJ52JXNsisbQVd2D7uy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","debug_symbols":"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quFV0x9seNXwivPbq+kPNuurZn3F+e3V9Aeb9VWzvmr6g01/sFlfNf3Bpj/Y9Aeb/mDTH2z6g01/sOkPNv3Bpj/43d/+fc3nhVcNrxpecX57NbwaeDXwat55EzXwauAV57fXwKuBVwOvOL+9Bl4NvBp4NcF14dXAq6E/OPBq4NXAq6E/OPBq4NXAq6E/OPBq4BXnt9fQHxzWV8P6ivPba+gPDuurYX019AeH/uCwvvrub//9jf3tb/99vR9eB6+T1y8n/85v/7x+Ofnd3/59XbxuXvN54dXAq4FXnN9eA68GXg28msPnhVcDrzi/vQZeDbwaeMX57TXwauDVwKu5XBdeDbya4rrwauDVwKsprguvBl4NvJriuvBq4BXnt9c012V9NayvOL+9prku66thfTXDdYfrsr767m///MbeeV417zyvGvqDQ39w6A/O2x/s553n1c87z6ufd55XP+88r+b89n5eXvXz8qqfl1fN+e39vLzq5+VVPy+v+nnnTfTz8qqfl1fN+e39BNcNrvvy6v/XXDe5bnLdl1f9JNdNrvvyqp/kusl1k+u+vOpncd3FdRfXfXnVz+K6i+u+vGrOb+9ncd3Fdd/1VXN+ez+b626u+66v+tlcd3Pdd33VzzvPq593nlc/7zyvft55Xv2887z6eed59fPO8+rnnefVzzvPq593nlc/7zyv5vz2fi6f9+VVPy+vmvPb+7l83pdX/by86ufyeV9e9fPyqjm/vZ/iusV1X14157f3U1y3uO7Lq36K6xbXfXnVT3Pd5rrNdZt/v811m+s2123+/TbXHa778qo5v72f4brDdYd/v8N1h+sO133XVx3veTL/vw5eJ6//cbLjnefV8c7z6njneXW887w63nleHe88r453nlfHO8+r453n1fHO82rOb++AVwGvAl5xfnsHvAp4FfAqks8LrwJecX57B7wKeBXwivPbO+BVwKuAV7G4LrwKeBWL68KrgFcBr2JzXXgV8CrgVWyuC68CXnF+e8fmupvrvuur5vz2jsN1D9d911cdh+servuurzreeV4d7zyvjneeV8c7z6vjnefV8c7z6njneXW887w63nleHe88r/7ub//ZA9l/+9vXz+t6eB28Tl4vXm9eH15fXhevm9dct7luc93mus11m+s2122u++XV72f88urzet7X3+dXn9cvJwNeBbwKeBXv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B14dnrcfeHXg1YFXh+ftB14deHXg1eF5+4FXB15xfvscnl8d1leH9RXnt8/h+dVhfXVYXx2etx+eXx3WV+ftD855+4Nz3v7gnLc/OOftD855+4Nz3v7gnLc/OOftD855+4Nz3v7gcH77HHh14NWBV5zfPgdeHXh14NXZfF54deAV57fPgVcHXh14xfntc+DVgVcHXp3DdeHVgVfncF14deDVgVfncl14deDVgVfncl14deAV57fP4Xn7YX11WF9xfvscnrcf1leH9dXhefvhefthfXXe/uCctz845+0Pznn7g3Pe/uCctz845+0Pznn7g3Pe/uCctz845+0PDue3z4FXB14deMX57XPg1YFXB14dnrcfeHXgFee3z4VXF15deMX57XPh1YVXF15d+oMXXl14dekPXnh14dWFV5f+4IVXF15deHXpD154deEV57fPpT94WV9d1lec3z6X/uBlfXVZX136g5f+4GV9dekPXvqDl/7gpT946Q9e+oOX/uClP3jpD176g9/97d/XfF54deHVhVec3z4XXl14deHVPXxeeHXhFee3z4VXF15deMX57XPh1YVXF17dy3Xh1YVXl/7ghVcXXl14dekPXnh14dWFV5f+4IVXF15xfvtc+oOX9dVlfcX57XPpD17WV5f11aU/eOkPXtZX3/3tn99Yv5z829/+eR28Tl6/nPw7v/3z+uXkd3/793Xxunn9ft6CVwWvCl5xfvsUvCp4VfCq3vMZpuBVwSvOb5+CVwWvCl5xfvsUvCp4VfCqguvCq4JXlVwXXhW8KnhVyXXhVcGrgleVXBdeFbzi/PapxXVZXxXrK85vn1pcl/VVsb6qzXU312V99d3f/vsbq3ee19Q7z2uK/mDRHyz6g0V/sN55XlPvPK+pd57X1DvPazi/fQpeFbwqeMX57VPwquBVwau6fF54VfCK89un4FXBq4JXnN8+Ba8KXhW8quK68KrgVRXXhVcFrwpeVXNdeFXwquBVNdeFVwWvOL99iv0MxfqqWF9xfvsU+xmK9VWxvqrhuuxnKNZX9c7zmnrneU2/87ym33le0+88r+l3ntf0O89r+p3nNf3O85p+53lNv/O8hvPbp+FVw6uGV5zfPg2vGl41vOr3PJlpeNXwivPbp+FVw6uGV5zfPg2vGl41vOrkuvCq4VUvrguvGl41vOrFdeFVw6uGV724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88Syx1Iysaydy+eJZY+l7DuXtXP5PLHssZR95/Z5YttjafvObd+57Tu3fee279z2ndu+c9t3bvvObd+57Tu3fed2ndgy0Xks6TyWbNeJLROdx5LOY8l2ndgy0Xks2a4TWyY6jyWdx5LtOrFlovNY0nks2a4TWyY6jyXbdWLLROexpPNYsl0ntkx0Hks6jyXbdWLLROexZPs8sX2e2PZY2nVi+zyxfZ7Y9ljadWL7PLHtsbR957bv3Pad275z23du+85t37ntO7d957bv3Pad275zWzu3TGyZ2DKxrZ1bJrZMbJnYPk9smdgysa2dWya2TGyZ2NbOLRNbJrZMbHssLRNbJra1c8vEloktE9vauWViy8SWie3zxJGJIxOdx5LOY8lxnTiuE53Hks5jyXGdOK4TnceSY+08rhPHvvPYdx77zmPfeew7j33nse889p3HvvPYdx77zs5jSeex5MjEkYnOY0nnseTIxJGJzmPJkYkjE53Hks5jyZGJIxOdx5LOY8mRiSMTnceSIxNHJo49lpGJIxNHJo49lpGJIxNHJo49lpGJIxOdx5Jjj2VcJ47rROex5NhjGdeJ4zpx7LGMPZZxnTj2nce+89h3HvvOY9957DuPfeex7zz2nce+89h3dh5LjkwcmTgy0XksOTJxZOLIxPF54sjEkYnOY8mRiSMTRyY6jyVHJo5MHJk4Pk8cmLgemLgeeizrgYnrgYnrgYnroceyHpi4Hpi4Hpi4nkcHoQOYuJzHsp7QQeiAdeJyHst6QgehA9aJ60kdpA5YJ66HvvN66Duvh77zeug7r4e+83roO6+HvvN66Duvh77zeug7r4e+83Iey3qW9wAmrgcmLuexrGd5D2DiemDierb3ACauByYu57GsZ+tg6wAmLuexrOfo4OgAJq7n6ODoACau5+jg6ODoACau5+rg6uDqACau5+rg6gAmLuexrOfq4OqAdeJyHst6SgelA9aJ6ykdlA5YJ66HvvN66Duvh77zeug7r4e+83roO6+HvvN66Duvh77zeug7r4e+83Iey3rGezASaeTBeA/GezASaeTBeA9g4npkovNY/hehSMVS4CBkYsjEkIlB33mFTAyZGKEDmRgyMWRihA5kYsjEkIkROpCJIROdx7IidZA6YJ24nMeyInWQOmCduGLpYOmAdeIK+s4r6DuvoO+8gr7zCvrOK+g7r6DvvIK+8wr6zivoO69vjuVPeA9kYsjEkInOY1khE0MmhkyM4z2QiSETnceyQiaGTAyZ6DyWFTIxZGLIxLg6kIkhE+PqQCaGTAyZGKUDmRgyMWRilA5kYshE57GsKB2UDloetA5aB62Dlgetg9YB68T1zbF8f5YNlf9yLF8RilRA5b95LF8Blb85lj9RilZwD1ImpkxMmeg8lpUyMWViysTkXJyVMjFlovNYVsrElIkpE53HslImpkxMmZihA5mYMjFTBzIxZWLKxEwdyMSUiSkTM3UgE1MmOo9l5dKB68R0neg8lpVLB64T03Vibh1sHbhO/OZYPj/LZJbpSmaZrqTvvJK+80r6zivpO69klulKZpmuZJbpSmaZLuexrJSJKRNTJjqPZaVMTJmYMjGv90Ampkx0HstKmZgyMWWi81hWysSUiSkTs3QgE1MmZulAJqZMTJmYrQOZmDIxZWK2DmRiykTnsaxsHbhOTNeJzmNZOTpwnZiuE3N0MDpwnZjMMl3JLNO1mGW6FrNM12KW6VrMMl2LWaZrMct0LWaZrsUs07WYZbqcx7KWTFwycclE57GsJROXTFwycXFW2FoycclE57GsJROXTFwy0Xksa8nEJROXTFypA5m4ZOJaOpCJSyYumbiWDmTikolLJq6lA5m4ZKLzWNbaOnCduFwnOo9lra0D14nLdeI6Ojg6cJ24mGW6FrNM12KW6VrMMl2LWaZrMct0LWaZrsUs07WYZboWs0zXYpbpch7LWjJxycQlE53HspZMXDJxycRV3gOZuGSi81jWkolLJi6Z6DyWtWTikolLJq7WgUxcMnG1DmTikolLJq7RgUxcMnHJxDU6kIlLJjqPZa3RgevE7TrReSxrc1bY2q4Tt+vEzVlha3N+4tquEzezTNdmlunazDJdm1mmazPLdG1mma7NLNO1mWW6NrNM12aW6frmWH63G6+/HMv6FfkoQpGKpdiKo7iKUrRCB0sHSwdLB0sHSwdLB0sHXyZ+PvaXiV8xiO/zxK+Aylsmbpm4ZeLmrLC1ZeKWiVsmbs4KW1smbpnoPJa1jw5cJ27Xic5jWfvowHXidp24rw6uDlwnOo9lbZm4ZeKWic5jWVsmbpm4ZeIuHcjELRN3+W/hu078iquAB1smbteJ29p5y8QtE7frxG3tvGXidp24rZ23TDTHssyxLHMsa8tEcyzLHMsyx7K2TDTHssyxrC0TzbEscyzLHMs6MtEcyzLHssyxrCMTzbEscyzruE40x7LMsSxzLOu4TjTHssyxLHMs67hONMeyzLGsw5my63Cm7DqcKbsOZ8oucyzLeSzLeSzLeSzLHMtyHstyHstyHss69J2X81iW81jWscfiPJblPJblPJZ17LE4j2U5j2U5j2UdeyzOY1nOY1nH54nHHsvZOjj+DnyeeOyxnKOD4+/AHss5Ojj+En2e6DyW5TyW5TyWdXye6DyW5TyW5TyWdeyxOI9lOY9lHfrO69B3Xqf8JZa/xPKXKBMPfed16DuvQ995HfrOyxzLMseynMeynMeyzLEscyzLeSzLeSzLHMs67T1o/zXKRHMsy3ksy3ksyxzLMseynMeynMeyzLGsY4/FeSzrykRzLMscyzLHsq5MNMeyzLEscyzrykRzLMscy7oy0RzLMseyzLGsKxPNsSxzLMscy7oy0RzLMseyrn3na9/52ne+9p2vfedr3/nad772na9952vf+dp3vtbO5liWOZZljmVda2dzLMscyzLHsq7PE82xLHMs61o7X3sszmNZzmNZ19r52mNxHstyHsu69liuPRbnsazr88Tr88QrE69MvD5PvD5PvDLxysTr88Rrj+XKxGvtfH2eeO2xXPvO19r5+jzx2mO59p2vzxOvPZZr3/nad772na9952vf+dp3vvadr33na9/52ne+9p2vfefrOvHKROexLOexrOs68cpE57Es57Gs6zrxykTnsaxynVgy0Xksy3ksq1wnlkx0HstyHssq14klE53Hssp1YslE57Es57Gscp1YMtF5LMt5LKtcJ5ZMdB7LKp8nls8Tyx5LuU4snyeWzxPLHku5TiyfJ5Y9lrLvXPady75z2Xcu+85l37nsO5d957LvXPady75z2Xcua+eSiSUTSyaWtXPJxJKJJRPL54klE0smlrVzycSSiSUTy9q5ZGLJxJKJZY+lZGLJxLJ2LplYMrFkYlk7l0wsmVgysXyeWDKxZKLzWJbzWFa5TizXic5jWc5jWeU6sVwnOo9llbVzuU4s+85l37nsO5d957LvXPady75z2Xcu+85l37nsOzuPZTmPZbVMbJnoPJblPJbVMrFlovNYVsvElonOY1nOY1ktE1smOo9lOY9ltUxsmeg8ltUysWVi22NpmdgysWVi22NpmdgysWVi22Npmdgy0Xksq+2xtOvEdp3oPJbV9ljadWK7Tmx7LG2PpV0ntn3ntu/c9p3bvnPbd277zm3fue07t33ntu/c9p2dx7JaJrZMbJnoPJbVMrFlYsvE9nliy8SWic5jWS0TWya2THQey2qZ2DKxZWL7PLFlYsvEtsfSMrFlYsvEtsfSMrFlYsvEtsfSMrFlovNYVvs8sV0ntutE57Gs9nliu05s14ltj6V9ntiuE9u+c9t3HvvOY9957DuPfeex7zz2nce+89h3HvvOzmNZIxNHJo5MdB7LGpk4MnFk4th3Hpk4MtF5LGtk4sjEkYnOY1kjE0cmjkwc+84jE0cmjn3nkYkjE0cmjn3nkYkjE0cmjn3nkYkjE53HssYey7hOHNeJzmNZY49lXCeO68SxxzL2WMZ14th3HvvOY9957DuPfeex7zz2nce+89h3HvvOY9/ZeSxrZOLIxJGJzmNZIxNHJo5MHHssIxNHJjqPZY1MHJk4MtF5LGtk4sjEkYlj33lk4sjEse88MnFk4sjEse88MnFk4sjEse88MnFkovNY1th3HtaJ+2GduJ3Hsh/6zvthnbgf1on7oe+8H/rO+2GduB/6zvuh77wf+s77oe+8H/rO+6HvvB/6zvuh77wf+s77oe/8v2iF9yC9BzBxPzBxO49lP+k9gIn7gYn7Se8BTNwPTNzOY9nP0sHSAUzczmPZz9LB0gFM3M/SwdIBTNzP1sHWwdYBTNzP1sHWwdYBTNzP1sHRAUzczmPZz9HB0QHrxO08lv0cHRwdsE7cz9XB1QHrxP3NsXx/lncrjuIqSvFSef/NY/mIeqm8vzmWP5GKpfAelPcAJu4HJm7nseynvAcwcT8tD9p7ABP3AxO381j20zpoHcDE7TyW/YwORgcjkUYHo4ORSKOD0cHoQCYGM6r+F6FIxVLgIGRiyETnsexgRtWORwesE7fzWHaEDkIHrBN3hA5CB6wT9zfH8vlZBrNMdzDLdAd95x30nXfQd95B33kHs0x3MMt0B7NMdzDLdDuPZYdMDJkYMtF5LDtkYsjEkImxvAcyMWSi81h2yMSQiSETnceyQyaGTAyZGFsHMjFkYhwdyMSQiSET4+hAJoZMDJkYRwcyMWSi81h2XB1cHbBO3M5j2XF1cHXAOnFH6aB0wDpxB7NMdzDLdAezTHcwy3QHs0x3MMt0B7NMdzDLdAezTHcwy3QHs0y381h2yMSQiSETnceyQyaGTAyZGOM9kIkhE53HskMmhkwMmeg8lp0yMWViysRkbt9OmZgyMTkrbKdMTJmYMjFDBzIxZWLKxAwdyMSUic5j2Rk6cJ2YrhOdx7IzdeA6MV0nZuogdeA6MZllupNZpjuZZbqTWaY7mWW6k1mmO5llupNZpjuZZbqTWaY7mWW6nceyUyamTEyZ6DyWnTIxZWLKxNzeA5mYMtF5LDtlYsrElInOY9kpE1MmpkzMowOZmDIxrw5kYsrElIl5dSATUyamTMyrA5mYMtF5LDtLB64T03Wi81h2lg5cJ6brxGwdtA5cJyazTHcyy3Qns0x3Mst0J7NMdzLLdCezTHcyy3Qns0x3Mst0f3Msv9uN91+OZX3EUVxFKVrx7hbe3xzLnwhFKpZiK47iKkrRCh2EDkIHXyaej1iKrTgKqLxk4pKJSyYuzgrbSyYumbhk4uKssL1k4pKJzmPZK3XgOnG5TnQey15LB64Tl+vEtXSwdOA60Xkse8nEJROXTHQey14yccnEJRPX1oFMXDJx0WPZfzmWrwgFPFgycblOXNbOSyYumbhcJy5r5yUTl+vEZe28ZKI5lm2OZZtj2UsmmmPZ5li2OZa9ZKI5lm2OZS+ZaI5lm2PZ5lj2konmWLY5lm2OZS+ZaI5lm2PZy3WiOZZtjmWbY9nLdaI5lm2OZZtj2ct1ojmWbY5lL86U3YszZffiTNm9OFN2m2PZzmPZzmPZzmPZ5li281i281i281j2pu+8nceynceyd+ggdBA6YC/O3qGD0EHogL04e4cOUgfsxdnb54k7dZA6YC/O3j5P3KmD1AF7cfZeOlg6YC/O3j5PdB7Ldh7Ldh7L3j5PdB7Ldh7Ldh7L3lsHWwfsT9ybvvPe9J33pu+8N33nvek77y0TN33nvek7703feW/6ztscyzbHsp3Hsp3Hss2xbHMs23ks23ks2xzL3td7QN95m2PZ5li281i281i2OZZtjmU7j2U7j2WbY9m7dEDfeW+ZaI5lm2PZ5lj2lonmWLY5lm2OZW+ZaI5lm2PZWyaaY9nmWLY5lr1lojmWbY5lm2PZWyaaY9nmWPam77w3fed96DvvQ995H/rO+9B33oe+8z70nfeh77wPfed96DvvY+1sjmWbY9nmWPaxdjbHss2xbHMs+/g80RzLNseyj7XzscfiPJbtPJZ9rJ2PPRbnsWznsexjj+XYY3Eeyz4+Tzw+Tzwy8cjE4/PE4/PEIxOPTDw+Tzz2WI5MPNbOx+eJxx7Loe+8j7Xz8Xniscdy6Dvv4/PEY4/l0Hfeh77zPvSd96HvvA99533oO+9D33kf+s770Hfeh77zPvSd96HvvI/rxCMTnceynceyj+vEIxOdx7Kdx7KP68QjE53Hso/rxCMTnceynceyj+vEIxOdx7Kdx7KP68QjE53Hso/rxCMTnceynceyj+vEIxOdx7Kdx7KP68QjE53Hso/PE4/PE489lus68fo88fo88dpjua4Tr88Trz2Wa9/52ne+9p2vfedr3/nad772na9952vf+dp3vvadr33na+18ZeKViVcmXmvnKxOvTLwy8fo88crEKxOvtfOViVcmXpl4rZ2vTLwy8crEa4/lysQrE6+185WJVyZemXitna9MvDLxysTr88QrE69MdB7Ldh7Lvq4Tr+tE57Fs57Hs6zrxuk50Hsu+1s7XdeK173ztO1/7zte+87XvfO07X/vO177zte987Ttf+87OY9nOY9lXJl6Z6DyW7TyWfWXilYnOY9lXJl6Z6DyW7TyWfWXilYnOY9nOY9lXJl6Z6DyWfWXilYnXHsuViVcmXplY9lhKJpZMLJlY9lhKJpZMdB7LLnss5TqxXCc6j2WXPZZynViuE8seS9ljKdeJZd+57DuXfeey71z2ncu+c9l3LvvOZd+57DuXfWfnseySiSUTSyY6j2WXTCyZWDKxfJ5YMrFkovNYdsnEkoklE53HsksmlkwsmVg+TyyZWDKx7LGUTCyZWDKx7LGUTCyZWDKx7LGUTCyZ6DyWXT5PLNeJ5TrReSy7fJ5YrhPLdWLZYymfJ5brxLLvXPady75z2Xcu+85l37nsO5d957LvXPady76z81h2ycSSiSUTnceySyaWTCyZWPadSyaWTHQeyy6ZWDKxZKLzWHbLxJaJLRPbvnPLxJaJbd+5ZWLLxJaJbd+5ZWLLxJaJbd+5ZWLLROex7LbH0q4T23Wi81h222Np14ntOrHtsbQ9lnad2Pad275z23du+85t37ntO7d957bv3Pad275z23d2HstumdgysWWi81h2y8SWiS0T2x5Ly8SWic5j2S0TWya2THQey26Z2DKxZWLbd26Z2DKx7Tu3TGyZ2DKx7Tu3TGyZ2DKx7Tu3TGyZ6DyW3fad23Viu050Hstu+87tOrFdJ7Z957bv3K4T275z23du+85t37ntO7d957bv3Pad275z23f+5lj+hPdAJrZMbJnoPJbdMnFk4sjEYUbVHpk4MtF5LHtk4sjEkYnOY9kjE0cmjkyc0IFMHJk49p1HJo5MHJk49p1HJo5MHJk49p1HJo5MdB7LHvvO4zpxXCc6j2WPfedxnTiuE8e+89h3HteJ3xzL52f5l2P5iP0oQpEKqPw3j+UroPI3x/InStEK74FMHJk4MtF5LHtk4sjEkYlzvAcycWSi81j2yMSRiSMTnceyRyaOTByZOFcHMnFk4pQOZOLIxJGJUzqQiSMTRyZO6UAmjkx0Hsue1oHrxHGd6DyWPa0D14njOnFGB6MD14nfHMv3Z8ks0z3MMt1j33nsO49956HvfB5mmZ6HWabnYZbpeZhlepzHch6YeB6YeB6YeJzHch6YeB6YeB6YeB5mVJ0HJp4HJh7nsZwndBA6gIn/Cx2kDlIHMPE8qYPUAUw8T+ogdZA6gInnWTpYOlg6gInnWTpYOoCJx3ks51k6WDpgnXicx3KerYOtA9aJ59k62DpgnXgeZpmeh1mm52GW6XmYZXoeZpmeh1mm52GW6XmYZXoeZpmeh1mm52GW6XEey3mu9wAmngcmHuexnOd6D2DieWDiea73ACaeByYe57Gcp3RQOoCJx3ks5ykdlA5g4nlKB6UDmHie1kHroHXQ8qB10DpoHbQ8aB2MDmDicR7LeUYHo4ORB6OD0cHogHXiCc4K+1+EIhUvlU8wy/QEs0xPMMv0BLNMTzDL9ASzTE8wy/QEs0xPMMv0BLNMj/NYTsjEkIkhE53HckImhkwMmRjpPZCJIROdx3JCJoZMDJnoPJYTMjFkYsjEWDqQiSETY+lAJoZMDJkYWwcyMWRiyMTYOpCJIROdx3Ji62DrgHXicR7LiaODowPWiSeODo4OWCeeYJbpCWaZnmCW6QlmmZ5glukJZpmeYJbpCWaZnmCW6QlmmZ5vjuV3u/H55ljy8xG+68SvCEUqlmIrjuIqStEKHbQOWgetg9ZB66B10DpoHbQOWgejg9HB6GB0MDoYHYwORgejg8HBN8fyJ0KRio+D+YitOIqr+HWw4iNaMYgPE//Er4OVH5GKpdiKXwdrfcRVlOLj4HzEID5M/BMfB/cjUrEUW/G5aH1EKVrxuejnjn4w+CdCkYql2IqjuIpStEIHWwdbB1sHWwdbBx8Mrs+3/cHgfj6iFL8O9ucL/mDwKz4Y/BOhSMVS/DrYn+/0g8G/d66iFDr4YPD7H7g6uDq4Org6uDq4Org6uDq4Org6KB2UDkoHpYPSQemgdFA6KB2UDloHrYPWQeugddA6aB20DloHrYPRwehgdDA6GB2MDkYHo4PRweDgG135vPONrvyJVCzF9j9wfOcqStEKHYQOQgehg9BB6CB0EDoIHYQOQgepg9RB6iB1kDpIHaQOUgepg9TBh4l7f0QoUrEUW3EUV1GKVgxi62DrYOtg62DrYOtg6+DLxPsRrRjEl4n9EaFIxcfBfMSvg/O5ox8m/omrKMWvg3M+YhAfJv6JXwfn4+3DxD+xFFtxFFdRio+D+ohBfJj4J0KRiqXYiqO4ilLooHTwYeJ9PiIUqViKXwf3821/mPgnruLXwf3c3g8T/8Svg/u5Ox8m/omPg4+3DxP/xMfB50fxYeL9/Cg+TPwTvw7qY/TDxD/RinnFN7pS8RGhSMVSbMVRXEUpWjGI0EHoIHQQOggdhA5CB6GD0EHoIHWQOkgdpA5SB6mD1EHqIHWQOlg6+DCx1kekYim24iiuohStGMSHiX9CB1sHWwdbB1sHWwdbB1sHHybW78//G135E6FIxcdBfcRWHMVVfBz0R7RiEB8m9ucfxoeJfyIVvw7682V9mPgnjuIqfi/a+RGD+GCwPzfkg8E/kYql2IqjuIpStGIQrYPWQeugddA6aB20Dj4Y7P0RHwfnIwbxwWB/vuAPBv9EKpZiK47i4+DznX4w+PdOK+YV37TKn4j3P/BNq/y9sxRbcRTX/0D5Tit0EDoIHYQOQgehg9BB6CB0EDoIHaQOUgepg9RB6iB1kDpIHaQOUgdLB0sHSwdLB0sHSwdLB0sHSwdLB1sHWwdbB1sHWwdbB1sHWwdbB1sHRwdHB0cHRwdHB0cHRwdHB0cHRwdXB1cHHwzO8xFL8etg4iOO4ipK8etg1kcM4sPEPxGKj4OPtw8T/8RWfBzUR1xFKVrxcfD5pB8m/olQpGIptuIorqIUrdDBh4kzHxGKVCzFj4P/Hx9/xFFcRf2K/IhWzCs+aZV/In7F8xGpWIqtOO83902r/IlStILfwTet8ifi/YK/aZU/sRRbcRT8Dr5plT/RikEkv4NvWuVPpGIptuIorqIUreB38E2r/Al+B9+0yp9Yiq34/A4+N3FdRSn6/YV80ip/Yj+KUKRi8XPZW3EUV1H8XHYrBnEeBTz4plX+xFJshb/E4y/xw8TvL+TDxD8xiA8T/4S/xC8TPz+XLxO/YiuOwt/B9Xdw/R1cfwfl76D8JZa/xPKXWP4Sy19i6eDLxM/P5cvErxhEP4rgt9OpWAqI9Emr/BNXUQp/iS2RRiJNKFIhkUYifZn4FVchkUYiDUT6plX+RChSAZG+aZU/cRRXUQqI9E2rfMWXiV8RCn4H37TKn9iKo7iKUrSCX2LJxJKJJRO/aZXPz+WbVvkTR3EVEOmTVvknBrEg0iet8k+k4vM72B+xFZ/fwedef5n4FaX4OPjc3i8TPx/uy8TP/+3LxK9IxVJs/mtfJn7/azrYOvgy8SsG8WXi5792gv/a0cHRwdkK78G5/tfK/5oOjg6u9+B6D27yX7uL/9rVwdXB9R5c78H1W7h+C6WD0kF5D8p7UH4L5bdQOigdlPegvAftt9B+C62D1kF7D9p70H4L7bfQOmgdjPdgvAfjtzB+C6OD0cF4D8Z7MH4Lw7fQDw76CUUqloJv4ZNW+fdfu/7fStEK7sEnrfL3Xwu+hU9a5d//TQexFUdx/a+V/7VfB/F959fBZ3vHJ63yT4QiFUuxFUdxFaX4dfDZdvFJq/yJDxP/RChSsRRbcRRXUQodLB1sHWwdbB1sHWwdbB1sHWwdbB1sHRwdHB0cHRwdHB0cHRwdHB0cHRwdXB1cHVwdXB1cHVwdXB1cHVwdXB2UDkoHpYPSQemgdPBh4mevxyet8k/8OljPRwziw8Q/EYpfB59dIJ+0yj+xFUdxFaX4OMiPGMSHiV+jHyb+iY+D9RFLsTH6YeKfuIpSNHY+TPyIT1rlnwhFKpZivx/hk1b5J/gWPmmVf6Lfj/BJq/yJ4Fv4pFX+iVQsBd/CJ63yT1xFKVrhPfgw8fsRPkz8E8lH+DDxT2w+woeJf4Jv4ZNW+SdawS/xk1b5s7P8FpbfwvJbWN6D5T34MPH7ET5M/BPNR/gy8SM+TPx+hA8T/4TfwvZb2FtxFH4L229h+y1sv4XjPTjegw8Tvx/hw8Q/sfkIXyZ+xeUjfJj4J/wWjt/C9Zd4/SVev4Xrt3D9Fq7fwvUeXO/BhQeftMqfKHgwFQp48Emr/BN+C+W3UP4Sy19i+S2U30L7LbTfgkwcmTgtD1oetDxoedDyoOXB+C2M38L4Sxx/ieO3MH4L47cwfgsycWDifZ6XB/d5QvHy4H7SKv/Ey4P7PEfxfgv3k1b5J1oxiHiwE6FIxVJsxVFcPkKUovkIMYh8+AgZisRoLsVWHMXFTpaiFX4Ly3uwvAcr+QhrKTYfYR3F5SOsUvgtLL+F/ShC4bew/Ra238L2W9jeg+092M1H2IM4Dx/hhCL5CGcp/BaO38Lxl3j8JR6/heO3cP0Wrt/C9R5c78HdfIR7FJePcEvRfIQ7iPJbKL+F8pdY/hLLb6H8FspvofwWyntQ3oOWBy0PWh60PGh50PKg/Rbab6H9Jba/xPFbGL+F8VsYv4XxHoz3YOTByIORBwMP4oEH8YSCbyGepdiKo+BbiKcUreBbCJkYMjECHkQsBTz4pFX+CXgQUQq+hQi+hchHEQq+hcil2Iqj8B7IxEh4EAkPYsGDWKGAB7GWwm9h+S2sqyiF38LyW9h+C9tvQSaGTIwND2IfBTyIXQp4EBsexPFbOH4Lx1/i8Zd4/BaO38LxWzh+CzIxZGJceBA3FB8H+yOW4uPgfMRRXEUpWjGILxO/IhSpWAodlA5KB6WD0kHpoHXQOmgdtA5aB62D1kHroHXQOhgdjA5GB6OD0cHo4MvE+xGl+HWwv/+3ecUnrfJPhCIVS7EVR3EVpWiFDkIHoYPQQeggdBA6CB18mLjrI1oxiA8T/0QoUrEUW3EUV6GD1EHqYOlg6WDpYOlg6WDp4MPEkx9RilYM4sPEPxGKVCzFVhyFDrYOtg62Do4Ojg6ODj5MPPsjfh387q69n+jK/1T4iKsoRSsG8WHinwhFKpZiK3RwdXB1cHVwdVA6KB2UDkoHpYPSQemgdFA6KB20DloHrYPWQeugddA6aB18mPi7c/F+oivRn3c+TPy+82Hi3zvpO8t3tu8c37m+U76jg8HBJ7ryfecTXfn3TvrO8p3tO8d3ru+U77Tv6CB0EDoIHYQOQgehg9BB6CB0EDpIHaQOUgepg9RB6iB1kDpIHaQOlg6WDpYOlg6WDpYOlg6WDpYOlg62DrYOtg62DrYOtg62DrYOtg62Do4Ojg6ODo4Ojg6ODj5M7PqIXwe/OwrvJ7ryTwziw8Q/EYpULMVWHMVV6ODq4OqgdFA6KB2UDkoHpYMPE+dzdz5M/BOtGMSHiX8iFKlYiq04Ch20DloHrYPRwehgdDA6GB18mPi7WeR+oiv/RClaMa/4RFf+iVCkYim24iiuohSt0EHoIHTwy8T83Vt0P9GV/J1RdT/RlYzv/+0orqIUrRjELxP/iVCkYil0kDpIHaQOUgepg6WDpYOlg6WDpYOlg6WDpYOlg6WDrYOtg62DrYOtg62DrYNfJv6/fP6IXwf5fWd455eJf+/8MvHfO+k7y3e27xzfub6jg6ODo4Org6uDq4Org6uDq4Org6uDq4Org9JB6aB0UDooHZQOSgelg9JB6aB10DpoHbQOWgetg9ZB66B10DoYHYwORgejg9HB6GB0MDoYHQwOPjmW7zufHMu/d9J3lu9s3zm+c32nfKd9Rwehg9BB6CB0EDr4MPHzhOmTY/n+ofzkWP6JVvDX+ZNj+SdCkYql2Iqj0EHqIHWQOlg6WDpYOlg6WDpY/HX+5Fj+iVK0gr/OnxzLPxGKVCzFVuhg62DrYOtg6+Do4Ojg6ODo4PDX+ZNj+SeuohSt4K/zuY8iFKlYCh1cHVwdXB1cHVwdlA4+TPwsCT45lu+S4JNj+f7J+eRY/omjuIpStIK/jZ8cyz8RilTooHXQOmgdtA5aB62D0cHoYHQwOhgdjA5GB6OD0cHg4JNj+SdCkYql2IqjuC+47peJ33fad4Z3vkz8vPNl4ved9J3lO9t3ju/oIHQQOggdpA5SB6mD1EHqIHWQOkgdpA5SB0sHSwdLB0sHSwdLB0sHSwdLB0sHWwdbB1sHWwdbB1sHWwdbB1sHWwdHB0cHRwdHB0cHRwdHB0cHRwdHB1cHVwdXB1cHVwdXB1cHVwdXB1cHpYPSQemgdPBh4mdJcK2db11FKVrBX+fbjyIUqViKrdBB66B10DpoHYwORgejg9GBtfM3x/InrqIUreCvcz2PIhSpWIqtOIqrKEUrdBA6CB2EDoK/zp8cyz9xFFdRilbw17nyUYQiFTpIHaQOUgepg9RB6uDDxM+SoL618+djWzuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO39yLP+EDrYOjg6ODo4Ojg6ODo4Ojg6ODo4Ojg6uDq4Org6uDq4OrJ3L2rmsncvauaydy9q5rJ3L2rmsncvauaydy9q5rJ3L2rmsncvauaydy9q5rJ3L2rmsncvauaydy9q5rJ3L2rmsncvauaydy9q5rJ3L2rmsncvauayd29q5rZ3b2rmtndvaua2d29q5rZ3b2rmtndvaua2d29q5rZ3b2rlDB6GD0EHoIHSQOkgdpA5SB6mD1EHqIHWQOkgdLB0sHSwdfJj4WRK0tfM3x/InrqIUreCv8zfH8idCkYql0MHWwdbB1sHWwdbB0cHRwdGBtfM3x/InjuIqStEK/jp/cyx/IhSp0MHVwdXB1cHVwdXB1UHpoHRQ/HX+5lj+xFYcxVWUohX8df7mWP5EKHTQOmgdtA5aB62D1sGHiZ8lQX9r58/HtnZua+e2dm5r57Z2bmvntnZua+e2dh5r57F2HmvnsXYea+exdv7kWP6JUrRCB6GD0EHoIHRgj2XssYw9lrHHMvZYxh7L2GMZeyxjj2XssYy181g7j7XzWDuPtfNYO4+181g7j7XzWDuPtfNYO4+181g7j7XzWDuPtfNYO4+181g7j7XzWDuPtfNYO4+181g7j7XzWDuPtfNYO4+181g7j7XzWDuPtfNYO4+181g7j7XzWDuPtfNYO4+181g7j7XzWDuPtfNYO4+181g7T+mgdFA6KB2UDkoHrYPWQeugddA6aB20DloHrYPWwehgdPBh4mdJMNbO3xzLnziKqyhFK96/zvXNsfyJUKRiKbbiKK6iFK3QQeggdEDtXN8cy5/YiqO4ilK0YhD5KEKhg9RB6iB1kDpIHaQOUgdLB+v961zfHMufWIqtOIqrKEUrBrEfhQ62DrYOtg62DrYOtg4+THw+X/C3dv58bGrneqid66F2rofauR5q53qoneuhdq6H2rkeaud6qJ3ruTq4Org6uDq4Org6uDq4Org6uDooHZQOSgelg9JB6aB0UDooHZQOWgetg9YBtXM91M71UDvXQ+1cD7VzPdTO9VA710PtXA+1cz3UzvWMDkYHo4PRwehgdEDtXEHtXEHtXEHtXEHtXEHtXEHtXEHtXEHtXEHtXPHoIHQQOggdhA5CB6GD0EHoIHQQOkgdpA5SB6mD1EHqIHWQOkgdpA6WDpYOlg6WDpYOlg6WDpYOlg6WDrYOtg62DrYOtg62DrYOtg62DrYOjg4+TPxdElRQO9c3x/IntuIorqIUreCvc7A/sYL9iRVXB1cHVwdXB1cHVwdXB1cHpQNq5/rmWP7EUmzFUVxFKVrBX+dgf2JF66B10DpoHbQOWgetg9ZB62D46/zNsfyJVCzFVhzFVZSiFawPkv2JlexPrGR/YiX7EyvZn1jJ/sRK9ifWJ8fyXRLkt3ZeH8FfpqR2rqR2rqR2rqR2rqR2rqR2rqR2rqR2/l+0Qgepg9RB6iB1kDpIHaQOUgepg9TB0sHSwdLB0sHSwdLB0sHSwdLB0sHWwdYBtXMltXMltXMltXMltXMltXMltXMltXMltXMltXPl0cHRwdHB0cHRwdHB0cHRwdXB1cHVwdXB1cHVwdXB1cHVwdVB6aB0UDooHZQOSgelg9JB6aB00DpoHbQOWgetg9ZB66B10DpoHYwORgejg9HB6GB0MDoYHYwOBgfrwcF6wnfSd5bvbN85vnN9p3ynfUcHHyZ+lgTL2vmbY/kTS7EVR3EVpWgFf50X+xNrpQ5SB6mD1EHqIHWQOkgdpA6snb85lj+RiqXYiqO4ilK0gr/Oa+tg62DrYOtg62DrYOtg62DrYPPX+Ztj+ROhSMVSbMVRXEUpWqGDq4Org6uDq4Org6uDDxM/S4L1rZ0/H9vaeVk7L2vnZe28rJ2XtfOydl7WzsvaeVk7L2vnZe28rJ2XtfOydl6tg9ZB66B10DpoHbQORgejg9HB6GB0MDoYHYwORgf0WGrTY6lt7bytnbe187Z23tbO29p5Wztva+dt7bytnbe187Z23tbO29p5Wztva+dt7bytnbe187Z23tbO29p5Wztva+dt7bytnbe187Z23tbO29p5Wztva+dt7bytnbe187Z23tbO29p5Wztva+dt7bytnbe187Z23tbO29rZHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZYylzLGWOpcyxlDmW+uZYPkuCbe28yfbVJttXm2xfbbJ9tdmfWJv9ibXZn1ib/Ym12Z9Yu3XQOmgdtA5aB62D1kHroHVg7bzJ9tUm21ebbF9tsn212Z9Ym/2JtdmfWJv9ibXZn1ib/Yl12J9Yh/2JddifWIf9iXXYn1iH/Yl12J9Yh/2Jdcj21SHbV4dsXx2yfXUiFUuxFUdxFaXQQeggdZA6SB2kDlIHHyZ+lgTnWzt/Pra187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7Xy2DrYOtg62DrYOtg62DrYO7LEceyzHHsuxx3LssRx7LMcey7HHcuyxHHssx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbO19r5Wjtfa+dr7Xytna+1szmWMsdS5ljKHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZYylzLGWOpcyxlDmWMsdS5ljKHEuZYylzLPXNsXyWBNfa+ZLtq0u2ry7Zvrpk++qyP7Eu+xPrsj+xLvsT67I/se7SwdbB1sHWwdbB1sHWwdbB1oG18yXbV5dsX12yfXXJ9tVlf2Jd9ifWZX9iXfYn1mV/Yt2jg6ODq4Org6uDq4Org6uDqwOyfXXJ9tUl21eXbF/dCkUqlmIrjuIqdFA6KB20DloHrYPWwYeJnyXB/dbOn49t7Xytna+187V2vtbO19r5Wjtfa+dr7Xytna+187V2vtbO19q5rJ2L/YlV7E+sYn9iFfsTq9ifWMX+xCr2J1axP7HKHkvZYyl7LGWPpeyxlD2WssdS9ljKHkvZYylr57J2LmvnsnYua+eydi5r57J2LmvnsnYua+eydi5r57J2LmvnsnYua+eydi5r57J2LmvnsnYua+eydi5r57J2LmvnsnYua+eydi5r57J2LmvnsnYua+eydi5r57J2LmvnsnYua+eydi5r57J2LmvnsnY2x1LmWMocS5ljKXMsZY6lzLGUOZYyx1LmWMocS5ljKXMsZY6lzLGUOZYyx1LmWMocS5ljKXMsZY6lvjmWz5KgrJ2LbF8V2b4qsn1VZPuq2J9Yxf7EKvYnVrE/sYr9iVWjA/cntvsT2/2J7f7Edn9iuz+x3Z/Y7k9sa+cm21dNtq+abF812b5q9ye2+xPb/Ynt/sR2f2K7P7Hdn9juT2z3J7b7E9v9ie3+xHZ/Yrs/scn2VZPtqybbV022r77zWP5EKFKxFFtxFDpwf2K7P7Hdn9juT2z3J7b7Ez85lu+SoL+18+djWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7f7E9v9ie3+xHZ/Yrs/sd2f2O5PbPcntj2WtsfS9ljaHkvbY2l7LG2Ppe2xtD2WtsfS1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3tPNbOY+081s5j7TzWzmPtPNbOY+081s5j7TzWzmPtPNbOY+081s5j7TzWzmPtPNbOY+081s5j7TzWzmPtbI6lzLGUOZYyx1LmWMocS5ljKXMsZY6lzLGUOZYyx1LmWMocS5ljKXMsZY6lzLGUOZYyx1LmWMocS31zLJ8lwVg7D9m+GrJ9NWT7asj21bg/cdyfOO5PHPcnjvsTx/2J4/7EcX/iuD9x3J847k8c9yeO+xPH/Ylj7Txk+2rI9tWQ7ash21fj/sRxf+K4P3HcnzjuTxz3J477E8f9ieP+xHF/4rg/cdyfOO5PHPcnDtm+GrJ9NWT7asj21Xcey1e4P3HcnzjuTxz3J477E8f9ieP+xHF/4rg/cdif2A/7E/thf2J/ciyfJUE/39p5fcT7l6kfaud+qJ37oXbuh9q5H2rnfqid+6F27ofauR9q535CB6GD0EHoIHQQOkgdpA5SB6mD1EHqIHWQOkgdpA6WDpYOlg6WDpYOlg6WDqid+6F27ofauR9q536onfuhdu6H2rkfaud+qJ37oXbuZ+tg62Dr4Ojg6ODo4Ojg6ODo4Ojg6ODo4Ojg6uDq4Org6uDq4Org6uDq4Org6qB0UDooHZQOSgelg9JB6aB0UDpoHbQOWgetg9ZB66B10DpoHbQORgejg9HB6GB0MDoYHYwORgfkWNocS5tjaXMsbY6lzbH0N8fyuyTooHbuINvXQbavg2xfB9m+DvYndrA/sYP9iR3sT+xgf2JH6CB0EDoIHaQOUgepg9RB6oDauYNsXwfZvg6yfR1k+zrYn9jB/sQO9id2sD+xg/2JHUsHSwdLB0sHSwdbB1sHWwdbB2T7Osj2dZDt6yDb1995LH+Cv87B/sQO9id2sD+xg/2JHUcHRwdHB0cHRwdHB1cHHyZ+lgTxrZ0/H5vauYPauYPauYPauYPauYPauYPauYPauYPauYPauaN0UDooHZQOSgelg9JB66B10DpoHbQOWgetg9ZB66B1MDoYHYwORgejg9EBtXMHtXMHtXMHtXMntXMntXMntXMntXMntXMntXMntXMntXMntXPno4PQQeggdBA6CB2EDkIHoYPQQeggdZA6SB2kDlIHqYPUQeogdZA6WDpYOlg6WDpYOlg6WDpYOlg6WDrYOtg62DrYOtg62DrYOtg62DrYOjg6ODo4Ojg6ODo4Ojg6ODo4Ojg6uDq4Org6uDr4MPGzJEhq506yfZ1k+zrJ9nWS7etkf2In+xM72Z/Yyf7ETvYndpYOSgelg9JB6aB10DpoHbQOqJ07yfZ1ku3rJNvXSbavk/2JnexP7GR/Yif7EzvZn9g5OhgdjA5GB6MD9if2Yn9iL/Yn9mJ/Yi+yfb3I9vUi29eLbF8vZg/0Yn9iL/Yn9mJ/Yi/2J/Zif2Kv0EHoIHQQOggdhA5CBx8mfpYE61s7fz62tfOydl7WzsvaeVk7L2vnZe28rJ2XtfOydl7WzsvaeVk7L2vnZe28lg6WDpYOtg62DrYOtg62DrYOtg62DrYOtg6ODo4Ojg6ODo4OrJ2XtfOydl7WzsvaeVk7L2vnZe28rJ2XtfOydl7WzsvaeVk7L2vnZe28rJ2XtfOydl7WzsvaeVk7L2vnZe28rJ2XtfOydl7WzsvaeVk7L2vnZe28rJ2XtfOydl7WzsvaeVk7L2vnZe28rJ2XtfOydl7WzsvaeVs7m2NpcyxtjqXNsbQ5ljbH0uZY2hxLm2NpcyxtjqXNsbQ5ljbH0uZY2hxLm2NpcyxtjqXNsbQ5ljbH0t8cy2dJsK2dN9m+3mT7epPt6022rzf7E3uzP7E3+xN7sz+xN/sTey8dLB0sHSwdLB0sHWwdbB1sHVg7b7J9vcn29Sbb15tsX2/2J/Zmf2Jv9if2Zn9ib/Yn9j46ODo4Ojg6ODo4Ojg6uDq4OiDb15tsX2+yfb3J9vVm9kBv9if2Zn9ib/Yn9mZ/Ym/2J/YuHZQOSgelg9JB6aB08GHiZ0nwncfyWRJsa+dt7bytnbe187Z23tbO29p5Wztva+dt7bytnbe187Z23tbO29p5jw5GB6MD9if2YX9iH/Yn9mF/Yh/2J/axx3LssRx7LMcey7HHcuyxHHssxx7Lscdy7LEca+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbOx9r5WDsfa+dj7XysnY+187F2PtbO5ljaHEubY2lzLG2Opc2xtDmWNsfS5ljaHEubY2lzLG2Opc2xtDmWNsfS5ljaHEubY2lzLG2Opc2x9DfH8lkSHGvnQ7avD9m+PmT7+pDt68P+xD7sT+zD/sQ+7E/sw/7EPqOD0cHoYHQwOhgdsD+xL/sT+7I/sa+18yXb15dsX1+yfX3J9vVlf2Jf9if2ZX9iX/Yn9mV/Yt/QQeggdBA6CB2EDkIHoYPUAdm+vmT7+pLt60u2ry+zB/qyP7Ev+xP7sj+xL/sT+7I/se/SwdLB0sHSwdLB0sHSwYeJnyXBdx7LZ0lwrZ2vtfO1dr7Wztfa+Vo7X2vna+18rZ2vtfO1dr7Wztfa+Vo7X2vne3RwdHB0cHRwdHB1cHVwdWCP5dpjufZYrj2Wa4/l2mO59liuPZZrj+XaY7nWztfa+Vo7X2vna+18rZ2vtfO1dr7Wztfa+Vo7X2vna+18rZ2vtfO1dr7Wztfa+Vo7X2vna+18rZ2vtfO1dr7Wztfa+Vo7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7VzWTuXtXNZO5e1c1k7l7WzOZY2x9LmWNocS5tjaXMsbY6lzbG0OZY2x9LmWNocS5tjaXMsbY6lzbG0OZY2x9LmWNocS5tjaXMs/c2xfJYEZe1cZPu6yPZ1ke3rItvXxf7ELvYndrE/sYv9iV3sT+w6Ojg6ODo4Ojg6ODo4Ojg6uDqwdi6yfV1k+7rI9nWR7etif2IX+xO72J/Yxf7ELvYndpUOSgelg9JB6aB0UDooHZQOyPZ1ke3rItvXRbavi9kDXexP7GJ/Yhf7E7vYn9jF/sSu0cHoYHQwOhgdjA5GBx8mfpYE33ksnyVBWTu3tXNbO7e1c1s7t7VzWzu3tXNbO7e1c1s7t7VzWzu3tXNbO7f7E9v9ie3+xHZ/Yrs/sd2f2O5PbPcntj2WtsfS9ljaHkvbY2l7LG2Ppe2xtD2WtsfS1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3t3NbObe3c1s5t7dzWzm3tbI6lzbG0OZY2x9LmWNocS5tjaXMsbY6lzbG0OZY2x9LmWNocS5tjaXMsbY6lzbG0OZY2x9LmWNocS39zLJ8lwSfHEvt8RCqWYiuO4ipK0YpBfGrnP6GD0EHoIHQQOggdhA5CB6GDT+286yNCkYql2IqjuIpStGIQSwdLB0sHSwdLB0sHSwdLB0sHnx7LyV/x6bH8iVCkYim24iiuohSt0MHRwdHB0cHRwdHB0cFnnXj2R/w6qM+P/LNOrM9X/1knfsVnnfgnQpGKpdiKo7iKUujg6qB0UDooHZQOSgelg9JB6aB0UDpoHbQOWgetg9ZB66B10DpoHbQORgefdWKvj/h10N93lu9s3zm+c32nfKd9Z/69M98cy+87882x/L2TvrN8Z/vO8Z3rO+U77Ts6CB2EDkIHoYPQQeggdBA6CB2EDlIHqYPUQeogdZA6SB2kDlIHqYOlg6WDpYOlg6WDpYOlg6WDpYOlg62DrYOtg62DrYOtg62DrYOtg62Do4Ojg6ODo4Ojg6ODo4Ojg6ODDxO7fgW18zxk++Yh2zcP2b55yPbNw/7EedifOA/7E+dhf+I87E+cp3RQOigdlA5KB6WD0kHpoHRA7TwP2b55yPbNQ7ZvHrJ987A/cR72J87D/sR52J84D/sT52kdjA5GB6OD0cHoYHQwOhgdkO2bh2zfBNm+CbJ9E8wemGB/4gT7EyfYnzjB/sQJ9idOsD9x4tFB6CB0EDoIHYQOPrXz71OC+c5j+X1KMEHtPEHt/L8YBLXz/yIUqViKrTiKq9BB6iB1sHSwdLB0sHSwdLB0sHSwdLB0sHSwdbB1sHWwdbB1sHWwdbB1sHWwdUDtPEHtPEHtPEHtPEHtPEHtPEHtPEHtPEHtPEHtPHF1cHVwdXB1cHVwdXB1cHVwdXB1UDooHZQOSgelg9JB6aB0UDooHbQOWgetg9ZB66B10DpoHbQOWgejg9HB6GB0MDoYHYwORgejA2rnMccy5ljGHMuYYxlzLGOOZcyxjDmWMccy5ljGHMuYYxlzLGOOZcyxjDmWMccy5lj+F78Ofp8SzDfHsuZXfJj4J0KRiqXYiqO4ilK0QgdLB0sHSwdLB0sHSwdLB0sHSwdLB1sHWwdbB1sHWwdbB1sHWwdbB1sHRwdHB0cHRwdHB0cHRwdHB0cHRwdXB1cHVwdXB1cHVwdXB1cHVwdXB6WD0kHpoHRQOigdlA5KB6WD0kHroHXQOmgdtA4+TNzrI67i18H+/NP8MPFPDOLDxD8RilQsxVYcxVXoYHQwOPjOY/kToUjFUmzFUVxFKVqhg9BB6CB0EDoIHYQOQgehg9DBh4m/D9bmm2P5E6FIxVJsxVFcRSlaoYOlg6WDpYOlg6WDpYOlg6WDDxN3f8THwe9P+Ztj+ROhSMVSbMVRXEUpWqGDo4Ojg6ODo4Ojg6ODo4Ojg6ODo4Org6uDq4Org6uDq4Org6uDq4Org9JB6aB0UDooHZQOSgelg9JB6aB10DpoHbQOWgetg9ZB66B10DoYHYwORgejg9HB6GB0MDoYHQwOvjmWPxGKVCzFVhzFVZSiFToIHYQOQgehg9BB6CB0EDoIHYQOUgepg9RB6iB1kDpIHaQOUgepg6WDpYOlg6WDpYOlg6WDpYOlA5m4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpm4ZeKWiVsmbpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOKRiUcmHpl4ZOI3x3Kej/h1cOIjfh2c8xFbcRRXUYpWDOLDxD8RilTo4Ojg6ODo4Ojg6ODo4Org6uDq4Org6uDq4Org6uDq4OqgdFA6KB2UDkoHpYPSQemgdFA6aB20DloHrYPWQeugddA6aB20DkYHo4PRwehgdDA6GB2MDkYHg4PvPJY/EYpULMVWHMVVlKIVHwe/9dx3HsufCEUqlmIrjuLjoD/i42A+ohU6SB2kDlIHqYPUQeogdZA6SB2kDpYOlg6WDpYOlg6WDpYOlg6WDpYOtg62DrYOtg62DrYOtg62DrYOtg6ODo4Ojg6ODo4Ojg6ODo4Ojg6ODq4Org6uDq4Org6uDq4Org6uDq4OSgelg9JB6aB0UDooHZQOSgelg9ZB66B10DpoHbQOWgetg9ZB62B0MDoYHYwORgejg9HB6GB0MDj45lj+RChSsRRbcRQ4+OZYPhf95lj+hA5kYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4rxMzOd5mfgjQpGKpdiKo/jn4Ef8c/AjWqGD0EHoIHQQOggdhA5CB6GD0EHoIHWQOkgdpA5SB6mD1EHqIHWQOlg6WDpYOlg6WDpYOlg6WDpYOlg62DrYOtg62DrYOtg62DrYOtg62Do4Ojg6ODo4Ojg6ODo4Ojg6ODo4Org6uDq4Org6uDq4Org6uDq4Org6KB2UDkoHpYPSQemgdFA6KB2UDloHrYPWQeugddA6aB20DloHrYPRwehgdDA6GB2MDkYHo4PRgUwMmRgyMWRiyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSQiSETQyaGTAyZGDIxZGLIxJCJIRNDJoZMDJkYMjFkYsjEkIkhE0MmhkwMmRgyMWRiyMSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTEyZmDIxZWLKxJSJKRNTJqZMTJmYMjFlYsrElIkpE1MmpkxMmZgyMWViysSUiSkTUyamTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TNwyccvELRO3TDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTLwy8crEKxOvTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJKJJRNLJpZMLJlYMrFkYsnEkoklE0smlkwsmVgysWRiycSSiSUTSyaWTCyZWDKxZGLJxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMbJnYMrFlYsvEloktE1smtkxsmdgysWViy8SWiS0TWya2TGyZ2DKxZWLLxJaJLRNbJrZMHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFk4sjEkYkjE0cmjkwcmTgycWTiyMSRiSMTRyaOTByZODJxZOLIxJGJIxNHJo5MHJk4MnFkojmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLP8LHchEcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjiXMsYQ5ljDHEuZYwhxLmGMJcyxhjuXnf+OiMjFlojmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuaY0lzLGmOJc2xpDmWNMeS5ljSHEuaY0lzLGmOJc2xpDmWNMeS5ljSHEuaY0lzLGmOJc2xpDmWNMeS5ljSHEuaY0lzLGmOJc2xpDmWNMeS5ljSHEuaY0lzLGmOJc2xpDmWNMeS5ljSHEuaY0lzLGmOJc2xpDmWNMeS5ljSHEuaY0lzLGmOJc2xpDmW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SR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQsvw9OYBN1LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylY/l9cAKbGDZRx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKx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rWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5ffBCWyijuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYfh+cwCaGTdSxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L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y9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L74MT2MSwiTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lvdxLPfn72F9+DfBjX8Pf038Phwfwod/E9z8eygf2ofrw/iwPjwe/pr4fTg+hA9OcJ3gOsF1gusE1wmuE4wTjBOME4wTjBOME4wTjBOME4wTrBOsE6wTrBOsE6wTrBOsE6wTrBM8J3hO8JzgOcFzgucEzwmeEzwneEzwcSzfh+ND+JA+lA/tw/VhfFgfnOA4wXGC4wTHCY4THCc4TnCc4DjBcYJwgnCCcIJwgnCCcIJwgnCCcIJwgnSCdIJ0gnSCdIJ0gnSCdIJ0gnSCcoJygnKCcoJygnKCcoJygnKCcoJ2gnaCdgKb+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzi+/8m5s/P/zfxfw/Hh/AhfSgf2ofrw/iwPjjBcYLjBMcJjhMcJzhOcJzgOMFxguME4QThBOEE4QThBOEE4QThBOEE4QTpBOkE6QTpBOkE6QTpBOkE6QTpBOUE5QTlBOUE5QTlBOUE5QTlBOUE7QTtBO0E7QTtBO0E7QTtBO0E7QTXCa4TXCe4TnCd4DrBdYLrBNcJrhOME4wTjBOME4wTjBOME4wTjBOME6wTrBOsE6wTrBOsE6wTrBOsE6wTPCd4TvCc4DnBc4LnBM8JnhM8J7CJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJxyYem3hs4rGJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIllE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1idcmXpt4beK1iWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hs4rOJzyY+m/hsoo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l98EJbKKO5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7lf//HByewiTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNj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saSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSyp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61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW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7s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7r7rzuzuvu/OdY/nsoH9qH68P4wN/Cek9c74nrPXG9J673xPWeuN4T13viek9c74nrPXG9J673xPWeuH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH6euH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7vvH7v/Pze+fm98/N75+f3zs/vnZ/fOz+/d35+7/z83vn5vfPze+fn987P752f3zs/v3d+fu/8/N75+b3z83vn579PfP77xOe/T3z++8Tnv098/vvE579PfP77xOe/T3zuzs/d+bk7P3fn5+783J2fu/Nzd37uzs/d+bk7P3fn5+783J2fu/Nzd37uzs/d+bk7P3fn5+783J2fu/Nzd37uzs/d+bk7/zmW/x6coJ2gnaCd4DqBu/Nzd37uzs/d+bk7P3fn5+783J2fu/Nzd37uzs/d+bk7P3fn5+783J2fu/Nzd37uzs/d+bk7P3fn5+783J2fu/Nzd37uzs/d+bk7P3fn5+783J2fu/Nzd37uzs/dWcdydSz3sTvPD7vz6Fjmh915ftidR8cyP+zO88PuPDqW+WF3nh9259GxzA+78/ywO4+OZX7YneeH3Xl0LPPD7jw/7M6jY5kfduf5YXceHcv8sDvPD7vz6Fjmh915ftidR8cyP+EppKeQnkJ6CukppKeQnkJ6CukppKeQnkJ5CuUplKdQnkJ5CuUplKdQnkJ5CuUptKfQnkJ7Cu0ptKfQnkJ7Cu0ptKfQnsL1FK6ncD2F6ylcT+F6CtdTuJ7C9RSupzCewngK4ymMpzCewngK4ymMpzCewngK6ymwO88Pu/P8sDvPD7vz/LA7zw+78/ywO88Pu/P8sDvPD7vz/DwneE7wnOA5wXOC5wTPCZ4TsDvPYXeew+48h915DrvzHHbnOezOc9id57A7z59j+e/BCY4THCc4TnCcgN15DrvzHHbnOezOc9id57A7z2F3nsPuPIfdeQ678xx25znsznPYneewO89hd/594G/hsDvPYXeew+48h915DrvzHHbnOezOc9id57A7z2F3nsPuPIfdeQ678xx25znlKZSnUJ5CeQrlKZSn0J5CewrtKbSn0J5CewrtKbSn0J5CewrXU7iewvUUrqdwPYXrKVxP4XoK11O4nsJ4CuMpjKcwnsJ4CuMpjKcwnsJ4CuMprKewnsJ6CusprKewnsJ6CusprKewnsLzFJ6n8DyF5yk8T+F5Cs9TeJ7C8xTYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSfYnSewfRPhKaSnkJ5CegrpKbA7T7A7T7A7T7A7T7A7T7A7T7A7T7A7T7A7T7A7T5QTlBOUE5QTlBOUE7QTtBO0E7QTtBO0E7QTtBO0E7QTXCe4TnCd4DrBdYLrBNcJrn8L17+F69/C+Lcw/i2Mfwvj38L4tzD+LYx/C+Pfwvi3MP4trH8L69/C+rew/i2sfwvr38L6t7D+Lax/C+vfwvNv4fm38PxbeP4tPIv0LNKzSM9TeJ6Cu3O6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O6e7c7o761hGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsUy6O6e7c7o7p7tzujunu3O6O6e7c7o7p7tzujunu3O6O5e7c7k7l7tzuTuXu3O5O5e7c7k7l7tzuTuXu3O5O5e7c7k7/zmW/x6c4DjBcYLjBMcJ3J11LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjmXJ3Lnfncncud+dydy5353J3Lnfncncud+dydy5353J3Lnfncncud+dydy5353J3Lnfncncud+dydy5353J3Lnfncncud+dyd25353Z3bnfndndud+d2d25353Z3bnfndndud+d2d25353Z3bnfndndud+d2d25353Z3bnfndndud+d2d25353Z3bnfndndud+d2d25353Z3bnfndnfu9BTSU0hPIT2F9BTSU3B3bnfndndud+d2d25353Z3bnfndndud+d2d25353Z3bnfndndud+d2d25353Z3bnfndndud+d2d25353Z3bnfndnfu6wTXCa4TjBOME4wTuDu3u3O7O7e7c7s7t7tzuzu3u3O7O7e7c7s7t7tzuzu3u3O7O7e7c7s7t7tzuzu3u3O7O7e7c7s7t7tzuzu3u3O7O1935+vufN2dr7vzdXe+7s7X3fm6O1935+vufN2dr7vzdXe+7s7X3fm6O1935+vufN2dr7vzdXe+7s7X3fn/mjqjXUma3Di/i67nopJkJkm/iiEIkiwbAhaSsJYMGMa+u89pRlZ/NwJi5/zdnPN1hTqqMoaH2fkwOx9m58PsfJidD7PzYXY+zM6H2fkwOx9m58PsfJidD7PzYXY+zM6H2fkwOx9m58PsfJidD7PzYXY+zM6H2fkwOx9m58PsfJidD7PzYXY+zM6H2fkwOx9m58PsfJidD7PzYXY+zM6H2fkwOx9m58PsfJidD7PzYXY+zM6H2fkwOx9m58PsfJidD7PzYXY+zM6H2fkwOx9m58PsfJidD7PzYXY+zM6nSKFIoUihSaFJoUmB2fkwOx9m58PsfJidD7PzYXZOZudkdk5m52R2TmbnZHZOZudkdk5m52R2TmbnZHZOZudkdk5m52R2TmbnZHZOZudkdk7jBMYJjBMYJzBOYJzAOAE9kT2WZI8l2WNJ9liSPZZkjyXZY0n2WJI9lmSPJdljSfZYkj2WZI8l2WNJ9liSPZZkjyXZY0n2WJI9lmSPJdljSfZYkj2WZI8l2WNJ9liSPZZkjyXZY0n2WJI9lmSPJdljSfZYkj2WZI8l2WNJ9liSPZZkjyXZY0n2WJI9lmSPJdljyaQnJj0x6YlJT0x6YtITk56Y9MSkJyY9MemJSU9MemLSE5Oe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S3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfSwWzczA7B7NzMDsHs3MwO29m583svJmduY+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+luI+lDrPzYXY+zM6H2fkwOx9m58PsfJidD7Mz97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EU97EUeyzFHkuxx1LssRR7LMUeS7HHUuyxFHssxR5LscdS7LEUeyzFHkuxx1LssRR7LMUeS7HHUuyxFHssxR5LscdS7LEUeyzFHkuxx1LssRR7LMUeS7HHUuyxFHssxR5LscdS7LEUeyzFHkuxx1LssRR7LMUeS7HHUuyxFHssdeiJh5546ImHnnjoiYeeeOiJSU9MemLSE5OemPTEpCcmPTHpiUlPTHpi0hOTnpj0xKQnJs4nVuJ8YiXOJ1bifGIlzidW4nxiJc4nVuJ8YiXOJ1bifGIlzidW4nxiJc4nVuJ8YiXOJ1YaKTgpOCk4KTgpOCnwLE7yLE7yLE7yLE7yLE7yLE7yfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmLyfmIyOyezczI7J7NzMjsns3MyO3MfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3EfS3Ef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YHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m583svJmdN7PzZnbezM6b2XkzO29m583svJmdN7PzZnbezM6b2XkzO29m583svJmdN7PzZnbezM6b2XkzO29m583svJmdN7PzZnbezM7bSMFJwUnBScFJwUmB2XkzO29m583svJmduY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+luY+l2WNp9liaPZZmj6XZY2n2WJo9lmaPpdljafZYmj2WZo+l2WNp9liaPZZmj6XZY2n2WJo9lmaPpdljafZYmj2WZo+l2WNp9liaPZZmj6XZY2n2WJo9lmaPpdljafZYmj2WZo+l2WNp9liaPZZmj6XZY2n2WJo9lmaPpdlj6UNPPPTEQ0889MRDTzz0xENPPPTEQ0889MRDTzz0xENPPPTEQ0889MRDTzz0xENPPPTEQ088TgpOCk4KTgpOCkEKQQpBCkEKQQpBCkEKQQpBCkEKmxQ2KWxS2KSwSWGTwiaFTQqbFDYpHFI4pMD7iYf3Ew/vJx7eTzy8n3h4P/HwfuLh/cTD+4mH9xMP7yce3k88vJ94eD/x8H7i4f3Ew/uJh/cTD+8nHt5PPLyfeHg/8fB+4uH9xMP7iYf3Ew/vJx5m58PsfJidD7Mz97E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E097E0eyzNHkuzx9LssTR7LM0eS7PH0uyxNHsszR5Ls8fS7LE0eyzNHkuzx9LssTR7LM0eS7PH0uyxNHsszR5Ls8fS7LE0eyzNHkuzx9LssTR7LM0eS7PH0uyxNHsszR5Ls8fS7LE0eyzNHkuzx9LssTR7LM0eS7PH0uyxNHssnfTEpCcmPTHpiUlPTHpi0hOTnpj0xKQnJj0x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gKfHIqbTY3kF8oJ6LFcgL6jHcgXygnosVyAvqMdyBfKCeixX4B5K0RPLSYGeWPTECtxDqcA9lArcQ6nAPZQKUqAnqsciCvTEClKgJ9bGPZTauIdSG/dQauMeSm1SoCfWJgV6Ym1SoCdOj+VSoCfWIQV6onosokBPVI9lrjn1WCL/9ufv/s8//vVf//Gf/vIv//vv/tv/+5H/87/+7Z//81///d8k//P//sf9k3/667/+5S//+r/+4T/++u///C//47/++i//8Jd//+ffP/u7R//nvy/7+a0sc/v7P3/nv/rZ9Wc9p370+vzA6v3zA8/z+z+sz3/xxO//cP7+5x3WfR2L8+fnqbleZT9/znNfwTz+mPf97y38j8X+/a/tneLnBsCfn89L3Sn8Z4j4zvBzt+Hnj2eozwy/H63fj9Tvq/h3hrX//K4t16v8PJL88/NQ8J3j52HFn98F8Jjk8/P5+ypxX+W31fnnt+P4/kby9zdS7+v89pT//HaN7+v8npn983s89vd19n2d+vktPa4XOfEn477Ajz3W++us9af89z88v//h78/as/7YTPn5y//8/n9//T8/kvdHfj62f34+OPdHetuf3nlfstP/dH5+w/X7X+hv/8f693/q7/+Uf364/+1vf/v7v/1/","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use jwt::JWT;\nuse std::hash::pedersen_hash;\n\n// Max length of the signed JWT data (header.payload in base64)\nglobal MAX_DATA_LENGTH: u32 = 1024;\n// Max email length (e.g., \"alice@example.com\")\nglobal MAX_EMAIL_LENGTH: u32 = 64;\n// Merkle tree depth (supports 2^20 = 1M users)\nglobal TREE_DEPTH: u32 = 20;\n\n/// Compute Pedersen hash of email bytes (1 byte = 1 Field)\nfn hash_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> Field {\n    let storage = email.storage();\n    let mut fields: [Field; MAX_EMAIL_LENGTH] = [0; MAX_EMAIL_LENGTH];\n    for i in 0..MAX_EMAIL_LENGTH {\n        fields[i] = storage[i] as Field;\n    }\n    pedersen_hash(fields)\n}\n\n/// Compute leaf hash: pedersen(email_hash, amount, salt)\nfn compute_leaf(email_hash: Field, amount: Field, salt: Field) -> Field {\n    pedersen_hash([email_hash, amount, salt])\n}\n\n/// Verify Merkle proof and return computed root\nfn verify_merkle_proof(\n    leaf: Field,\n    siblings: [Field; TREE_DEPTH],\n    path_indices: [Field; TREE_DEPTH],\n) -> Field {\n    let mut current = leaf;\n    for i in 0..TREE_DEPTH {\n        let sibling = siblings[i];\n        let is_right = path_indices[i];\n        // If is_right == 1, current is on right, so hash(sibling, current)\n        // If is_right == 0, current is on left, so hash(current, sibling)\n        let left = if is_right == 1 { sibling } else { current };\n        let right = if is_right == 1 { current } else { sibling };\n        current = pedersen_hash([left, right]);\n    }\n    current\n}\n\nfn main(\n    // Private inputs - JWT data\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    expected_email: BoundedVec<u8, MAX_EMAIL_LENGTH>,\n    // Private inputs - Merkle proof\n    salt: Field,\n    amount: Field,\n    merkle_siblings: [Field; TREE_DEPTH],\n    merkle_path_indices: [Field; TREE_DEPTH],\n    // Private input - recipient (returned as public output)\n    recipient: Field,\n    // Public inputs\n    pubkey_modulus_limbs: pub [u128; 18],\n    merkle_root: pub Field,\n) -> pub (Field, Field) {\n    // 1. Initialize and verify the JWT\n    let jwt: JWT<MAX_DATA_LENGTH> = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n    jwt.verify();\n\n    // 2. Verify the email claim in JWT matches private expected_email\n    jwt.assert_claim_string(\"email\".as_bytes(), expected_email);\n\n    // 3. Compute email hash (public commitment)\n    let email_hash = hash_email(expected_email);\n\n    // 4. Compute leaf from email_hash, amount, salt\n    let leaf = compute_leaf(email_hash, amount, salt);\n\n    // 5. Verify Merkle proof - computed root must match public merkle_root\n    let computed_root = verify_merkle_proof(leaf, merkle_siblings, merkle_path_indices);\n    assert(computed_root == merkle_root, \"Merkle proof verification failed\");\n\n    // 6. Return email hash and recipient as public outputs\n    // Both values are cryptographically bound to the proof\n    // Contract verifies msg.sender == recipient to prevent front-running\n    (email_hash, recipient)\n}\n\n#[test]\nfn test_hash_email() {\n    // Test with a simple email\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"test@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    let hash = hash_email(email);\n    // Just check it doesn't panic\n    assert(hash != 0);\n}\n","path":"/Users/yaman/dev/zarf/zarf/circuits/src/main.nr"},"52":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/yaman/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/lib.nr"},"55":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"56":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"95":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"98":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"99":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"102":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"110":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"139":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr"},"142":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/yaman/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"158":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"159":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"}},"expression_width":{"Bounded":{"width":4}}}