{"noir_version":"1.0.0-beta.17+0d6984c7c643b690e6559351f0cb36ce62b44b26","hash":"7361376552833830448","abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":1024,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"expected_email","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_path_indices","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2707472466662157409":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"6587586420081008171":{"error_kind":"string","string":"Merkle proof verification failed"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"8784292831194001448":{"error_kind":"string","string":"data length is too long"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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do0m6BrjYdcYy64xBF1jPewaa9k1lqBrnIdd4yy7xhF0jfewa7xl13iCrgkedk2w7JpA0DXRw66Jll0TCbomedg1ybJrEkHXZA+7Jlt2TSbomuJh1xTLrikEXVM97Jpq2TWVoGuah13TLLumEXRN97BrumXXdIKuGR52zbDsmkHQNdPDrpmWXTMJumZ52DXLsmsWQddsD7tmW3bNJuia42HXHMuuOQRdcz3smmvZNZega56HXfMsu+YRdM33sGu+Zdd8gq4FHnYtsOxaQNC10MOuhZZdCwm6FnnYtciyaxFB12IPuxZbdi0m6FriYdcSy64lBF1LPexaatm1lKBrmYddyyy7lhF0Lfewa7ll13KCrhUedq2w7FpB0LXSw66Vll0rCbpWedi1yrJrFUHXag+7Vlt2rSboWuNh1xrLrjUEXWs97Fpr2bWWoGudh13rLLvWEXSt97BrvWXXeoKuDR52bbDs2kDQtdHDro2WXRsJujZ52LXJsmsTQddmD7s2W3ZtJuja4mHXFsuuLQRdWz3s2mrZtZWga5uHXdssu7YRdG33sGu7Zdd2gq4dHnbtsOzaQdC108OunZZdOwm6dnnYtcuyaxdB124Pu3Zbdu0m6NrjYdcey649BF17Pezaa9m1l6Brn4dd+yy79hF07fewa79l136CrgMedh2w7DpA0HXQw66Dll0HCboOedh1yLLrEEHXYQ+7Dlt2HSboOuJh1xHLriMEXUc97Dpq2XWUoOuYh13HLLuOEXQd97DruGXXcYKuEx52nbDsOkHQddLDrpOWXScJuk552HXKsusUQddpD7tOW3adJug642HXGcuuMwRdZz3sOmvZdZag65yHXecsu84RdJ33sOu8Zdd5gq4LHnZdsOy6QNB10cOui5ZdFwm6LnnYdcmy6xJB12UPuy5bdl0m6LriYdcVy64rBF1XPey6atl1laDrmodd1yy7rhF0Xfew67pl13WCrhsedt2w7LpB0HXTw66bll03Cbpuedh1y7LrFkHXbQ+7blt23SbouuNh1x3LrjsEXXc97Lpr2XWXoOueh133LLvuEXTd97DrvmXXfYKuBx52PbDsekDQ9dDDroeWXQ8Juh552PXIsusRQddjD7seW3Y9Juh64mHXE8uuJwRdTz3semrZ9ZSg65mHXc8su54RdD33sOu5Zddzgq4XHna9sOx6QdD1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yLJrEUHXYg+7Flt2LSboWuJh1xLLriUEXUs97Fpq2bWUoGuZh13LLLuWEXQt97BruWXXcoKuFR52rbDsWkHQtdLDrpWWXSsJulZ52LXKsmsVQddqD7tWW3atJuha42HXGsuuNQRdaz3sWmvZtZaga52HXessu9YRdK33sGu9Zdd6gq4NHnZtsOzaQNC10cOujZZdGwm6NnnYtcmyaxNB12YPuzZbdm0m6NriYdcWy64tBF1bPezaatm1laBrm4dd2yy7thF0bfewa7tl13aCrh0edu2w7NpB0LXTw66dll07Cbp2edi1y7JrF0HXbg+7dlt27Sbo2uNh1x7Lrj0EXXs97Npr2bWXoGufh137LLv2EXTt97Brv2XXfoKuAx52HbDsOkDQddDDroOWXQcJug552HXIsusQQddhD7sOW3YdJug64mHXEcuuIwRdRz3sOmrZdZSg65iHXccsu44RdB33sOu4Zddxgq4THnadsOw6QdB10sOuk5ZdJwm6TnnYdcqy6xRB12kPu05bdp0m6DrjYdcZy64zBF1nPew6a9l1lqDrnIdd5yy7zhF0nfew67xl13mCrgsedl2w7LpA0HXRw66Lll0XCbouedh1ybLrEkHXZQ+7Llt2XSbouuJh1xXLrisEXVc97Lpq2XWVoOuah13XLLuuEXRd97DrumXXdYKuGx523bDsukHQddPDrpuWXTcJum552HXLsusWQddtD7tuW3bdJui642HXHcuuOwRddz3sumvZdZeg656HXfcsu+4RdN33sOu+Zdd9gq4HHnY9sOx6QND10MOuh5ZdDwm6HnnY9ciy6xFB12MPux5bdj0m6HriYdcTy64nBF1PPex6atn1lKDrmYddzyy7nhF0Pfew67ll13OCrhcedr2w7HpB0PXSw66Xll0vCbpeedj1yrLrFUEX+8m/rlCTTVdohzP8x6YrzMOuMMuuMIKutzzsesuy6y2CrigedkWx7IpC0PW2h11vW3a9TdAV1cOuqJZdUQm6onnYFc2yKxpBV3QPu6JbdkUn6IrhYVcMy64YBF0xPeyKadkVk6DrHQ+73rHseoegK5aHXbEsu2IRdMX2sCu2ZVdsgq44HnbFseyKQ9AV18OuuJZdcQm64nnYFc+yKx5B17sedr1r2fUuQVd8D7viW3bFJ+hK4GFXAsuuBARdCT3sSmjZlZCgK5GH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XTstu3YSdO3ysGuXZdcugq7dHnbttuzaTdC1x8OuPZZdewi69nrYtdeyay9B1z4Pu/ZZdu0j6NrvYdd+y679BF0HPOw6YNl1gKDroIddBy27DhJ0HfKw65Bl1yGCrsMedh227DpM0HXEw64jll1HCLqOeth11LLrKEHXMQ+7jll2HSPoOu5h13HLruMEXSc87Dph2XWCoOukh10nLbtOEnSd8rDrlGXXKYKu0x52nbbsOk3QdcbDrjOWXWcIus562HXWsussQdc5D7vOWXadI+g672HXecuu8wRdFzzsumDZdYGg66KHXRctuy4SdF3ysOuSZdclgq7LHnZdtuy6TNB1xcOuK5ZdVwi6rnrYddWy6ypB1zUPu65Zdl0j6LruYdd1y67rBF03POy6Ydl1g6DrpoddNy27bhJ03fKw65Zl1y2Crtsedt227LpN0HXHw647ll13CLrueth117LrLkHXPQ+77ll23SPouu9h133LrvsEXQ887Hpg2fWAoOuhh10PLbseEnQ98rDrkWXXI4Kuxx52PbbsekzQ9cTDrieWXU8Iup562PXUsuspQdczD7ueWXY9I+h67mHXc8uu5wRdLzzsemHZ9YKg66WHXS8tu14SdL3ysOuVZdcrgi72s39doSabrtAOZ/iPTVeYh11hll1hBF1vedj1lmXXWwRdUTzsimLZFYWg620Pu9627HqboCuqh11RLbuiEnRF87ArmmVXNIKu6B52Rbfsik7QFcPDrhiWXTEIumJ62BXTsismQdc7Hna9Y9n1DkFXLA+7Yll2xSLoiu1hV2zLrtgEXXE87Ipj2RWHoCuuh11xLbviEnTF87ArnmVXPIKudz3setey612CrvgedsW37IpP0JXAw64Ell0JCLoSetiV0LIrIUFXIg+7Ell2JSLoSuxhV2LLrsQEXe952PWeZdd7BF1JPOxKYtmVhKArqYddSS27khJ0JfOwK5llVzKCruQediW37EpO0JXCw64Ull0pCLre97Drfcuu9wm6UnrYldKyKyVBVyoPu1JZdqUi6ErtYVdqy67UBF3cwy5u2cUJutJ42JXGsisNQVdaD7vSWnalJehK52FXOsuudARd6T3sSm/ZlZ6gK4OHXRksuzIQdGX0sCujZVdGgq5MHnZlsuzKRNCV2cOuzJZdmQm6snjYlcWyKwtBV1YPu7JadmUl6MrmYVc2y65sBF3ZPezKbtmVnaArh4ddOSy7chB05fSwK6dlV06CrlweduWy7MpF0JXbw67cll25CbryeNiVx7IrD0FXXg+78lp25SXoyudhVz7LrnwEXfk97Mpv2ZWfoKuAh10FLLsKEHQV9LCroGVXQYKuQh52FbLsKkTQVdjDrsKWXYUJuop42FXEsqsIQVdRD7uKWnYVJegq5mFXMcuuYgRdxT3sKm7ZVZygq4SHXSUsu0oQdJX0sKukZVdJgq5SHnaVsuwqRdBV2sOu0pZdpQm6ynjYVcayqwxBV1kPu8padpUl6CrnYVc5y65yBF3lPewqb9lVnqCrgoddFSy7KhB0VfSwq6JlV0WCrkoedlWy7KpE0FXZw67Kll2VCbqqeNhVxbKryv/D3tmAy1R1cXwGSZJukiTpJnGTJEmSNElIvgkJDfnON0mSbpIkSZIkIUmSJPlOkiQJSZIkSUISkiSJdy/30t377pm91vKedeY8z53n2c/t7H7b/u+xfteeOTPnCOSqmYC5ajJz1RTIdWcC5rqTmetOgVy1EjBXLWauWgK5aidgrtrMXLUFctVJwFx1mLnqCOSqm4C56jJz1RXIVS8Bc9Vj5qonkKt+Auaqz8xVXyBXgwTM1YCZq4FAroYJmKshM1dDgVyNEjBXI2auRgK57krAXHcxc90lkKtxAuZqzMzVWCBXkwTM1YSZq4lArqYJmKspM1dTgVx3J2Cuu5m57hbI1SwBczVj5momkOueBMx1DzPXPQK5midgrubMXM0FcrVIwFwtmLlaCORqmYC5WjJztRTIdW8C5rqXmetegVzRBMwVZeaKCuRqlYC5WjFztRLI1ToBc7Vm5motkOu+BMx1HzPXfQK52iRgrjbMXG0EcrVNwFxtmbnaCuRql4C52jFztRPI1T4Bc7Vn5movkKtDAubqwMzVQSBXxwTM1ZGZq6NArk4JmKsTM1cngVz3J2Cu+5m57hfI1TkBc3Vm5uoskKtLAubqwszVRSBX1wTM1ZWZq6tArm4JmKsbM1c3gVzdEzBXd2au7gK5eiRgrh7MXD0EcvVMwFw9mbl6CuTqlYC5ejFz9RLI1TsBc/Vm5uotkOuBBMz1ADPXAwK5+iRgrj7MXH0Ecj2YgLkeZOZ6UCBX3wTM1ZeZq69ArocSMNdDzFwPCeTql4C5+jFz9RPI9XAC5nqYmethgVz9EzBXf2au/gK5HknAXI8wcz0ikGtAAuYawMw1QCDXowmY61FmrkcFcqUmYK5UZq5UgVyPJWCux5i5HhPINTABcw1k5hookOvxBMz1ODPX4wK5BiVgrkHMXIMEcj2RgLmeYOZ6QiDX4ATMNZiZa7BAricTMNeTzFxPCuQakoC5hjBzDRHI9VQC5nqKmespgVxDEzDXUGauoQK5nk7AXE8zcz0tkGtYAuYaxsw1TCDXMwmY6xlmrmcEcg1PwFzDmbmGC+R6NgFzPcvM9axArhEJmGsEM9cIgVzPJWCu55i5nhPINTIBc41k5hopkOv5BMz1PDPX8wK5RiVgrlHMXKMEcr2QgLleYOZ6QSDX6ATMNZqZa7RArhcTMNeLzFwvCuQak4C5xjBzjRHI9VIC5nqJmeslgVxjEzDXWGausQK5Xk7AXC8zc70skGtcAuYax8w1TiDXKwmY6xVmrlcEco1PwFzjmbnGC+SakIC5JjBzTRDINTEBc01k5pookOvVBMz1KjPXqwK5JiVgrknMXJMEcr2WgLleY+Z6TSDX5ATMNZmZa7JArtcTMNfrzFyvC+SakoC5pjBzTRHI9UYC5nqDmesNgVxTEzDXVGauqQK53kzAXG8yc70pkGtaAuaaxsw1TSDXWwmY6y1mrrcEck1PwFzTmbmmC+R6OwFzvc3M9bZArhkJmGsGM9cMgVzvJGCud5i53hHINTMBc81k5popkOvdBMz1LjPXuwK5ZiVgrlnMXLMEcr2XgLneY+Z6TyDX7ATMNZuZa7ZArjkJmGsOM9ccgVxzEzDXXGauuQK55iVgrnnMXPMEcs1PwFzzmbnmC+RakIC5FjBzLRDItTABcy1k5lookOv9BMz1PjPX+wK5FiVgrkXMXIsEcn2QgLk+YOb6QCDX4gTMtZiZa7FArg8TMNeHzFwfCuRakoC5ljBzLRHI9VEC5vqImesjgVxLEzDXUmaupQK5Pk7AXB8zc30skGtZAuZaxsy1TCDXJwmY6xNmrk8Eci1PwFzLmbmWC+T6NAFzfcrM9alArhUJmGsFM9cKgVyfJWCuz5i5PhPItTIBc61k5lopkOvzBMz1OTPX5wK5ViVgrlXMXKsEcq1OwFyrmblWC+Rak4C51jBzrRHI9UUC5vqCmesLgVxrEzDXWmautQK5vkzAXF8yc30pkGtdAuZax8y1TiDXVwmY6ytmrq8Ecq1PwFzrmbnWC+T6OgFzfc3M9bVArg0JmGsDM9cGgVzfJGCub5i5vhHItTEBc21k5tookOvbBMz1LTPXtwK5NiVgrk3MXJsEcn2XgLm+Y+b6TiDX5gTMtZmZa7NAru8TMNf3zFzfC+TakoC5tjBzbRHI9UMC5vqBmesHgVxbEzDXVmaurQK5fkzAXD8yc/0okGtbAubaxsy1TSDXTwmY6ydmrp8Ecm1PwFzbmbm2C+T6OQFz/czM9bNArh0JmGsHM9cOgVw7EzDXTmaunQK5diVgrl3MXLsEcv2SgLl+Yeb6RSDX7gTMtZuZa7dArl8TMNevzFy/CuTak4C59jBz7RHI9VsC5vqNmes3gVx7EzDXXmauvQK59iVgrn3MXPsEcu1PwFz7mbn2C+T6PQFz/c7M9btArgMJmOsAM9cBgVx/JGCuP5i5/hDIdTABcx1k5jookOvPBMz1JzPXnwK5DiVgrkPMXIcEcv2VgLn+Yub6SyDX4QTMdZiZ67BArr8TMNffzFx/C+Q6koC5jjBzHRHI9U8C5vqHmesfgVxHEzDXUWauowK5/k3AXP8yc/0rkOtYAuY6xsx1TCDX8QTMdZyZ67hArlDHxMsFmTi5YExyCP/g5AonYK4wM1dYIFe2BMyVjZkrm0Cu7AmYKzszV3aBXDkSMFcOZq4cArnOSMBcZzBznSGQK2cC5srJzJVTINeZCZjrTGauMwVy5UrAXLmYuXIJ5DorAXOdxcx1lkCu3AmYKzczV26BXGcnYK6zmbnOFsiVJwFz5WHmyiOQ65wEzHUOM9c5ArnyJmCuvMxceQVynZuAuc5l5jpXIFdSAuZKYuZKEsh1XgLmOo+Z6zyBXPkSMFc+Zq58ArnOT8Bc5zNznS+QK38C5srPzJVfINcFCZjrAmauCwRyFUjAXAWYuQoI5LowAXNdyMx1oUCuggmYqyAzV0GBXBclYK6LmLkuEshVKAFzFWLmKiSQ6+IEzHUxM9fFArkKJ2CuwsxchQVyXZKAuS5h5rpEIFeRBMxVhJmriECuSxMw16XMXJcSc4Vy0P78S1roc7j45Lah0GVtcfy+48ePA1sUzx8D9nI8/y+wxfD8UWCvwPP/AFsczx8BtgSe/xvYFDx/GNgr8fxfwJbE84eAvQrP/wlsKTx/ENir8fwfwJbG8weAvQbP/w5sGTy/H9hr8fw+YMvi+b3AXofnfwO2HJ7fA+z1eP5XYMvj+d3A3oDnfwG2Ap7fBeyNeH4nsBXx/A5gb8LzPwNbCc9vB/ZmPP8TsJXx/DZgb8HzPwIbwfNbgb0Vz/8AbBU8vwXY2/D898BWxfObgb0dz38HbDU8vwnY6nj+W2Br4PmNwN6B578Btiae3wDsnXj+a2Br4fn1wNbG818BWwfPrwO2Lp7/Eth6eH4tsPXx/BfANsDza4BtiOdXA9sIz68C9i48/zmwjfH8SmCb4PnPgG2K51cAezee/xTYZnh+ObD34PlPgG2O55cB2wLPfwxsSzy/FNh78fxHwEbx/BJgW+H5D4FtjecXA3sfnv8A2DZ4fhGwbfH8+8C2w/MLgW2P5xcA2wHPzwe2I56fB2wnPD8X2Pvx/BxgO+P52cB2wfPvAdsVz88CthuefxfY7nh+JrA98Pw7wPbE8zOA7YXn3wa2N56fDuwDeP4tYPvg+WnAPojn3wS2L56fCuxDeP4NYPvh+SnAPoznXwe2P56fDOwjeP41YAfg+UnAPornXwU2Fc9PBPYxPD8B2IF4fjywj+P5V4AdhOfHAfsEnn8Z2MF4fiywT+L5l4AdgufHAPsUnn8R2KF4fjSwT+P5F4AdhudHAfsMnn8e2OF4fiSwz+L554AdgedHAPscnn8W2JF4fjiwz+P5Z4AdheeHAfsCnn8a2NF4fiiwL+L5p4Adg+eHAPsSnn8S2LF4fjCwL+P5J4Adh+cHAfsKnn8c2PF4fiCwE/D8Y8BOxPOpwL6K5x8FdhKeHwDsa3j+EWAn4/n+wL6O5x8Gdgqe7wfsG3j+IWCn4vm+wL6J5x8Edhqe7wPsW3j+AWCn4/newL6N53sBOwPP9wT2HTzfA9iZeL47sO/i+W7AzsLzXYF9D893AXY2nu8M7Bw8fz+wc/F8J2Dn4fmOwM7H8x2AXYDn2wO7EM+3A/Z9PN8W2EV4vg2wH+D5+4BdjOdbA/shnm8F7BI8HwX2Izx/L7BL8XxLYD/G8y2AXYbnmwP7CZ6/B9jleL4ZsJ/i+buBXYHnmwL7GZ5vAuxKPN8Y2M/x/F3ArsLzjYBdjecbArsGzzcA9gs8Xx/YtXi+HrBf4vm6wK7D83WA/QrP1wZ2PZ6vBezXeP5OYDfg+ZrAfoPn7wB2I56vAey3eL46sJvwfDVgv8PztwO7Gc9XBfZ7PH8bsFvwfBVgf8DztwK7Fc9HgP0Rz98C7DY8XxnYn/D8zcBux/OVgP0Zz98E7A48XxHYnXj+RmB34fkKwP6C528AdjeeLw/sr3j+emD34PlywP6G568Ddi+eLwvsPjx/LbD78XwZYH/H89cAewDPlwb2Dzx/NbAH8XwpYP/E81cBewjPlwT2Lzx/JbCH8XwKsH/j+RLAHsHzxYH9B89fAexRPF8M2H/x/OXAHsPzRYE9jucvAzbUDs0nAxvG85cCmw3PFwE2O56/BNgceL4wsGfg+YuBzYnnCwF7Jp6/CNhceL4gsGfh+QuBzY3nCwB7Np6/ANg8eD4/sOfg+fOBzYvn8wF7Lp4/D9gkPJ8E7Hl4/lxg8+H5vMCej+fPATY/ns8D7AV4/mxgC+D53MBeiOfPArYgns8F7EV4/kxgC+H5nMBejOfPALYwns8B7CV4PjuwRfB8NmAvxfPhEyyeP8FehuaPHQe2KJ4/BuzleP5fYIvh+aPAXoHn/wG2OJ4/AmwJPP83sCl4/jCwV+L5v4AtiecPAXsVnv8T2FJ4/iCwV+P5P4AtjecPAHsNnv8d2DJ4fj+w1+L5fcCWxfN7gb0Oz/8GbDk8vwfY6/H8r8CWx/O7gb0Bz/8CbAU8vwvYG/H8TmAr4vkdwN6E538GthKe3w7szXj+J2Ar4/ltwN6C538ENoLntwJ7K57/AdgqeH4LsLfh+e+BrYrnNwN7O57/DthqeH4TsNXx/LfA1sDzG4G9A89/A2xNPL8B2Dvx/NfA1sLz64Gtjee/ArYOnl8HbF08/yWw9fD8WmDr4/kvgG2A59cA2xDPrwa2EZ5fBexdeP5zYBvj+ZXANsHznwHbFM+vAPZuPP8psM3w/HJg78HznwDbHM8vA7YFnv8Y2JZ4fimw9+L5j4CN4vklwLbC8x8C2xrPLwb2Pjz/AbBt8PwiYNvi+feBbYfnFwLbHs8vALYDnp8PbEc8Pw/YTnh+LrD34/k5wHbG87OB7YLn3wO2K56fBWw3PP8usN3x/Exge+D5d4DtiednANsLz78NbG88Px3YB/D8W8D2wfPTgH0Qz78JbF88PxXYh/D8G8D2w/NTgH0Yz78ObH88PxnYR/D8a8AOwPOTgH0Uz78KbCqenwjsY3h+ArAD8fx4YB/H868AOwjPjwP2CTz/MrCD8fxYYJ/E8y8BOwTPjwH2KTz/IrBD8fxoYJ/G8y8AOwzPjwL2GTz/PLDD8fxIYJ/F888BOwLPjwD2OTz/LLAj8fxwYJ/H888AOwrPDwP2BTz/NLCj8fxQYF/E808BOwbPDwH2JTz/JLBj8fxgYF/G808AOw7PDwL2FTz/OLDj8fxAYCfg+ceAnYjnU4F9Fc8/CuwkPD8A2Nfw/CPATsbz/YF9Hc8/DOwUPN8P2Dfw/EPATsXzfYF9E88/COw0PN8H2Lfw/APATsfzvYF9G8/3AnYGnu8J7Dt4vgewM/F8d2DfxfPdgJ2F57sC+x6e7wLsbDzfGdg5eP5+YOfi+U7AzsPzHYGdj+c7ALsAz7cHdiGebwfs+3i+LbCL8HwbYD/A8/cBuxjPtwb2QzzfCtgleD4K7Ed4/l5gl+L5lsB+jOdbALsMzzcH9hM8fw+wy/F8M2A/xfN3A7sCzzcF9jM83wTYlXi+MbCf4/m7gF2F5xsBuxrPNwR2DZ5vAOwXeL4+sGvxfD1gv8TzdYFdh+frAPsVnq8N7Ho8XwvYr/H8ncBuwPM1gf0Gz98B7EY8XwPYb/F8dWA34flqwH6H528HdjOerwrs93j+NmC34PkqwP6A528FdiuejwD7I56/BdhteL4ysD/h+ZuB3Y7nKwH7M56/CdgdeL4isDvx/I3A7sLzFYD9Bc/fAOxuPF8e2F/x/PXA7sHz5YD9Dc9fB+xePF8W2H14/lpg9+P5MsD+juevAfYAni8N7B94/mpgD+L5UsD+ieevAvYQni8J7F94/kpgD+P5FGD/xvMlgD2C54sD+w+evwLYo3i+GLD/4vnLgT2G54sCexzPXwZsqD2aTwY2jOcvBTYbni8CbHY8fwmwOfB8YWDPwPMXA5sTzxcC9kw8fxGwufB8QWDPwvMXApsbzxcA9mw8fwGwefB8fmDPwfPnA5sXz+cD9lw8fx6wSXg+Cdjz8Py5wObD83mBPR/PnwNsfjyfB9gL8PzZwBbA87mBvRDPnwVsQTyfC9iL8PyZwBbC8zmBvRjPnwFsYTyfA9hL8Hx2YIvg+WzAXornwydYPH+CvQzN/3sc2KJ4/hiwl+P5f4EthuePAnsFnv8H2OJ4/giwJfD838Cm4PnDwF6J5/8CtiSePwTsVXj+T2BL4fmDwF6N5/8AtjSePwDsNXj+d2DL4Pn9wF6L5/cBWxbP7wX2Ojz/G7Dl8PweYK/H878CWx7P7wb2Bjz/C7AV8PwuYG/E8zuBrYjndwB7E57/GdhKeH47sDfj+Z+ArYzntwF7C57/EdgInt8K7K14/gdgq+D5LcDehue/B7Yqnt8M7O14/jtgq+H5TcBWx/PfAlsDz28E9g48/w2wNfH8BmDvxPNfA1sLz68Htjae/wrYOnh+HbB18fyXwNbD82uBrY/nvwC2AZ5fA2xDPL8a2EZ4fhWwd+H5z4FtjOdXAtsEz38GbFM8vwLYu/H8p8A2w/PLgb0Hz38CbHM8vwzYFnj+Y2Bb4vmlwN6L5z8CNornlwDbCs9/CGxrPL8Y2Pvw/AfAtsHzi4Bti+ffB7Ydnl8IbHs8vwDYDnh+PrAd8fw8YDvh+bnA3o/n5wDbGc/PBrYLnn8P2K54fhaw3fD8u8B2x/Mzge2B598BtieenwFsLzz/NrC98fx0YB/A828B2wfPTwP2QTz/JrB98fxUYB/C828A2w/PTwH2YTz/OrD98fxkYB/B868BOwDPTwL2UTz/KrCpeH4isI/h+QnADsTz44F9HM+/AuwgPD8O2Cfw/MvADsbzY4F9Es+/BOwQPD8G2Kfw/IvADsXzo4F9Gs+/AOwwPD8K2Gfw/PPADsfzI4F9Fs8/B+wIPD8C2Ofw/LPAjsTzw4F9Hs8/A+woPD8M2Bfw/NPAjsbzQ4F9Ec8/BewYPD8E2Jfw/JPAjsXzg4F9Gc8/Aew4PD8I2Ffw/OPAjsfzA4GdgOcfA3Yink8F9lU8/yiwk/D8AGBfw/OPADsZz/cH9nU8/zCwU/B8P2DfwPMPATsVz/cF9k08/yCw0/B8H2DfwvMPADsdz/cG9m083wvYGXi+J7Dv4PkewM7E892BfRfPdwN2Fp7vCux7eL4LsLPxfGdg5+D5+4Gdi+c7ATsPz3cEdj6e7wDsAjzfHtiFeL4dsO/j+bbALsLzbYD9AM/fB+xiPN8a2A/xfCtgl+D5KLAf4fl7gV2K51sC+zGebwHsMjzfHNhP8Pw9wC7H882A/RTP3w3sCjzfFNjP8HwTYFfi+cbAfo7n7wJ2FZ5vBOxqPN8Q2DV4vgGwX+D5+sCuxfP1gP0Sz9cFdh2erwPsV3i+NrDr8XwtYL/G83cCuwHP1wT2Gzx/B7Ab8XwNYL/F89WB3YTnqwH7HZ6/HdjNeL4qsN/j+duA3YLnqwD7A56/FditeD4C7I94/hZgt+H5ysD+hOdvBnY7nq8E7M94/iZgd+D5isDuxPM3ArsLz1cA9hc8fwOwu/F8eWB/xfPXA7sHz5cD9jc8fx2we/F8WWD34flrgd2P58sA+zuevwbYA3i+NLB/4PmrgT2I50sB+yeevwrYQ3i+JLB/4fkrgT2M51OA/RvPlwD2CJ4vDuw/eP4KYI/i+WLA/ovnLwf2GJ4vCuxxPH8ZsKEOaD4Z2DCevxTYbHi+CLDZ8fwlwObA84WBPQPPXwxsTjxfCNgz8fxFwObC8wWBPQvPXwhsbjxfANiz8fwFwObB8/mBPQfPnw9sXjyfD9hz8fx5wCbh+SRgz8Pz5wKbD8/nBfZ8PH8OsPnxfB5gL8DzZwNbAM/nBvZCPH8WsAXxfC5gL8LzZwJbCM/nBPZiPH8GsIXxfA5gL8Hz2YEtguezAXspng+fYPH8CfYyNH/0OLBF8fwxYC/H8/8CWwzPHwX2Cjz/D7DF8fwRYEvg+b+BTcHzh4G9Es//BWxJPH8I2Kvw/J/AlsLzB4G9Gs//AWxpPH8A2Gvw/O/AlsHz+4G9Fs/vA7Ysnt8L7HV4/jdgy+H5PcBej+d/BbY8nt8N7A14/hdgK+D5XcDeiOd3AlsRz+8A9iY8/zOwlfD8dmBvxvM/AVsZz28D9hY8/yOwETy/Fdhb8fwPwFbB81uAvQ3Pfw9sVTy/Gdjb8fx3wFbD85uArY7nvwW2Bp7fCOwdeP4bYGvi+Q3A3onnvwa2Fp5fD2xtPP8VsHXw/Dpg6+L5L4Gth+fXAlsfz38BbAM8vwbYhnh+NbCN8PwqYO/C858D2xjPrwS2CZ7/DNimeH4FsHfj+U+BbYbnlwN7D57/BNjmeH4ZsC3w/MfAtsTzS4G9F89/BGwUzy8BthWe/xDY1nh+MbD34fkPgG2D5xcB2xbPvw9sOzy/ENj2eH4BsB3w/HxgO+L5ecB2wvNzgb0fz88BtjOenw1sFzz/HrBd8fwsYLvh+XeB7Y7nZwLbA8+/A2xPPD8D2F54/m1ge+P56cA+gOffArYPnp8G7IN4/k1g++L5qcA+hOffALYfnp8C7MN4/nVg++P5ycA+gudfA3YAnp8E7KN4/lVgU/H8RGAfw/MTgB2I58cD+ziefwXYQXh+HLBP4PmXgR2M58cC+ySefwnYIXh+DLBP4fkXgR2K50cD+zSefwHYYXh+FLDP4PnngR2O50cC+yyefw7YEXh+BLDP4flngR2J54cD+zyefwbYUXh+GLAv4PmngR2N54cC+yKefwrYMXh+CLAv4fkngR2L5wcD+zKefwLYcXh+ELCv4PnHgR2P5wcCOwHPPwbsRDyfCuyreP5RYCfh+QHAvobnHwF2Mp7vD+zreP5hYKfg+X7AvoHnHwJ2Kp7vC+ybeP5BYKfh+T7AvoXnHwB2Op7vDezbeL4XsDPwfE9g38HzPYCdiee7A/sunu8G7Cw83xXY9/B8F2Bn4/nOwM7B8/cDOxfPdwJ2Hp7vCOx8PN8B2AV4vj2wC/F8O2Dfx/NtgV2E59sA+wGevw/YxXi+NbAf4vlWwC7B81FgP8Lz9wK7FM+3BPZjPN8C2GV4vjmwn+D5e4BdjuebAfspnr8b2BV4vimwn+H5JsCuxPONgf0cz98F7Co83wjY1Xi+IbBr8HwDYL/A8/WBXYvn6wH7JZ6vC+w6PF8H2K/wfG1g1+P5WsB+jefvBHYDnq8J7Dd4/g5gN+L5GsB+i+erA7sJz1cD9js8fzuwm/F8VWC/x/O3AbsFz1cB9gc8fyuwW/F8BNgf8fwtwG7D85WB/QnP3wzsdjxfCdif8fxNwO7A8xWB3YnnbwR2F56vAOwveP4GYHfj+fLA/ornrwd2D54vB+xveP46YPfi+bLA7sPz1wK7H8+XAfZ3PH8NsAfwfGlg/8DzVwN7EM+XAvZPPH8VsIfwfElg/8LzVwJ7GM+nAPs3ni8B7BE8XxzYf/D8FcAexfPFgP0Xz18O7DE8XxTY43j+MmBDHdF8MrBhPH8psNnwfBFgs+P5S4DNgecLA3sGnr8Y2Jx4vhCwZ+L5i4DNhecLAnsWnr8Q2Nx4vgCwZ+P5C4DNg+fzA3sOnj8f2Lx4Ph+w5+L584BNwvNJwJ6H588FNh+ezwvs+Xj+HGDz4/k8wF6A588GtgCezw3shXj+LGAL4vlcwF6E588EthCezwnsxXj+DGAL4/kcwF6C57MDWwTPZwP2UtWOZ0/jT45zPMKXtUWz2Yri2eyX49kcxfDsGVfg2ZzF8eyZJfBsrhQ8e9aVeDZ3STx79lV4Nk8pPHvO1Xg2b2k8e+41eDapDJ4971o8m68snj3/OjybvxyeveB6PFugPJ698AY8W7ACnr3oRjxbqCKevfgmPFu4Ep695GY8W6Qynr30FjybHMGzl92KZ4tWwbOX34Zni1XFs1fcjmeLV8OzJarj2ZQaePbKO/BsyZp49qo78WypWnj26tp4tnQdPHtNXTxbph6evbY+ni3bAM9e1xDPlmuEZ6+/C8+Wb4xnb2iCZys0xbM33o1nKzbDszfdg2crNcezN7fAs5Vb4tlb7sWzkSievbUVnq3SGs/edh+erdoGz97eFs9Wa4dnq7fHszU64Nk7OuLZmp3w7J3349lanfFs7S54tk5XPFu3G56t1x3P1u+BZxv0xLMNe+HZRr3x7F0P4NnGffBskwfxbNO+ePbuh/Bss3549p6H8Wzz/ni2xSN4tuUAPHvvo3g2mopnWz2GZ1sPxLP3PY5n2wzCs22fwLPtBuPZ9k/i2Q5D8GzHp/Bsp6F49v6n8WznYXi2yzN4tutwPNvtWTzbfQSe7fEcnu05Es/2eh7P9h6FZx94Ac/2GY1nH3wRz/Ydg2cfegnP9huLZx9+Gc/2H4dnH3kFzw4Yj2cfnYBnUyfi2cdexbMDJ+HZx1/Ds4Mm49knXsezg6fg2SffwLNDpuLZp97Es0On4dmn38Kzw6bj2WfexrPDZ+DZZ9/BsyNm4tnn3sWzI2fh2effw7OjZuPZF+bg2dFz8eyL8/DsmPl49qUFeHbsQjz78vt4dtwiPPvKB3h2/GI8O+FDPDtxCZ599SM8O2kpnn3tYzw7eRmeff0TPDtlOZ5941M8O3UFnn3zMzw7bSWefetzPDt9FZ59ezWenbEGz77zBZ6duRbPvvslnp21Ds++9xWenb0ez875Gs/O3YBn532DZ+dvxLMLvsWzCzfh2fe/w7OLNuPZD77Hs4u34NkPf8CzS7bi2Y9+xLNLt+HZj3/Cs8u249lPfsazy3fg2U934tkVu/DsZ7/g2ZW78eznv+LZVXvw7Orf8OyavXj2i314du1+PPvl73h23QE8+9UfeHb9QTz79Z94dsMhPPvNX3h242E8++3feHbTETz73T94dvNRPPv9v3h2yzE8+8NxPLs11A7N/hjGs9uy4dmfsuPZ7Tnw7M9n4NkdOfHszjPx7K5cePaXs/Ds7tx49tez8eyePHj2t3Pw7N68eHbfuXh2fxKe/f08PHsgH57943w8ezA/nv3zAjx7qACe/etCPHu4IJ79+yI8e6QQnv3nYjx7tDCe/fcSPHusCJ49fimaDYeS8Wz4MjybrSiezX45ns1RDM+ecQWezVkcz55ZAs/mSsGzZ12JZ3OXxLNnX4Vn85TCs+dcjWfzlsaz516DZ5PK4NnzrsWz+cri2fOvw7P5y+HZC67HswXK49kLb8CzBSvg2YtuxLOFKuLZi2/Cs4Ur4dlLbsazRSrj2UtvwbPJETx72a14tmgVPHv5bXi2WFU8e8XteLZ4NTxbojqeTamBZ6+8A8+WrIlnr7oTz5aqhWevro1nS9fBs9fUxbNl6uHZa+vj2bIN8Ox1DfFsuUZ49vq78Gz5xnj2hiZ4tkJTPHvj3Xi2YjM8e9M9eLZSczx7cws8W7klnr3lXjwbieLZW1vh2Sqt8ext9+HZqm3w7O1t8Wy1dni2ens8W6MDnr2jI56t2QnP3nk/nq3VGc/W7oJn63TFs3W74dl63fFs/R54tkFPPNuwF55t1BvP3vUAnm3cB882eRDPNu2LZ+9+CM8264dn73kYzzbvj2dbPIJnWw7As/c+imejqXi21WN4tvVAPHvf43i2zSA82/YJPNtuMJ5t/ySe7TAEz3Z8Cs92Gopn738az3Yehme7PINnuw7Hs92exbPdR+DZHs/h2Z4j8Wyv5/Fs71F49oEX8Gyf0Xj2wRfxbN8xePahl/Bsv7F49uGX8Wz/cXj2kVfw7IDxePbRCXg2dSKefexVPDtwEp59/DU8O2gynn3idTw7eAqeffINPDtkKp596k08O3Qann36LTw7bDqefeZtPDt8Bp599h08O2Imnn3uXTw7chaeff49PDtqNp59YQ6eHT0Xz744D8+OmY9nX1qAZ8cuxLMvv49nxy3Cs698gGfHL8azEz7EsxOX4NlXP8Kzk5bi2dc+xrOTl+HZ1z/Bs1OW49k3PsWzU1fg2Tc/w7PTVuLZtz7Hs9NX4dm3V+PZGWvw7Dtf4NmZa/Hsu1/i2Vnr8Ox7X+HZ2evx7Jyv8ezcDXh23jd4dv5GPLvgWzy7cBOeff87PLtoM5794Hs8u3gLnv3wBzy7ZCue/ehHPLt0G579+Cc8u2w7nv3kZzy7fAee/XQnnl2xC89+9gueXbkbz37+K55dtQfPrv4Nz67Zi2e/2Idn1+7Hs1/+jmfXHcCzX/2BZ9cfxLNf/4lnNxzCs9/8hWc3Hsaz3/6NZzcdwbPf/YNnNx/Fs9//i2e3HMOzPxzHs1tD7dHsj2E8uy0bnv0pO57dngPP/nwGnt2RE8/uPBPP7sqFZ385C8/uzo1nfz0bz+7Jg2d/OwfP7s2LZ/edi2f3J+HZ38/Dswfy4dk/zsezB/Pj2T8vwLOHCuDZvy7Es4cL4tm/L8KzRwrh2X8uxrNHC+PZfy/Bs8eK4Nnjl6LZbKFkPBu+DM9mK4pns1+OZ3MUw7NnXIFncxbHs2eWwLO5UvDsWVfi2dwl8ezZV+HZPKXw7DlX49m8pfHsudfg2aQyePa8a/FsvrJ49vzr8Gz+cnj2guvxbIHyePbCG/BswQp49qIb8Wyhinj24pvwbOFKePaSm/Fskcp49tJb8GxyBM9ediueLVoFz15+G54tVhXPXnE7ni1eDc+WqI5nU2rg2SvvwLMla+LZq+7Es6Vq4dmra+PZ0nXw7DV18WyZenj22vp4tmwDPHtdQzxbrhGevf4uPFu+MZ69oQmerdAUz954N56t2AzP3nQPnq3UHM/e3ALPVm6JZ2+5F89Gonj21lZ4tkprPHvbfXi2ahs8e3tbPFutHZ6t3h7P1uiAZ+/oiGdrdsKzd96PZ2t1xrO1u+DZOl3xbN1ueLZedzxbvweebdATzzbshWcb9cazdz2AZxv3wbNNHsSzTfvi2bsfwrPN+uHZex7Gs83749kWj+DZlgPw7L2P4tloKp5t9RiebT0Qz973OJ5tMwjPtn0Cz7YbjGfbP4lnOwzBsx2fwrOdhuLZ+5/Gs52H4dkuz+DZrsPxbLdn8Wz3EXi2x3N4tudIPNvreTzbexSefeAFPNtnNJ598EU823cMnn3oJTzbbyyeffhlPNt/HJ595BU8O2A8nn10Ap5NnYhnH3sVzw6chGcffw3PDpqMZ594Hc8OnoJnn3wDzw6ZimefehPPDp2GZ59+C88Om45nn3kbzw6fgWeffQfPjpiJZ597F8+OnIVnn38Pz46ajWdfmINnR8/Fsy/Ow7Nj5uPZlxbg2bEL8ezL7+PZcYvw7Csf4Nnxi/HshA/x7MQlePbVj/DspKV49rWP8ezkZXj29U/w7JTlePaNT/Hs1BV49s3P8Oy0lXj2rc/x7PRVePbt1Xh2xho8+84XeHbmWjz77pd4dtY6PPveV3h29no8O+drPDt3A56d9w2enb8Rzy74Fs8u3IRn3/8Ozy7ajGc/+B7PLt6CZz/8Ac8u2YpnP/oRzy7dhmc//gnPLtuOZz/5Gc8u34FnP92JZ1fswrOf/YJnV+7Gs5//imdX7cGzq3/Ds2v24tkv9uHZtfvx7Je/49l1B/DsV3/g2fUH8ezXf+LZDYfw7Dd/4dmNh/Hst3/j2U1H8Ox3/+DZzUfx7Pf/4tktx/DsD8fx7NZQBzT7YxjPbsuGZ3/Kjme358CzP5+BZ3fkxLM7z8Szu3Lh2V/OwrO7c+PZX8/Gs3vy4NnfzsGze/Pi2X3n4tn9SXj29/Pw7IF8ePaP8/Hswfx49s8L8OyhAnj2rwvx7OGCePbvi/DskUJ49p+L8ezRwnj230vw7LEiePb4pWg2eygZz4Yvw7PZiuLZ7Jfj2RzF8OwZV+DZnMXx7Jkl8GyuFDx71pV4NndJPHv2VXg2Tyk8e87VeDZvaTx77jV4NqkMnj3vWjybryyePf86PJu/HJ694Ho8W6A8nr3wBjxbsAKevehGPFuoIp69+CY8W7gSnr3kZjxbpDKevfQWPJscwbOX3Ypni1bBs5ffhmeLVcWzV9yOZ4tXw7MlquPZlBp49so78GzJmnj2qjvxbKlaePbq2ni2dB08e01dPFumHp69tj6eLdsAz17XEM+Wa4Rnr78Lz5ZvjGdvaIJnKzTFszfejWcrNsOzN92DZys1x7M3t8CzlVvi2VvuxbORKJ69tRWerdIaz952H56t2gbP3t4Wz1Zrh2ert8ezNTrg2Ts64tmanfDsnffj2Vqd8WztLni2Tlc8W7cbnq3XHc/W74FnG/TEsw174dlGvfHsXQ/g2cZ98GyTB/Fs07549u6H8Gyzfnj2nofxbPP+eLbFI3i25QA8e++jeDaaimdbPYZnWw/Es/c9jmfbDMKzbZ/As+0G49n2T+LZDkPwbMen8GynoXj2/qfxbOdheLbLM3i263A82+1ZPNt9BJ7t8Rye7TkSz/Z6Hs/2HoVnH3gBz/YZjWcffBHP9h2DZx96Cc/2G4tnH34Zz/Yfh2cfeQXPDhiPZx+dgGdTJ+LZx17FswMn4dnHX8Ozgybj2Sdex7ODp+DZJ9/As0Om4tmn3sSzQ6fh2affwrPDpuPZZ97Gs8Nn4Nln38GzI2bi2efexbMjZ+HZ59/Ds6Nm49kX5uDZ0XPx7Ivz8OyY+Xj2pQV4duxCPPvy+3h23CI8+8oHeHb8Yjw74UM8O3EJnn31Izw7aSmefe1jPDt5GZ59/RM8O2U5nn3jUzw7dQWeffMzPDttJZ5963M8O30Vnn17NZ6dsQbPvvMFnp25Fs+++yWenbUOz773FZ6dvR7Pzvkaz87dgGfnfYNn52/Eswu+xbMLN+HZ97/Ds4s249kPvsezi7fg2Q9/wLNLtuLZj37Es0u34dmPf8Kzy7bj2U9+xrPLd+DZT3fi2RW78Oxnv+DZlbvx7Oe/4tlVe/Ds6t/w7Jq9ePaLfXh27X48++XveHbdATz71R94dv1BPPv1n3h2wyE8+81feHbjYTz77d94dtMRPPvdP3h281E8+/2/eHbLMTz7w3E8uzXUEc3+GMaz27Lh2Z+y49ntOfDsz2fg2R058ezOM/Hsrlx49pez8Ozu3Hj217Px7J48ePa3c/Ds3rx4dt+5eHZ/Ep79/Tw8eyAfnv3jfDx7MD+e/fMCPHuoAJ7960I8e7ggnv37Ijx7pBCe/ediPHu0MJ799xI8e6wInj1+KZpNe4TTfyan/yzTpk7PH6+deOX8erfPfeyxpi1SrttV46EF3Z+77cc/n9+v/n/R20Ohy1qomYxxrmlgHI4Nh5Lb4vNc2oW23v9mSXskI+dJ7oJiR+7/749mzXMZfj2VT2eeovh5yp3OPJfj57n+dOYphp+n/OnMcwV+nhtOZ57i+HkqnM48JfDz3Hg686Tg56l4OvNciZ/nptOZpyR+nkqnM89V+HluPp15SuHnSTqdea7Gz3Pe6cxTGj9PvtOZ5xr8POefzjxl8PPkP515rsXPc8HpzFMWP0+B05nnOvw8F57OPOXw8xQ8nXmux89z0enMUx4/zy2nM88N+HkKnc48FfDzXHw689yIn6fw6cxTET/PJaczz034eYqczjyV8PNcejrz3IyfJ/l05qmMn+ey05nnFvw8RU9nngh+nstPZ55b8fMUO515quDnueJ05rkNP0/x05mnKn6eEqczz+34eVJOZ55q+HmuPJ15quPnKXk689TAz3PV6cxzB36eUqczT038PFefzjx34ucpfTrz1MLPc83pzFMbP0+Z05mnDn6ea09nnrr4ecqezjz18PNcB+9Njob/Sn+T8sR7dwFrl2X4b3ivDt5Hg/e44P0neG8I3reB91Tg/Q54L+Iqx5/XITkU+l61w6odUe2oasfgCVW7j2yq5VAtp2q5VMutWh7V8qqWpFq+y9LeH4DX7vC6Gl7zwutReK0Ir+PgNRa8/rneMm/59J+wz4c9OOyPYe8K+0rY88F+DPZKsI+JdEn79x/+bYZ/N+HfNPj3Bv4tgN/T8DsUfr/B7x74vQDOgk9Q61CH9boE5+83q8k1qP0g5c1qWS2rZbXTaVm/87JaVktr8Mh28jWB8UgO0R7m6xYXzvl8AnWO+oQ5cqiWM/Tf5zek5rX9+c7PQrRI+7wJNRf+syb2R3KI8aAuLkWFLMr4IE0K4YM0lxE+SNOA8Jfpl0wNBGRq6JNMDT2WCWothSFTioxMYetRcvpP59l+FbIYQ6bSBJmKEmRqFACZGgnIdJdPMt3lsUxQa6UZMpWWkSmbPqsx2PlRBhWyOEOmcgSZLifI1DgAMjUWkKmJTzI18VgmqLVyDJnKycikP4XUxVVUIVMYMlUkyFSMIFPTAMjUVECmu32S6W6PZYJaq8iQqaKMTDn0WY3Bzg+hqJAlGTJFCDJdQZCpWQBkaiYg0z0+yXSPxzJBrUUYMkVkZDpDn9UY7PyEjQpZiiFTNYJMxQkyNQ+ATM0FZGrhk0wtPJYJaq0aQ6ZqMjLl1Gc1Bjs/PqRClmbIVIsgUwmCTC0DIFNLAZnu9Ummez2WCWqtFkOmWjIynanPagx2vhWtQpZhyNSAIFMKQaZoAGSKCsjUyieZWnksE9RaA4ZMDWRkyqXPagx2vuBXIcsyZGpKkOlKgkytAyBTawGZ7vNJpvs8lglqrSlDpqYyMp2lz2oMdm6rVMhyDJlaEmQqSZCpTQBkaiMgU1ufZGrrsUxQay0ZMrWUkSm3Pqsx2Fm8KmR5hkxtCDJdRZCpXQBkaicgU3ufZGrvsUxQa20YMrWRkelsfVZjsGtxnVTICgyZOhFkKkWQqUMAZOogIFNHn2Tq6LFMUGudGDJ1kpEpjz6rMdi1uO4qZEWGTN0JMl1NkKlTAGTqJCDT/T7JdL/HMkGtdWfI1F1GpnP0WY3BrsX1USErMWTqQ5CpNEGmzgGQqbOATF18kqmLxzJBrfVhyNRHRqa8+qzGYNfi+quQlRky9SfIdA1Bpq4BkKmrgEzdfJKpm8cyQa31Z8jUX0amc/VZjcGuxQ1UISMMmQYSZCpDkKl7AGTqLiBTD59k6uGxTFBrAxkyDZSRKUmf1RjsWtwQFbIKQ6YhBJmuJcjUMwAy9RSQqZdPMvXyWCaotSEMmYbIyHSePqsx2LW44SpkVYZMwwkylSXI1DsAMvUWkOkBn2R6wGOZoNaGM2QaLiNTPn1WY7BrcaNUyGoMmUYRZLqOIFOfAMjUR0CmB32S6UGPZYJaG8WQaZSMTOfrsxqDXYsbq0LWYMg0liBTOYJMfQMgU18BmR7ySaaHPJYJam0sQ6axMjLl12c1BrsWN1GFrMmQaSJBpusJMvULgEz9BGR62CeZHvZYJqi1iQyZJsrIdIE+qzHYtbgpKmQthkxTCDKVJ8jUPwAy9ReQ6RGfZHrEY5mg1qYwZJoiI1MBfVZjsGtx01XIOgyZphNkuoEg04AAyDRAQKZHfZLpUY9lglqbzpBpuoxMF+qzGoNdi5ulQtZjyDSLIFMFgkypAZApVUCmx3yS6TGPZYJam8WQaZaMTAX1WY3BrsXNVyEbMGSaT5DpRoJMAwMg00ABmR73SabHPZYJam0+Q6b5MjJdpM9qDHYtbrEK2Ygh02KCTBUJMg0KgEyDBGR6wieZnvBYJqi1xQyZFsvIVEif1RjsWtwyFbIxQ6ZlBJluIsg0OAAyDRaQ6UmfZHrSY5mg1pYxZFomI9PF+qzGYNfiVqqQTRkyrSTIVIkg05AAyDREQKanfJLpKY9lglpbyZBppYxMhfVZjcGuxa1VIZsxZFpLkOlmgkxDAyDTUAGZnvZJpqc9lglqbS1DprUyMl2iz2oMdi1ugwrZnCHTBoJMlQkyDQuATMMEZHrGJ5me8VgmqLUNDJk2yMhURJ/VGOxa3GYVsiVDps0EmW4hyDQ8ADINF5DpWZ9ketZjmaDWNjNk2iwj06X6rMZg1+K2qZBRhkzbCDJFCDKNCIBMIwRkes4nmZ7zWCaotW0MmbbJyKRj1MXtUiFbM2TaRZDpVoJMIwMg00gBmZ73SabnPZYJam0XQ6ZdMjJdps9qDHYtbq8K2YYh016CTFUIMo0KgEyjBGR6wSeZXvBYJqi1vQyZ9srIVFSf1RjsWtxBFbIdQ6aDBJluI8g0OgAyjRaQ6UWfZHrRY5mg1g4yZDooI9Pl+qzGYNfijqiQHRgyHSHIVJUg05gAyDRGQKaXfJLpJY9lglo7wpDpiIxMxfRZjcGuxYWqhUKdGDLBOBwbDt1OkGlsAGQaKyDTyz7J9LLHMkGtQe1Qc+Hrzf5IxmFXGLPqg12Ly6lCdmbIlJMgUzWCTOMCINM4AZle8UmmVzyWCWotJ0OmnDIyFddnNQa7FpdHhezKkCkPQabqBJnGB0Cm8QIyTfBJpgkeywS1lochUx4ZmUqc+i94UuFiybYnNSXTH5ojFO9RX39Sk+Kx5u3uI3FY827e4ThsppsVx4mc+V6ssSNbbjUZicVa7qQXM7LtRmGxIlvvgxQjsv02LxEra7+LhT1yjIv0WyPHuga5LXLMSyxHMnfFvIKsJXLsC2Rmjhzn+n+ZIse7vFnEOI539SYzctyL0xiR4197Q4/suLRAJOOB45vTWmTXF0MzRnZ+7y1DZPfXeiKn/sv9rYX/IiM+lH0qMuYzpycjoz5SF0n7gfrEUHpk3Aci0iIjz/eeiIw9nRVRDftuPURGvxmpIuPfa0kKEV5KRgg7ZfJGwHwk47Ai/LHhU9UbzvAHTVS5X1VtkmqvqTZZtddVm6LaG6pNVe1N1aap9pZq01V7W7UZqr2j2kzV3lVtlmrvqTZbtTmqzVVtnmrzVVug2kLV3ldtkWofdEkPkT39J4TIZfS9aumbZOl7zdI32dL3uqVviqXvDUvfVEvfm5a+aZa+tyx90y19b1v6Zlj63rH0zbT0vWvpm2Xpe8/SN9vSN8fSN9fSN8/SN9/St8DSt9DS976lb5Gl74Mu5h0OT7ylc+KRfKona+OZ4RGJxWZtPNMeWRvPtEfWxjPtkbXxTPuRtfEMJeTG03mdQCS77/jx8KtoNhSehGVV3tdw7EiVNzwZxR6EtYVfx7BbTzwP4SkItkracxZ+w82OSH9+w1OdbLeTfxfhN13s/FN/b+FpDrbvf3/H4bfis9Uz1EN4elx2Z8baCb8djy2r1Vl4Rhy2hF6T4Xdis82N+g3PjMk2MWs9/G4sNjWTF+FZMdjUzA6F37Ozcyy+hWdb2ao2N8NzbGxdq8fhuRZ2nt358LzMbEqM3w/h+ZnYCbF+l4QXmGyZmL93wgsNdmvs31Hh93W2R5zfZ+FFGls73u++8Af436knHif/xU0O2eot8+/WfOrFRnfGmaF8hDNDNQhnhhYT1uvXmaHFXbyf40PCHP/PM0MfelxvUGv5GGeG8smcGUrRZzUGuxZXUIXsyZCpIEGmOwgyLQmATEsEZPrIJ5k+8lgmqLWCDJkKysh0pT6rMdi1uCIqZG+GTEUIMtUkyLQ0ADItFZDpY59k+thjmaDWijBkKiIjU0l9VmOwa3HFVMg+DJmKEWS6kyDTsgDItExApk98kukTj2WCWivGkKmYjExX6bMag12LK6lC9mXIVJIgUy2CTMsDINNyAZk+9UmmTz2WCWqtJEOmkjIyldJnNQa7FldGhezHkKkMQabaBJlWBECmFQIyfeaTTJ95LBPUWhmGTGVkZLpan9UY7FpceRWyP0Om8gSZ6hBkWhkAmVYKyPS5TzJ97rFMUGvlGTKVl5GptD6rMdi1uEoq5ACGTJUIMtUlyLQqADKtEpBptU8yrfZYJqi1SgyZKsnIdI0+qzHYeb9qFTKVIVMVgkz1CDKtCYBMawRk+sInmb7wWCaotSoMmarIyFRGn9UY7LwrqAo5kCFTDYJM9QkyrQ2ATGsFZPrSJ5m+9FgmqLUaDJlqyMh0rT6rMdh57zUVchBDpjoEmRoQZFoXAJnWCcj0lU8yfeWxTFBrdRgy1ZGRqaw+qzHYeYcbFXIwQ6ZGBJkaEmRaHwCZ1gvI9LVPMn3tsUxQa40YMjWSkek6fVZjsPM+AirkEIZMzQgyNSLItCEAMm0QkOkbn2T6xmOZoNaaMWRqJiNTOX1WY7Dzas0q5FCGTFGCTHcRZNoYAJk2Csj0rU8yfeuxTFBrUYZMURmZrtdnNQY7r4mpQg5jyNSOIFNjgkybAiDTJgGZvvNJpu88lglqrR1DpnYyMpXXZzUGO688pkIOZ8jUmSBTE4JMmwMg02YBmb73SabvPZYJaq0zQ6bOMjLdoM9qDHZ+JF6FHMGQqSdBpqYEmbYEQKYtAjL94JNMP3gsE9RaT4ZMPWVkqqDPagx2fvBQhRzJkKkvQaa7CTJtDYBMWwVk+tEnmX70WCaotb4MmfrKyHSjPqsx2PnxDhVyFEOmAQSZmhFk2hYAmbYJyPSTTzL95LFMUGsDGDINkJGpoj6rMdh5Ek2FHM2QaRBBpnsIMm0PgEzbBWT62SeZfvZYJqi1QQyZBsnIdJM+qzHY+ValCjmGIdNQgkzNCTLtCIBMOwRk2umTTDs9lglqbShDpqEyMlXSZzUGO18QqpBjGTKNIMjUgiDTrgDItEtApl98kukXj2WCWhvBkGmEjEw367Mag53/7KqQ4xgyjSbI1JIg0+4AyLRbQKZffZLpV49lglobzZBptIxMlfVZjcHOxamQ4xkyjSPIdC9Bpj0BkGmPgEy/+STTbx7LBLU2jiHTOBmZbtFnNQa7FjdJhZzIkGkSQaYoQaa9AZBpr4BM+3ySaZ/HMkGtTWLINElGpoh2RF3cVBVyEkOmqQSZWhFk2h8AmfYLyPS7TzL97rFMUGtTGTJNlZHpVn1WY7BrcTNUyMkMmWYQZGpNkOlAAGQ6ICDTHz7J9IfHMkGtzWDINENGpir6rMZg1+Jmq5BTGDLNJsh0H0GmgwGQ6aCATH/6JNOfHssEtTabIdNsGZlu02c1BrsWt1CFnMqQaSFBpjYEmQ4FQKZDAjL95ZNMf3ksE9TaQoZMC2VkqqrPagx2XttbhZzGkGkJQaa2BJkOB0CmwwIy/e2TTH97LBPU2hKGTEtkZLpdn9UY7LyCqgo5nSHTcoJM7QgyHQmATEcEZPrHJ5n+8VgmqLXlDJmWy8hUTZ/VGOy8Tp0aPoMh0yqCTO0JMh0NgExHBWT61yeZ/vVYJqi1VQyZVsnIVF2f1RjsvBqQCjmTIdM6gkwdCDIdC4BMxwRkOu6TTMc9lglqbR1DpnUyMtXQZzUGO6+5oELOYsi0kSBTR4JMoa6JLxMl43+DaHOEu/ojU7irtzJBrW1kyLRRRqY79FmNwc5vtqqQsxkybSHI1IkgU7YAyJRNQKbsPsmU3WOZoNa2MGTaIiNTTX1WY7Dz+0Mq5FyGTNsJMt1PkClHAGTKISDTGT7JdIbHMkGtbWfItF1Gpjv1WY3Bzk9pq5DzGTLtJsjUmSBTzgDIlFNApjN9kulMj2WCWtvNkGm3jEy19FmNwc7PwqmQCxky7SfI1IUgU64AyJRLQKazfJLpLI9lglrbz5Bpv4xMtfVZjcHOTxyokIsYMh0iyNSVIFPuAMiUW0Cms32S6WyPZYJaO8SQ6ZCMTHX0WY3BzvM6KuRihkxHCTJ1I8iUJwAy5RGQ6RyfZDrHY5mg1o4yZDoqI1PdU/8FT2qekP1JTcn0h+YIxXt8qJ9vSIrHmre7j8Rhzbt5h+OwmW5WHCdy5nuxxo5sudVkJBZruZNezMi2G4XFimy9D1KMyPbbvESsrP0uFvbIMS7Sb40c6xrktsgxL7EcydwV8wqylsixL5CZOXKc6/9lihzv8mYR4zje1ZvMyHEvTmNEjn/tDT2y49ICkYwHjm9Oa5FdXwzNGNn5vbcMkd1f64mc+i/3txb+i4z4UPapyJjPnJ6MjPpIXSTtB+oTQ+mRcR+ISIuMPN97IjL2dFZENey79RAZ/Wakiox/ryUpRHgpGSHslMkbAfORjMOK8MeGT1VvOMMflFflPle1JNXOUy2fauerll+1C1QroNqFqhVU7SLVCql2sWqFVbtEtSKqXQprV+0y1YqqdrlqxVS7QrXiqpVQLUW1K1UrqdpVXdNDZE//CSFyGX3nWvqSLH3nWfryWfrOt/Tlt/RdYOkrYOm70NJX0NJ3kaWvkKXvYktfYUvfJZa+Ipa+Sy19yZa+yyx9RS19l1v6iln6rrD0Fbf0lbD0pVj6rrT0lbT0XZXel/Fx8jOFyad6sjaeGR6RWGzWxjPtkbXxTHtkbTzTHlkbz7QfWRvPUEJuPF3vJuVFsvuOHw+fi2ZD4SQsq/Keh2NHqrzhfCj2IKwtfD6G3XrieQjnR7BV0p6z8AVudkT68xsu4GS7nfy7CF/oYuef+nsLF3Swff/7Ow5fFJ+tnqEewoXisjsz1k744nhsWa3OwoXjsCX0mgxfEpttbtRvuEhMtolZ6+FLY7GpmbwIJ8dgUzM7FL7Mzs6x+BYuamWr2twMX25j61o9DhezsPPszoevyMymxPj9EC6eiZ0Q63dJuITJlon5eyecYrBbY/+OCl+psz3i/D4Ll9TY2vF+94Wvwv9OPfE4+S9ucshWb5aPglYPhZYwzgzBOBwbDnUnnBkqFYAzQ6W6ej/H1T6dGbra43qDWoPaoebC15v9kYzD6umzGoOdH7hRIZcyZMpFkKkHQabSAZCptIBM1/gk0zUeywS1loshUy4ZmerrsxqDnbt+FXIZQ6a8BJl6EmQqEwCZygjIdK1PMl3rsUxQa3kZMuWVkamBPqsx2LW4/CrkcoZM+Qky9SLIVDYAMpUVkOk6n2S6zmOZoNbyM2TKLyNTQ31WY7BrcYVUyBUMmQoRZOpNkKlcAGQqJyDT9T7JdL3HMkGtFWLIVEhGpkb6rMZg1+KSVciVDJmSCTI9QJCpfABkKi8g0w0+yXSDxzJBrSUzZEqWkekufVZjsGtxxVXIVQyZihNk6kOQqUIAZKogINONPsl0o8cyQa0VZ8hUXEamxvqsxmDnW9Eq5BqGTKUIMj1IkKliAGSqKCDTTT7JdJPHMkGtlWLIVEpGpib6rMZg5wt+FXItQ6ayBJn6EmSqFACZKgnIdLNPMt3ssUxQa2UZMpWVkampPqsx2LmtUiHXMWSqQJDpIYJMlQMgU2UBmW7xSaZbPJYJaq0CQ6YKMjLdrc9qDHYWrwq5niFTZYJM/QgyRQIgU0RAplt9kulWj2WCWqvMkKmyjEzN9FmNwa7FVVUhNzBkqkqQ6WGCTFUCIFMVAZlu80mm2zyWCWqtKkOmqjIy3aPPagx2La6mCrmRIVNNgkz9CTJVDYBMVQVkut0nmW73WCaotZoMmWrKyNRcn9UY7FpcPRVyE0OmegSZHiHIVC0AMlUTkKm6TzJV91gmqLV6DJnqycjUQp/VGOxaXGMVcjNDpsYEmQYQZKoRAJlqCMh0h08y3eGxTFBrjRkyNZaRqaU+qzHYtbjmKuQWhkzNCTI9SpCpZgBkqikg050+yXSnxzJBrTVnyNRcRqZ79VmNwa7FtVYhtzJkak2QKZUgU60AyFRLQKbaPslU22OZoNZaM2RqLSNTVDuiLq6DCrmNIVMHgkyPEWSqEwCZ6gjIVNcnmep6LBPUWgeGTB1kZGqlz2oMdi2uqwq5nSFTV4JMAwky1QuATPUEZKrvk0z1PZYJaq0rQ6auMjK11mc1BrsW11uF3MGQqTdBpscJMjUIgEwNBGRq6JNMDT2WCWqtN0Om3jIy3afPagx2La6fCrmLIVM/gkyDCDI1CoBMjQRkussnme7yWCaotX4MmfrJyNRGn9UY7Fpcqgq5myFTKkGmJwgyNQ6ATI0FZGrik0xNPJYJai2VIVOqjExt9VmNwa7FDVYh9zBkGkyQaTBBpqYBkKmpgEx3+yTT3R7LBLU2mCHTYBmZ2umzGoNdixumQu5lyDSMINOTBJmaBUCmZgIy3eOTTPd4LBPU2jCGTMNkZGqvz2oMdi1upAq5nyHTSIJMQwgyNQ+ATM0FZGrhk0wtPJYJam0kQ6aRMjJ10Gc1BrsWN0aFPMCQaQxBpqcIMrUMgEwtBWS61yeZ7vVYJqi1MQyZxsjI1FGf1RjsWtx4FfIgQ6bxBJmGEmSKBkCmqIBMrXySqZXHMkGtjWfINF5Gpk76rMZg1+Imq5CHGDJNJsj0NEGm1gGQqbWATPf5JNN9HssEtTaZIdNkGZnu12c1BrsWN02FPMyQaRpBpmEEmdoEQKY2AjK19Ummth7LBLU2jSHTNBmZOuuzGoNdi5upQh5hyDSTINMzBJnaBUCmdgIytfdJpvYeywS1NpMh00wZmbrosxqDXYubq0IeZcg0lyDTcIJMHQIgUwcBmTr6JFNHj2WCWpvLkGmujExd9VmNwa7FLVIhjzFkWkSQ6VmCTJ0CIFMnAZnu90mm+z2WCWptEUOmRTIyddNnNQY7b/GhQsL3C6kyLSXINIIgU+cAyNRZQKYuPsnUxWOZoNaWMmRaKiNTd31WY7DzQuoqZDaGTCsIMj1HkKlrAGTqKiBTN59k6uaxTFBrKxgyrZCRqYc+qzHYeblaFTIHQ6Y1BJlGEmTqHgCZugvI1MMnmXp4LBPU2hqGTGtkZOqpz2oMdl4UUIXMyZBpPUGm5wky9QyATD0FZOrlk0y9PJYJam09Q6b1MjL10mc1BjsvvaRC5mLItIkg0yiCTL0DIFNvAZke8EmmBzyWCWptE0OmTTIy9dZnNQY7L3ChQuZmyLSVINMLBJn6BECmPgIyPeiTTA96LBPU2laGTFtlZHpAn9UY7PwasQqZhyHTDoJMowky9Q2ATH0FZHrIJ5ke8lgmqLUdDJl2yMjUR5/VGOz8spYKmZch0x6CTC8SZOoXAJn6Ccj0sE8yPeyxTFBrexgy7ZGR6cFT/wVPap6Q/UlNyfSH5gjFe1ytP6lJ8VjzdveROKx5N+9wHDbTzYrjRM58L9bYkS23mozEYi130osZ2XajsFiRrfdBihHZfpuXiJW138XCHjnGRfqtkWNdg9wWOeYlliOZu2JeQdYSOfYFMjNHjnP9v0yR413eLGIcx7t6kxk57sVpjMjxr72hR3ZcWiCS8cDxzWktsuuLoRkjO7/3liGy+2s9kVP/5f7Wwn+RER/KPhUZ85nTk5FRH6mLpP1AfWIoPTLuAxFpkZHne09Exp7OiqiGfbceIqPfjFSR8e+1JIUILyUjhJ0yeSNgPpJxWBH+2PCp6g1n+IP6q9yPqDZAtUdVS1XtMdUGqva4aoNUe0K1wao9qdoQ1Z5SbahqT6s2TLVnVBuu2rOqjVDtOdVGqva8aqNUe0G10aq9qNoY1V7qmh4ie/pPCJHL6HvE0jfA0veopS/V0veYpW+gpe9xS98gS98Tlr7Blr4nLX1DLH1PWfqGWvqetvQNs/Q9Y+kbbul71tI3wtL3nKVvpKXveUvfKEvfC5a+0Za+Fy19Yyx9L6X3ZXxUS/+ZfKona+OZ4RGJxWZtPNMeWRvPtEfWxjPtkbXxTPuRtfEMJeTG0/VuUn8ku+/48fAjaDYUHoBlVd5HcexIlTecimIPwtrCj2HYrSeeh/BABFsl7TkLP+5mR6Q/v+FBTrbbyb+L8BMudv6pv7fwYAfb97+/4/CT8dnqGeohPCQuuzNj7YSfiseW1eosPDQOW0KvyfDTsdnmRv2Gh8Vkm5i1Hn4mFpuayYvw8BhsamaHws/a2TkW38IjrGxVm5vh52xsXavH4ZEWdp7d+fDzmdmUGL8fwqMysRNi/S4Jv2CyZWL+3gmPNtitsX9HhV/U2R5xfp+Fx2hs7Xi/+8Iv4X+nnnic/Bc3OWSrN8v1XdQ77kmMM0MHCGeGxhDODI0lrNevM0Nju3o/x8uEOf6fZ4Ze9rjeoNYOMM4MHZA5M9RXn9UY7PwWvQqZjyHTYYJMLxFkGhcAmcYJyPSKTzK94rFMUGuHGTIdlpHpIX1WY7Dzu4oqZH6GTMcIMo0lyDQ+ADKNF5Bpgk8yTfBYJqi1YwyZjsnI1E+f1Rjs/EZIjVCoAEMmGIdjw6GXCTJNDIBMEwVketUnmV71WCaoNagdai58vdkfyTjsYX1WY7Dzc7cqZEGGTLkJMo0jyDQpADJNEpDpNZ9kes1jmaDWcjNkyi0jU399VmOw8wWhClmIIVMSQaZXCDJNDoBMkwVket0nmV73WCaotSSGTEkyMj2iz2oMdv6zq0IWZshUgCDTeIJMUwIg0xQBmd7wSaY3PJYJaq0AQ6YCMjIN0Gc1BjsXp0IWYchUmCDTBIJMUwMg01QBmd70SaY3PZYJaq0wQ6bCMjI9qs9qDHYtriiEZMhUlCDTRIJM0wIg0zQBmd7ySaa3PJYJaq0oQ6aiMjKlakfUxaWokEUZMqUQZHqVINP0AMg0XUCmt32S6W2PZYJaS2HIlCIj02P6rMZg1+JKq5DFGDKVJsg0iSDTjADINENApnd8kukdj2WCWivNkKm0jEwD9VmNwa7FlVMhizNkKkeQ6TWCTDMDINNMAZne9Ummdz2WCWqtHEOmcjIyPa7Pagx2La6iCpnCkKkiQabJBJlmBUCmWQIyveeTTO95LBPUWkWGTBVlZBqkz2oMdi0uokKWZMgUIcj0OkGm2QGQabaATHN8kmmOxzJBrUUYMkVkZHpCn9UY7FpcNRWyFEOmagSZphBkmhsAmeYKyDTPJ5nmeSwT1Fo1hkzVZGQarM9qDHYtrpYKWZohUy2CTG8QZJofAJnmC8i0wCeZFngsE9RaLYZMtWRkelKf1RjsWlwDFbIMQ6YGBJmmEmRaGACZFgrI9L5PMr3vsUxQaw0YMjWQkWmIPqsx2LW4pipkWYZMTQkyvUmQaVEAZFokINMHPsn0gccyQa01ZcjUVEamp/RZjcGuxbVUIcsxZGpJkGkaQabFAZBpsYBMH/ok04ceywS11pIhU0sZmYbqsxqDnfcjVyHLM2RqQ5DpLYJMSwIg0xIBmT7ySaaPPJYJaq0NQ6Y2MjI9rc9qDHbe9VWFrMCQqRNBpukEmZYGQKalAjJ97JNMH3ssE9RaJ4ZMnWRkGqbPagx23ltPhazIkKk7Qaa3CTItC4BMywRk+sQnmT7xWCaote4MmbrLyPSMPqsx2HkHIxWyEkOmPgSZZhBkWh4AmZYLyPSpTzJ96rFMUGt9GDL1kZFpuD6rMdh5GUUVsjJDpv4Emd4hyLQiADKtEJDpM59k+sxjmaDW+jNk6i8j07P6rMZg1+IGqpARhkwDCTLNJMi0MgAyrRSQ6XOfZPrcY5mg1gYyZBooI9MIfVZjsGtxQ1TIKgyZhhBkepcg06oAyLRKQKbVPsm02mOZoNaGMGQaIiPTc/qsxmDX4oarkFUZMg0nyDSLINOaAMi0RkCmL3yS6QuPZYJaG86QabiMTCP1WY3BrsWNUiGrMWQaRZDpPYJMawMg01oBmb70SaYvPZYJam0UQ6ZRMjI9r89qDHZe21uFrMGQaSxBptkEmdYFQKZ1AjJ95ZNMX3ksE9TaWIZMY2VkGqXPagx2XkFVhazJkGkiQaY5BJnWB0Cm9QIyfe2TTF97LBPU2kSGTBNlZHpBn9UY7LxOnQpZiyHTFIJMcwkybQiATBsEZPrGJ5m+8VgmqLUpDJmmyMiklxN1cdNVyDoMmaYTZJpHkGljAGTaKCDTtz7J9K3HMkGtTWfINF1Gphf1WY3BzmsuqJD1GDLNIsg0nyDTpgDItElApu98kuk7j2WCWpvFkGmWjExj9FmNwc5vtqqQDRgyzSfItIAg0+YAyLRZQKbvfZLpe49lglqbz5BpvoxML+mzGoOd3x9SIRsxZFpMkGkhQaYtAZBpi4BMP/gk0w8eywS1tpgh02IZmcbqsxqDnZ/SViEbM2RaRpDpfYJMWwMg01YBmX70SaYfPZYJam0ZQ6ZlMjK9rM9qDHZ+Fk6FbMqQaSVBpkUEmbYFQKZtAjL95JNMP3ksE9TaSoZMK2VkGqfPagx2fuJAhWzGkGktQaYPCDJtD4BM2wVk+tknmX72WCaotbUMmdbKyPSKPqsx2HleR4VszpBpA0GmxQSZdgRAph0CMu30SaadHssEtbaBIdMGGZnG67Mag53vnqmQLRkybSbI9CFBpl0BkGmXgEy/+CTTLx7LBLW2mSHTZhmZJpz6L3hS84TsT2pKpj80Ryje42X9SU2Kx5q3u4/EYc27eYfjsJluVhwncuZ7scaObLnVZCQWa7mTXszIthuFxYpsvQ9SjMj227xErKz9Lhb2yDEu0m+NHOsa5LbIMS+xHMncFfMKspbIsS+QmTlynOv/ZYoc7/JmEeM43tWbzMhxL05jRI5/7Q09suPSApGMB45vTmuRXV8MzRjZ+b23DJHdX+uJnPov97cW/ouM+FD2qciYz5yejIz6SF0k7QfqE0PpkXEfiEiLjDzfeyIy9nRWRDXsu/UQGf1mpIqMf68lKUR4KRkh7JTJGwHzkYzDivDHhk9VbzjDH7Rb5f5VtT2q/abaXtX2qbZftd9VO6DaH6odVO1P1Q6p9pdqh1X7W7Ujqv2j2lHV/lXtmGrHVQt1U/Oolk217KrlUO0M1XKqdma39BDZ039CiFxG36+Wvj2Wvt8sfXstffssffstfb9b+g5Y+v6w9B209P1p6Ttk6fvL0nfY0ve3pe+Ipe8fS99RS9+/lr5jlr7jlj74Szb7wpa+bJa+7Ja+HJa+Myx9OS19Z6b3ZXxUS/+ZfKona+OZ4RGJxWZtPNMeWRvPtEfWxjPtkbXxTPuRtfEMJeTG0/Vu0m4ku+/48fCvaDYU3oNlVd7fcOxIlTe8F8UehLWF92HYrSeeh/B+BFsl7TkL/+5mR6Q/v+EDTrbbyb+L8B8udv6pv7fwQQfb97+/4/Cf8dnqGeohfCguuzNj7YT/iseW1eosfDgOW0KvyfDfsdnmRv2Gj8Rkm5i1Hv4nFpuayYvw0RhsamaHwv/a2TkW38LHrGxVm5vh4za2rtXjMOy7TXae3flwODObEuP3QzhbJnZCrN8l4ewmWybm751wDoPdGvt3VPgMne0R5/dZOKfG1o73uy98Zjf079QTj5P/4iaHbPVm+cCNesc9yjgztI1wZmgJ4cxQLsJ6/TozlKub93OcRZjj/3lm6CyP6w1qbRvjzBC+3uyPZBw2UTuiLm6XCtmaIdMugkwfEWTKHQCZcgvIdLZPMp3tsUxQa7sYMu2SkelVfVZjsGtxe1XINgyZ9hJkWkqQKU8AZMojINM5Psl0jscyQa3tZci0V0amSfqsxmDX4g6qkO0YMh0kyPQxQaa8AZApr4BM5/ok07keywS1dpAh00EZmV7TZzUGuxZ3RIXswJDpCEGmZQSZkgIgU5KATOf5JNN5HssEtXaEIdMRGZkm67Mag12LC90RCnViyATjcGw49AlBpnwBkCmfgEzn+yTT+R7LBLUGtUPNha83+yMZh71uzKoPdi0upwrZmSFTToJMywky5Q+ATPkFZLrAJ5ku8FgmqLWcDJlyysg0RZ/VGOx8wa9CdmXIlIcg06cEmQoEQKYCAjJd6JNMF3osE9RaHoZMeWRkekOf1Rjs3FapkN0ZMuUjyLSCIFPBAMhUUECmi3yS6SKPZYJay8eQKZ+MTFP1WY3BzuJVIXsyZCpIkOkzgkyFAiBTIQGZLvZJpos9lglqrSBDpoIyMr2pz2oMdi2uiArZmyFTEYJMKwkyFQ6ATIUFZLrEJ5ku8VgmqLUiDJmKyMg0TZ/VGOxaXDEVsg9DpmIEmT4nyFQkADIVEZDpUp9kutRjmaDWijFkKiYj01v6rMZg1+JKqpB9GTKVJMi0iiBTcgBkShaQ6TKfZLrMY5mg1koyZCopI9N0fVZjsGtxZVTIfgyZyhBkWk2QqWgAZCoqINPlPsl0uccyQa2VYchURkamt/VZjcGuxZVXIfszZCpPkGkNQaZiAZCpmIBMV/gk0xUeywS1Vp4hU3kZmWbosxqDXYurpEIOYMhUiSDTFwSZigdApuICMpXwSaYSHssEtVaJIVMlGZne0Wc1BjvvV61CpjJkqkKQaS1BppQAyJQiINOVPsl0pccyQa1VYchURUammfqsxmDnXUFVyIEMmWoQZPqSIFPJAMhUUkCmq3yS6SqPZYJaq8GQqYaMTO/qsxqDnfdeUyEHMWSqQ5BpHUGmUgGQqZSATFf7JNPVHssEtVaHIVMdGZlm6bMag513uFEhBzNkakSQ6SuCTKUDIFNpAZmu8UmmazyWCWqtEUOmRjIyvafPagx23kdAhRzCkKkZQab1BJnKBECmMgIyXeuTTNd6LBPUWjOGTM1kZJqtz2oMdl7gQoUcypApSpDpa4JMZQMgU1kBma7zSabrPJYJai3KkCkqI9McfVZjsPNrxCrkMIZM7QgybSDIVC4AMpUTkOl6n2S63mOZoNbaMWRqJyPTXH1WY7Dzy1oq5HCGTJ0JMn1DkKl8AGQqLyDTDT7JdIPHMkGtdWbI1FlGpnn6rMZg50fiVcgRDJl6EmTaSJCpQgBkqiAg040+yXSjxzJBrfVkyNRTRqb5+qzGYOcHD1XIkQyZ+hJk+pYgU8UAyFRRQKabfJLpJo9lglrry5Cpr4xMC/RZjcHOj3eokKMYMg0gyLSJIFOlAMhUSUCmm32S6WaPZYJaG8CQaYCMTAv1WY3BzpNoKuRohkyDCDJ9R5CpcgBkqiwg0y0+yXSLxzJBrQ1iyDRIRqb39VmNwc63KlXIMQyZhhJk2kyQKRIAmSICMt3qk0y3eiwT1NpQhkxDZWRapM9qDHa+IFQhxzJkGkGQ6XuCTFUCIFMVAZlu80mm2zyWCWptBEOmETIyfaDPagx2/rOrQo5jyDSaINMWgkxVAyBTVQGZbvdJpts9lglqbTRDptEyMi3WZzUGOxenQo5nyDSOINMPBJmqBUCmagIyVfdJpuoeywS1No4h0zgZmT7UZzUGuxY3SYWcyJBpEkGmrQSZagRAphoCMt3hk0x3eCwT1NokhkyTZGRaoh1RFzdVhZzEkGkqQaYfCTLVDIBMNQVkutMnme70WCaotakMmabKyPSRPqsx2LW4GSrkZIZMMwgybSPIVCsAMtUSkKm2TzLV9lgmqLUZDJlmyMi0VJ/VGOxa3GwVcgpDptkEmX4iyFQnADLVEZCprk8y1fVYJqi12QyZZsvI9LE+qzHYtbiFKuRUhkwLCTJtJ8hULwAy1ROQqb5PMtX3WCaotYUMmRbKyLRMn9UY7FrcEhVyGkOmJQSZfibI1CAAMjUQkKmhTzI19FgmqLUlDJmWyMj0iT6rMdi1uOUq5HSGTMsJMu0gyNQoADI1EpDpLp9kustjmaDWljNkWi4j03J9VmOwa3GrVMgZDJlWEWTaSZCpcQBkaiwgUxOfZGrisUxQa6sYMq2SkenTU/8FT2qekP1JTcn0h+YIxXucpT+pSfFY83b3kTiseTfvcBw2082K40TOfC/W2JEtt5qMxGItd9KLGdl2o7BYka33QYoR2X6bl4iVtd/Fwh45xkX6rZFjXYPcFjnmJZYjmbtiXkHWEjn2BTIzR45z/b9MkeNd3ixiHMe7epMZOe7FaYzI8a+9oUd2XFogkvHA8c1pLbLri6EZIzu/95YhsvtrPZFT/+X+1sJ/kREfyj4VGfOZ05ORUR+pi6T9QH1iKD0y7gMRaZGR53tPRMaezoqohn23HiKj34xUkfHvtSSFCC8lI4SdMnkjYD6ScVgR/tjwqeoNZ/iDmqrcd6vWTLV7VGuuWgvVWqp2r2pR1Vqp1lq1+1Rro1pb1dqp1l61Dqp1VK2Taver1lm1Lqp1Va2bat1V66FaT9V6qdZbtQe6pYfInv4TQuQy+u629DWz9N1j6Wtu6Wth6Wtp6bvX0he19LWy9LW29N1n6Wtj6Wtr6Wtn6Wtv6etg6eto6etk6bvf0tfZ0tfF0tfV0tfN0tfd0tfD0tfT0tfL0tfb0vdAel/Gx8nfwMnpP0/stsvE3G2He3bT2a2xd+bhXjrbI84uPty7G37HP2kV7xdJVWOtWZts7RGJxWZtstMeWZvstEfWJjvtkbXJTvuRtckOJeQm2/XvaFMku+/48fDdaDYUboZlVd57cOxI2CM0R7EHT+wnWmDYrWl7j5YItkr6PuVeNzvi5J4m6mS7ndr/tHKx8//bK7V2sH0z7Kvui89Wz7gHaxOX3ant19rGY8vqe7t2cdgSxj6wfWy2ubln7BCTbZJpf9kxFpuaeS/aKQabatm33m9n59j2uJ2tbFXrfriLja1r3zt3tbDzYuyzu2VmU2LtybtnYifE3L/30Nja8X7vhB8g/D6j7vVP/suYHMr0d2L9HbhOnQWYyThbtY5wtmoX4WxVH/xz49vZKkpG7hwPEub4f56terCbt/UGtbaOcbZqnczZqhX6rMZg1+I2qpCzGDJtJMj0C0GmvgGQqa+ATA/5JNNDHssEtbaRIdNGGZk+02c1BrsWt0WFnM2QaQtBpt0EmfoFQKZ+AjI97JNMD3ssE9TaFoZMW2RkWqnPagx2LW67CjmXIdN2gky/EmTqHwCZ+gvI9IhPMj3isUxQa9sZMm2XkelzfVZjsGtxu1XI+QyZdhNk2kOQaUAAZBogINOjPsn0qMcyQa3tZsi0W0amVfqsxmDX4varkAsZMu0nyPQbQabUAMiUKiDTYz7J9JjHMkGt7WfItF9GptX6rMZg1+IOqZCLGDIdIsi0lyDTwADINFBApsd9kulxj2WCWjvEkOmQjExr9FmNwa7FHVUhFzNkOkqQaR9BpkEBkGmQgExP+CTTEx7LBLV2lCHTURmZvtBnNQa7FpetZii0hCETjMOx4dB+gkyDAyDTYAGZnvRJpic9lglqDWqHmgtfb/ZHMg5bq89qDHYtLpcKuZQhUy6CTL8TZBoSAJmGCMj0lE8yPeWxTFBruRgy5ZKR6Ut9VmOwa3F5VchlDJnyEmQ6QJBpaABkGiog09M+yfS0xzJBreVlyJRXRqZ1+qzGYNfi8quQyxky5SfI9AdBpmEBkGmYgEzP+CTTMx7LBLWWnyFTfhmZvtJnNQa7FldIhVzBkKkQQaaDBJmGB0Cm4QIyPeuTTM96LBPUWiGGTIVkZFqvz2oMdi0uWYVcyZApmSDTnwSZRgRAphECMj3nk0zPeSwT1FoyQ6ZkGZm+1mc1BrsWV1yFXMWQqThBpkMEmUYGQKaRAjI975NMz3ssE9RacYZMxWVk2qDPagx2La6UCrmGIVMpgkx/EWQaFQCZRgnI9IJPMr3gsUxQa6UYMpWSkekbfVZjsGtxZVXItQyZyhJkOkyQaXQAZBotINOLPsn0oscyQa2VZchUVkamjfqsxmDX4iqokOsYMlUgyPQ3QaYxAZBpjIBML/kk00seywS1VoEhUwUZmb7VZzUGO++RrkKuZ8hUmSDTEYJMYwMg01gBmV72SaaXPZYJaq0yQ6bKMjJt0mc1BjvvRKtCbmDIVJUg0z8EmcYFQKZxAjK94pNMr3gsE9RaVYZMVWVk+k6f1RjsvN+fCrmRIVNNgkxHCTKND4BM4wVkmuCTTBM8lglqrSZDppoyMm3WZzUGO++qpEJuYshUjyDTvwSZJgZApokCMr3qk0yveiwT1Fo9hkz1ZGT6Xp/VGOy8d4UKuZkhU2OCTMcIMk0KgEyTBGR6zSeZXvNYJqi1xgyZGsvItEWf1RjsWlxzFXILQ6bmBJmOE2SaHACZJgvI9LpPMr3usUxQa80ZMjWXkekHfVZjsGtxrVXIrQyZWhNkCrXD55kSAJmmCMj0hk8yveGxTFBrrRkytZaRaat2RF1cBxVyG0OmDgSZwgSZpgZApqkCMr3pk0xveiwT1FoHhkwdZGT6UZ/VGOxaXFcVcjtDpq4EmbIRZJoWAJmmCcj0lk8yveWxTFBrXRkydZWRaZs+qzHYtbjeKuQOhky9CTJlJ8g0PQAyTReQ6W2fZHrbY5mg1nozZOotI9NP+qzGYOcVVFXIXQyZ+hFkykGQaUYAZJohINM7Psn0jscyQa31Y8jUT0am7fqsxmDndepUyN0MmVIJMp1BkGlmAGSaKSDTuz7J9K7HMkGtpTJkSpWR6Wd9VmOw82pAKuQehkyDCTLlJMg0KwAyzRKQ6T2fZHrPY5mg1gYzZBosI9MOfVZjsPOaCyrkXoZMwwgynUmQaXYAZJotINMcn2Sa47FMUGvDGDINk5Fppz6rMdj5zVYVcj9DppEEmXIRZJobAJnmCsg0zyeZ5nksE9TaSIZMI2Vk2qXPagx2fn9IhTzAkGkMQaazCDLND4BM8wVkWuCTTAs8lglqbQxDpjEyMv2iz2oMdn5KW4U8yJBpPEGm3ASZFgZApoUCMr3vk0zveywT1Np4hkzjZWTarc9qDHZ+Fk6FPMSQaTJBprMJMi0KgEyLBGT6wCeZPvBYJqi1yQyZJsvI9Ks+qzHY+YkDFfIwQ6ZpBJnyEGRaHACZFgvI9KFPMn3osUxQa9MYMk2TkWmPPqsx2HleR4U8wpBpJkGmcwgyLQmATEsEZPrIJ5k+8lgmqLWZDJlmysj0mz6rMdj57pkKeZQh01yCTHkJMi0NgExLBWT62CeZPvZYJqi1uQyZ5srItFef1RjsfI2iQh5jyLSIINO5BJmWBUCmZQIyfeKTTJ94LBPU2iKGTItkZNp36r/gSc0Tsj+pKZn+0ByheI8H9Sc1KR5r3u4+Eoc17+YdjsNmullxnMiZ78UaO7LlVpORWKzlTnoxI9tuFBYrsvU+SDEi22/zErGy9rtY2CPHuEi/NXKsa5DbIse8xHIkc1fMK8haIse+QGbmyHGu/5cpcrzLm0WM43hXbzIjx704jRE5/rU39MiOSwtEMh44vjmtRXZ9MTRjZOf33jJEdn+tJ3Lqv9zfWvgvMuJD2aciYz5zejIy6iN1kbQfqE8MpUfGfSAiLTLyfO+JyNjTWRHVsO/WQ2T0m5EqMv69lqQQ4aVkhLBTJm8EzEcyDivCHxs+Vb3hDH/QcpX7U9VWqPaZaitV+1y1VaqtVm2Nal+otla1L1Vbp9pXqq1X7WvVNqj2jWobVftWtU2qfafaZtW+V22Laj+otlW1H1XbptpP3dJDZE//CSFyGX2fWvpWWPo+s/SttPR9bulbZelbbelbY+n7wtK31tL3paVvnaXvK0vfekvf15a+DZa+byx9Gy1931r6Nln6vrP0bbb0fW/p22Lp+8HSt9XS96Olb5ul76f0voyPk7+Bk9N/nthtl4m52w5v7aazW2PvzMM/6myPOLv48LZu+B3/x6t4v0iqGmvN2mRrj0gsNmuTnfbI2mSnPbI22WmPrE122o+sTXYoITfZzrv0Idl9x4+HP0WzofAKLKvyfoZjR8IeYSWKPXhiP/E5ht2atvdYhWCrpO9TVrvZESf3NGucbLdT+58vXOz8//ZKax1s3wz7qi/js9Uz7sHWxWV3avu1r+KxZfW93fo4bAljH/h1bLa5uWfcEJNtkml/+U0sNjXzXnRjDDbVsm/91s7Ose1xN1nZqtb98Hc2tq5977zZws6Lsc/+PjObEmtPviUTOyHm/v0Hja0d7/dO+CfC7zPqXv/kv4zJoUx/J/ZTreosQOhe+tmqpYSzVUmEs1Xb8c+Nb2erKBm5c/xMmOP/ebbq527e1hvU2lLG2aqlMmer9uuzGoOddypVIbMxZFpBkOk8gkw7AiDTDgGZdvok006PZYJaW8GQaYWMTL/rsxqDnfeDUyFzMGRaQ5ApH0GmXQGQaZeATL/4JNMvHssEtbaGIdMaGZkO6LMag5133VEhczJkWk+Q6XyCTLsDINNuAZl+9UmmXz2WCWptPUOm9TIy/aHPagx23ttAhczFkGkTQab8BJn2BECmPQIy/eaTTL95LBPU2iaGTJtkZDqoz2oMdl5BWoXMzZBpK0GmCwgy7Q2ATHsFZNrnk0z7PJYJam0rQ6atMjL9qc9qDHa+4Fch8zBk2kGQqQBBpv0BkGm/gEy/+yTT7x7LBLW2gyHTDhmZDumzGoOd2yoVMi9Dpj0EmS4kyHQgADIdEJDpD59k+sNjmaDW9jBk2iMj01/6rMZgZ/GqkEkMmQ4QZCpIkOlgAGQ6KCDTnz7J9KfHMkGtHWDIdEBGpsP6rMZg5zf7Vch8DJkOE2S6iCDToQDIdEhApr98kukvj2WCWjvMkOmwjEx/67Mag53fn1Qh8zNkOkaQqRBBpsMBkOmwgEx/+yTT3x7LBLV2jCHTMRmZjuizGoOdJ9HuDIUKMGSCcTg2HLqYINORAMh0RECmf3yS6R+PZYJag9qh5sLXm/2RjMP+0Wc1BjvfqlQhCzJkyk2QqTBBpqMBkOmogEz/+iTTvx7LBLWWmyFTbhmZjuqzGoOdLwhVyEIMmZIIMl1CkOlYAGQ6JiDTcZ9kOu6xTFBrSQyZkmRk+lef1Rjs/GdXhSzMkKkAQaYiBJlC3RNfJkrG/wbR5gh390emcHdvZYJaK8CQqYCMTMf0WY3BzsWpkEUYMhUmyHQpQaZsAZApm4BM2X2SKbvHMkGtFWbIVFhGpuP6rMZg1+KKQkiGTEUJMiUTZMoRAJlyCMh0hk8yneGxTFBrRRkyFRWRKWw/TE7/6VpcigpZlCFTCkGmywgy5QyATDkFZDrTJ5nO9FgmqLUUhkwpMjLpNlEXV1qFLMaQqTRBpqIEmXIFQKZcAjKd5ZNMZ3ksE9RaaYZMpWVkyqYfGoNdiyunQhZnyFSOINPlBJlyB0Cm3AIyne2TTGd7LBPUWjmGTOVkZNKfQuriKqqQKQyZKhJkKkaQKU8AZMojINM5Psl0jscyQa1VZMhUUUYm/aps1MVFVMiSDJkiBJmuIMiUNwAy5RWQ6VyfZDrXY5mg1iIMmSIyMp2hHxqDXYurpkKWYshUjSBTcYJMSQGQKUlApvN8kuk8j2WCWqvGkKmajEw59UNjsGtxtVTI0gyZahFkKkGQKV8AZMonINP5Psl0vscyQa3VYshUS0amM/VDY7BrcQ1UyDIMmRoQZEohyJQ/ADLlF5DpAp9kusBjmaDWGjBkaiAjk35ZferimqqQZRkyNSXIdCVBpgIBkKmAgEwX+iTThR7LBLXWlCFTUxmZztIPjcGuxbVUIcsxZGpJkKkkQaaCAZCpoIBMF/kk00UeywS11pIhU0sZmXLrh8Zg1+LaqJDlGTK1Ich0FUGmQgGQqZCATBf7JNPFHssEtdaGIVMbGZnO1g+Nwa7FdVIhKzBk6kSQqRRBpsIBkKmwgEyX+CTTJR7LBLXWiSFTJxmZ8uiHxmDX4rqrkBUZMnUnyHQ1QaYiAZCpiIBMl/ok06UeywS11p0hU3cZmc7RD43BrsX1USErMWTqQ5CpNEGm5ADIlCwg02U+yXSZxzJBrfVhyNRHRqa8+qEx2LW4/ipkZYZM/QkyXUOQqWgAZCoqINPlPsl0uccyQa31Z8jUX0amc/VDY7BrcQNVyAhDpoEEmcoQZCoWAJmKCch0hU8yXeGxTFBrAxkyDZSRKUk/NAa7FjdEhazCkGkIQaZrCTIVD4BMxQVkKuGTTCU8lglqbQhDpiEyMp2nHxqDXYsbrkJWZcg0nCBTWYJMKQGQKUVApit9kulKj2WCWhvOkGm4jEz59ENjsGtxo1TIagyZRhFkuo4gU8kAyFRSQKarfJLpKo9lglobxZBplIxM5+uHxmDX4saqkDUYMo0lyFSOIFOpAMhUSkCmq32S6WqPZYJaG8uQaayMTPn1Q2Owa3ETVciaDJkmEmS6niBT6QDIVFpApmt8kukaj2WCWpvIkGmijEwX6IfGYNfipqiQtRgyTSHIVJ4gU5kAyFRGQKZrfZLpWo9lglqbwpBpioxMBfRDY7BrcdNVyDoMmaYTZLqBIFPZAMhUVkCm63yS6TqPZYJam86QabqMTBee+k94UuHDRbYnNSXTH5ojFO/xs36Z3KR4rHm7+0gc1rybdzgOm+lmxXEiZ74Xa+zIlltNRmKxljvpxYxsu1FYrMjW+yDFiGy/zUvEytrvYmGPHOMi/dbIsa5Bbosc8xLLkcxdMa8ga4kc+wKZmSPHuf5fpsjxLm8WMY7jXb3JjBz34jRG5PjX3tAjOy4tEMl44PjmtBbZ9cXQjJGd33vLENn9tZ7Iqf9yf2vhv8iID2Wfioz5zOnJyKiP1EXSfqA+MZQeGfeBiLTIyPO9JyJjT2dFVMO+Ww+R0W9Gqsj491qSQoSXkhHCTpm8ETAfyTisCH9s+FT1hjP8QeVU7utVK6/aDapVUO1G1SqqdpNqlVS7WbXKqt2iWkS1W1WrotptqlVV7XbVqqlWXbUaqt2hWk3V7lStlmq1VaujWl3V6qlWv3t6iOzpPyFELqPvektfeUvfDZa+Cpa+Gy19FS19N1n6Kln6brb0Vbb03WLpi1j6brX0VbH03Wbpq2rpu93SV83SV93SV8PSd4elr6al705LXy1LX21LXx1LX11LXz1LX/30voyPk7+Bk9N/nthtl4m52w7X6a6zW2PvzMN1dbZHnF18uF53/I5/+yreL5KqxlqzNtnaIxKLzdpkpz2yNtlpj6xNdtoja5Od9iNrkx1KyE228yviSHbf8ePh69FsKFwey6q8N+DYkbBHqIBiD57YT9yIYbem7T0qItgq6fuUm9zsiJN7mkpOttup/c/NLnb+f3ulyg62b4Z91S3x2eoZ92CRuOxObb92azy2rL63qxKHLWHsA2+LzTY394xVY7JNMu0vb4/Fpmbei1aLwaZa9q3V7ewc2x63hpWtat0P32Fj69r3zjUt7LwY++w7M7MpsfbktTKxE2Lu32trbO14v3fC9Qm/z6h7/ZP/MiaHMv2dWH8HzlJnAeoxzlbNIpytqkA4W9UA/9z4draKkpE7R0PCHP/Ps1UNu3tbb1Brsxhnq2bJnK0qqB8ag12Lm69CNmDINJ8g040EmRoFQKZGAjLd5ZNMd3ksE9TafIZM82Vkukg/NAa7FrdYhWzEkGkxQaaKBJkaB0CmxgIyNfFJpiYeywS1tpgh02IZmQrph8Zg1+KWqZCNGTItI8h0E0GmpgGQqamATHf7JNPdHssEtbaMIdMyGZku1g+Nwa7FrVQhmzJkWkmQqRJBpmYBkKmZgEz3+CTTPR7LBLW2kiHTShmZCuuHxmDX4taqkM0YMq0lyHQzQabmAZCpuYBMLXySqYXHMkGtrWXItFZGpkv0Q2Owa3EbVMjmDJk2EGSqTJCpZQBkaikg070+yXSvxzJBrW1gyLRBRib9o3DUxW1WIVsyZNpMkOkWgkzRAMgUFZCplU8ytfJYJqi1zQyZNsvIdKl+aAx2LW6bChllyLSNIFOEIFPrAMjUWkCm+3yS6T6PZYJa28aQaZuMTDpGXdwuFbI1Q6ZdBJluJcjUJgAytRGQqa1PMrX1WCaotV0MmXbJyHSZfmgMdi1urwrZhiHTXoJMVQgytQuATO0EZGrvk0ztPZYJam0vQ6a9MjIV1Q+Nwa7FHVQh2zFkOkiQ6TaCTB0CIFMHAZk6+iRTR49lglo7yJDpoIxMl+uHxmDX4o6okB0YMh0hyFSVIFOnAMjUSUCm+32S6X6PZYJaO8KQ6YiMTMX0Q2Owa3GhWqqAGTLBOBwbDt1OkKlzAGTqLCBTF59k6uKxTFBrUDvUXPh6sz+SUVT4CmNWfbBrcTlVyM4MmXISZKpGkKlrAGTqKiBTN59k6uaxTFBrORky5ZSRqbh+aAx2LS6PCtmVIVMegkzVCTJ1D4BM3QVk6uGTTD08lglqLQ9DpjwyMpXQD43BrsXlUyG7M2TKR5CpBkGmngGQqaeATL18kqmXxzJBreVjyJRPRqYU/dAY7LxHugrZkyFTQYJMdxBk6h0AmXoLyPSATzI94LFMUGsFGTIVlJHpSv3QGOy8E60K2ZshUxGCTDUJMvUJgEx9BGR60CeZHvRYJqi1IgyZisjIVFI/NAY77/enQvZhyFSMINOdBJn6BkCmvgIyPeSTTA95LBPUWjGGTMVkZLpKPzQGO++qpEL2ZchUkiBTLYJM/QIgUz8BmR72SaaHPZYJaq0kQ6aSMjKV0g+Nwc57V6iQ/RgylSHIVJsgU/8AyNRfQKZHfJLpEY9lglorw5CpjIxMV+uHxmDX4sqrkP0ZMpUnyFSHINOAAMg0QECmR32S6VGPZYJaK8+QqbyMTKX1Q2Owa3GVVMgBDJkqEWSqS5ApNQAypQrI9JhPMj3msUxQa5UYMlWSkeka/dAY7LyHtgqZypCpCkGmegSZBgZApoECMj3uk0yPeywT1FoVhkxVZGQqox8ag513KlUhBzJkqkGQqT5BpkEBkGmQgExP+CTTEx7LBLVWgyFTDRmZrtUPjcHO+8GpkIMYMtUhyNSAINPgAMg0WECmJ32S6UmPZYJaq8OQqY6MTGX1Q2Ow86KAKuRghkyNCDI1JMg0JAAyDRGQ6SmfZHrKY5mg1hoxZGokI9N1+qEx2HnpJRVyCEOmZgSZGhFkGhoAmYYKyPS0TzI97bFMUGvNGDI1k5GpnH5oDHZe4EKFHMqQKUqQ6S6CTMMCINMwAZme8UmmZzyWCWotypApKiPT9fqhMdj5NWIVchhDpnYEmRoTZBoeAJmGC8j0rE8yPeuxTFBr7RgytZORqbx+aAx2fllLhRzOkKkzQaYmBJlGBECmEQIyPeeTTM95LBPUWmeGTJ1lZLpBPzQGOz8Sr0KOYMjUkyBTU4JMIwMg00gBmZ73SabnPZYJaq0nQ6aeMjJV0A+Nwc4PHqqQIxky9SXIdDdBplEBkGmUgEwv+CTTCx7LBLXWlyFTXxmZbtQPjcHOj3eokKMYMg0gyNSMINPoAMg0WkCmF32S6UWPZYJaG8CQaYCMTBX1Q2Ow8ySaCjmaIdMggkz3EGQaEwCZxgjI9JJPMr3ksUxQa4MYMg2Skekm/dAY7HyrUoUcw5BpKEGm5gSZxgZAprECMr3sk0wveywT1NpQhkxDZWSqpB8ag50vCFXIsQyZRhBkakGQaVwAZBonINMrPsn0iscyQa2NYMg0Qkamm/VDY7Dzn10VchxDptEEmVoSZBofAJnGC8g0wSeZJngsE9TaaIZMo2VkqqwfGoOdi1MhxzNkGkeQ6V6CTBMDINNEAZle9UmmVz2WCWptHEOmcTIy3XLqP+FJzROyP6kpmf7QHKF4j4b6k5oUjzVvdx+Jw5p38w7HYTPdrDhO5Mz3Yo0d2XKryUgs1nInvZiRbTcKixXZeh+kGJHtt3mJWFn7XSzskWNcpN8aOdY1yG2RY15iOZK5K+YVZC2RY18gM3PkONf/yxQ53uXNIsZxvKs3mZHjXpzGiBz/2ht6ZMelBSIZDxzfnNYiu74YmjGy83tvGSK7v9YTOfVf7m8t/BcZ8aHsU5Exnzk9GRn1kbpI2g/UJ4bSI+M+EJEWGXm+90Rk7OmsiGrYd+shMvrNSBUZ/15LUojwUjJC2CmTNwLmIxmHFeGPDZ+q3nCGP2iSyv2aapNVe121Kaq9odpU1d5UbZpqb6k2XbW3VZuh2juqzVTtXdVmqfaearNVm6PaXNXmqTZftQWqLVTtfdUWqfaBaotV+7B7eojs6T8hRC6j7zVL32RL3+uWvimWvjcsfVMtfW9a+qZZ+t6y9E239L1t6Zth6XvH0jfT0veupW+Wpe89S99sS98cS99cS988S998S98CS99CS9/7lr5Flr4PLH2LLX0fpvdlfJw8Tk7/eXK3Pc++2w4v6J6JTYmxMw8vzMROiLWLD79vsmVi7vjDiwx2a+xXB+EPdLZHnFcS4cUaWzveq47wh5mfh9hX9i4SZv3iixh/N1kvCrRHJBab9aIg7ZH1oiDtkfWiIO2R9aIg7UfWi4JQQr4ocP07OgnJ7jt+PPwamg2FJ2NZlfd1HDsS9ghTUOzBE/uJNzDs1rS9x1QEWyV9n/Kmmx1xck8zzcl2O7X/ecvFzv9vrzTdwfbNsK96Oz5bPeMebEZcdqe2X3snHltW39vNjMOWMPaB78Zmm5t7xlkx2SaZ9pfvxWJTM+9FZ8dgUy371jl2do5tjzvXyla17ofn2di69r3zfMLvB+re+eS/NMkh699J5t8p6izARMbZqkmEs1VRwtmqJfjnxrezVZSM3Dk+Iszx/zxb9RFxbdR6g1qbxDhbNUnmbFVEPzQGuxY3VYWcxJBpKkGmVgSZlgZApqUCMn3sk0wfeywT1NpUhkxTZWS6VT80BrsWN0OFnMyQaQZBptYEmZYFQKZlAjJ94pNMn3gsE9TaDIZMM2RkqqIfGoNdi5utQk5hyDSbINN9BJmWB0Cm5QIyfeqTTJ96LBPU2myGTLNlZLpNPzQGuxa3UIWcypBpIUGmNgSZVgRAphUCMn3mk0yfeSwT1NpChkwLZWSqqh8ag50v+FXIaQyZlhBkakuQaWUAZFopINPnPsn0uccyQa0tYci0REam2/VDY7BzW6VCTmfItJwgUzuCTKsCINMqAZlW+yTTao9lglpbzpBpuYxM1fRDY7CzeFXIGQyZVhFkak+QaU0AZFojINMXPsn0hccyQa2tYsi0Skam6vqhMdi1uHUq5EyGTOsIMnUgyLQ2ADKtFZDpS59k+tJjmaDW1jFkWicjUw390BjsWtxGFXIWQ6aNBJk6EmRaFwCZ1gnI9JVPMn3lsUxQaxsZMm2UkekO/dAY7FrcFhVyNkOmLQSZOhFkWh8AmdYLyPS1TzJ97bFMUGtbGDJtkZGppn5oDHYtbrsKOZch03aCTPcTZNoQAJk2CMj0jU8yfeOxTFBr2xkybZeR6U790BjsWtxuFXI+Q6bdBJk6E2TaGACZNgrI9K1PMn3rsUxQa7sZMu2WkamWfmgMdi1uvxq+kCHTfoJMXQgybQqATJsEZPrOJ5m+81gmqLX9DJn2y8hUWz80BrsWd0iFXMSQ6RBBpq4EmTYHQKbNAjJ975NM33ssE9TaIYZMh2RkqqMfGoNdizuqQi5myHSUIFM3gkxbAiDTFgGZfvBJph88lglq7ShDpqMyMtXVD43BrsVlU/+wLWHIBONwbDjUnSDT1gDItFVAph99kulHj2WCWoPaoebC15v9kYyiwvX0Q2Owa3G5VMilDJlyEWTqQZBpWwBk2iYg008+yfSTxzJBreViyJRLRqb6+qEx2LW4vCrkMoZMeQky9STItD0AMm0XkOlnn2T62WOZoNbyMmTKKyNTA/3QGOxaXH4VcjlDpvwEmXoRZNoRAJl2CMi00yeZdnosE9RafoZM+WVkaqgfGoNdiyukQq5gyFSIIFNvgky7AiDTLgGZfvFJpl88lglqrRBDpkIyMjXSD43BrsUlq5ArGTIlE2R6gCDT7gDItFtApl99kulXj2WCWktmyJQsI9Nd+qEx2LW44irkKoZMxQky9SHItCcAMu0RkOk3n2T6zWOZoNaKM2QqLiNTY/3QGOxaXCkVcg1DplIEmR4kyLQ3ADLtFZBpn08y7fNYJqi1UgyZSsnI1EQ/NAa7FldWhVzLkKksQaa+BJn2B0Cm/QIy/e6TTL97LBPUWlmGTGVlZGqqHxqDXYuroEKuY8hUgSDTQwSZDgRApgMCMv3hk0x/eCwT1FoFhkwVZGS6Wz80BrsWV1mFXM+QqTJBpn4EmQ4GQKaDAjL96ZNMf3osE9RaZYZMlWVkaqYfGoNdi6uqQm5gyFSVINPDBJkOBUCmQwIy/eWTTH95LBPUWlWGTFVlZLpHPzQGuxZXU4XcyJCpJkGm/gSZDgdApsMCMv3tk0x/eywT1FpNhkw1ZWRqrh8ag12Lq6dCbmLIVI8g0yMEmY4EQKYjAjL945NM/3gsE9RaPYZM9WRkaqEfGoNdi2usQm5myNSYINMAgkxHAyDTUQGZ/vVJpn89lglqrTFDpsYyMrXUD43BrsU1VyG3MGRqTpDpUYJMxwIg0zEBmY77JNNxj2WCWmvOkKm5jEz36ofGYNfiWquQWxkytSbIlEqQKdQj8WWiZPxvEG2OcA9/ZAr38FYmqLXWDJlay8gU1Q+Nwa7FdVAhtzFk6kCQ6TGCTNkCIFM2AZmy+yRTdo9lglrrwJCpg4xMrfRDY7Dzrt4q5HaGTF0JMg0kyJQjADLlEJDpDJ9kOsNjmaDWujJk6iojU2v90BjsWlxvFXIHQ6beBJkeJ8iUMwAy5RSQ6UyfZDrTY5mg1nozZOotI9N9+qEx2LW4firkLoZM/QgyDSLIlCsAMuUSkOksn2Q6y2OZoNb6MWTqJyNTG/3QGOxaXKoKuZshUypBpicIMuUOgEy5BWQ62yeZzvZYJqi1VIZMqTIytdUPjcGuxQ1WIfcwZBpMkGkwQaY8AZApj4BM5/gk0zkeywS1Npgh02AZmdrph8Zg1+KGqZB7GTINI8j0JEGmvAGQKa+ATOf6JNO5HssEtTaMIdMwGZnan/pPeFLzhOxPakqmPzRHKN7jI/3kXVI81rzdfSQOa97NOxyHzXSz4jiRM9+LNXZky60mI7FYy530Yka23SgsVmTrfZBiRLbf5iViZe13sbBHjnGRfmvkWNcgt0WOeYnlSOaumFeQtUSOfYHMzJHjXP8vU+R4lzeLGMfxrt5kRo57cRojcvxrb+iRHZcWiGQ8cHxzWovs+mJoxsjO771liOz+Wk/k1H+5v7XwX2TEh7JPRcZ85vRkZNRH6iJpP1CfGEqPjPtARFpk5PneE5Gxp7MiqmHfrYfI6DcjVWT8ey1JIcJLyQhhp0zeCJiPZBxWhD82fKp6wxn+oCSV+zzV8ql2vmr5VbtAtQKqXahaQdUuUq2QaherVli1S1QrotqlsGbVLlOtqGqXq1ZMtStUK65aCdVSVLtStZKqXaVaKdWu7pEeInv6TwiRy+g7z9KXz9J3vqUvv6XvAktfAUvfhZa+gpa+iyx9hSx9F1v6Clv6LrH0FbH0XWrpS7b0XWbpK2rpu9zSV8zSd4Wlr7ilr4SlL8XSd6Wlr6Sl7ypLXylL39XpfRkfJ4+T03+e3G3Ps++2wyV6ZGJTYuzMwymZ2AmxdvHhK022TMwdf7ikwW6N/eogfJXO9ojzSiJcSmNrx3vVEb468/MQ8xXKM0XCrF98EePvJutFgfaIxGKzXhSkPbJeFKQ9sl4UpD2yXhSk/ch6URBKyBcFrn9Hk5DsvuPHw+eh2VA4H5ZVec/HsSNhj5AfxR48sZ+4AMNuTdt7FECwVdL3KRe62REn9zQFnWy3U/ufi1zs/P/2SoUcbN8M+6qL47PVM+7BCsdld2r7tUvisWX1vV2ROGwJYx94aWy2ublnTI7JNsm0v7wsFpuaeS9aNAabatm3Xm5n59j2uMWsbFXrfvgKG1vXvncuTvj9QN07n/yXJjlk/TvJ9DtlpDoLsJ9xtmok4WzVEMLZqtL458a3s1WUjNw5rvHpbNU1xLVR6w1qbSTjbNVImbNVHfRDY7BrcWNUyAMMmcYQZHqKIFOZAMhURkCma32S6VqPZYJaG8OQaYyMTB31Q2Owa3HjVciDDJnGE2QaSpCpbABkKisg03U+yXSdxzJBrY1nyDReRqZO+qEx2LW4ySrkIYZMkwkyPU2QqVwAZConINP1Psl0vccyQa1NZsg0WUam+/VDY7BrcdNUyMMMmaYRZBpGkKl8AGQqLyDTDT7JdIPHMkGtTWPINE1Gps76oTHYtbiZKuQRhkwzCTI9Q5CpQgBkqiAg040+yXSjxzJBrc1kyDRTRqYu+qEx2LW4uSrkUYZMcwkyDSfIVDEAMlUUkOkmn2S6yWOZoNbmMmSaKyNTV/3QGOxa3CIV8hhDpkUEmZ4lyFQpADJVEpDpZp9kutljmaDWFjFkWiQjUzf90BjsvIe2ChmK0mVaSpBpBEGmygGQqbKATLf4JNMtHssEtbaUIdNSGZm664fGYOedSlXIbFG6TCsIMj1HkCkSAJkiAjLd6pNMt3osE9TaCoZMK2Rk6qEfGoOd94NTIXNE6TKtIcg0kiBTlQDIVEVAptt8kuk2j2WCWlvDkGmNjEw99UNjsPOuOypkzihdpvUEmZ4nyFQ1ADJVFZDpdp9kut1jmaDW1jNkWi8jUy/90BjsvLeBCpkrSpdpE0GmUQSZqgVApmoCMlX3SabqHssEtbaJIdMmGZl664fGYOcVpFXI3FG6TFsJMr1AkKlGAGSqISDTHT7JdIfHMkGtbWXItFVGpgf0Q2Ow8zqdKmSeKF2mHQSZRhNkqhkAmWoKyHSnTzLd6bFMUGs7GDLtkJGpj35oDHZeDU2FzBuly7SHINOLBJlqBUCmWgIy1fZJptoeywS1toch0x4ZmR7UD43Bzo/Eq5BJUbpMBwgyjSHIVCcAMtURkKmuTzLV9VgmqLUDDJkOyMjUVz80Bjs/eKhC5ovSZTpMkOklgkz1AiBTPQGZ6vskU32PZYJaO8yQ6bCMTA/ph8Zg58c7VMj8UbpMxwgyjSXI1CAAMjUQkKmhTzI19FgmqLVjDJmOycjUTz80BjtPotUJhQpE6TLBOBwbDr1MkKlRAGRqJCDTXT7JdJfHMkGtQe1Qc+Hrzf5IRlHhh/VDY7DzrUoVsmCULlNugkzjCDI1DoBMjQVkauKTTE08lglqLTdDptwyMvXXD43BzheEKmShKF2mJIJMrxBkahoAmZoKyHS3TzLd7bFMUGtJDJmSZGR6RD80Bjv/2VUhC0fpMhUgyDSeIFOzAMjUTECme3yS6R6PZYJaK8CQqYCMTAP0Q2Owc3EqZJEoXabCBJkmEGRqHgCZmgvI1MInmVp4LBPUWmGGTIVlZHpUPzQGuxZXFEJG6TIVJcg0kSBTywDI1FJApnt9kulej2WCWivKkKmojEyp+qEx2LW4FBWyaJQuUwpBplcJMkUDIFNUQKZWPsnUymOZoNZSGDKlyMj0mH5oDHZeQVWFLBaly1SaINMkgkytAyBTawGZ7vNJpvs8lglqrTRDptIyMg3UD43BzuvUqZDFo3SZyhFkeo0gU5sAyNRGQKa2PsnU1mOZoNbKMWQqJyPT4/qhMdh5NSAVMiVKl6kiQabJBJnaBUCmdgIytfdJpvYeywS1VpEhU0UZmQbph8Zg5zUXVMiSUbpMEYJMrxNk6hAAmToIyNTRJ5k6eiwT1FqEIVNERqYn9ENjsPObrSpkqShdpmoEmaYQZOoUAJk6Cch0v08y3e+xTFBr1RgyVZORabB+aAx2fn9IhSwdpctUiyDTGwSZOgdAps4CMnXxSaYuHssEtVaLIVMtGZme1A+Nwc5PaauQZaJ0mRoQZJpKkKlrAGTqKiBTN59k6uaxTFBrDRgyNZCRaYh+aAx2fhZOhSwbpcvUlCDTmwSZugdApu4CMvXwSaYeHssEtdaUIVNTGZme0g+Nwc5PHKiQ5aJ0mVoSZJpGkKlnAGTqKSBTL59k6uWxTFBrLRkytZSRaah+aAx2ntdRIctH6TK1Icj0FkGm3gGQqbeATA/4JNMDHssEtdaGIVMbGZme1g+Nwc53z1TIClG6TJ0IMk0nyNQnADL1EZDpQZ9ketBjmaDWOjFk6iQj0zD90BjsfI2iQlaM0mXqTpDpbYJMfQMgU18BmR7ySaaHPJYJaq07Q6buMjI9ox8ag53/EqiQlaJ0mfoQZJpBkKlfAGTqJyDTwz7J9LDHMkGt9WHI1EdGpuH6oTHYtbj+KmTlKF2m/gSZ3iHI1D8AMvUXkOkRn2R6xGOZoNb6M2TqLyPTs6f+E57UPCH7k5qS6Q/NEYr3uEZ/UpPisebt7iNxWPNu3uE4bKabFceJnPlerLEjW241GYnFWu6kFzOy7UZhsSJb74MUI7L9Ni8RK2u/i4U9coyL9Fsjx7oGuS1yzEssRzJ3xbyCrCVy7AtkZo4c5/p/mSLHu7xZxDiOd/UmM3Lci9MYkeNfe0OP7Li0QCTjgeOb01pk1xdDM0Z2fu8tQ2T313oip/7L/a2F/yIjPpR9KjLmM6cnI6M+UhdJ+4H6xFB6ZNwHItIiI8/3noiMPZ0VUQ37bj1ERr8ZqSLj32tJChFeSkYIO2XyRsB8JOOwIvyx4VPVG87wBw1QuR9VLVW1x1QbqNrjqg1S7QnVBqv2pGpDVHtKtaGqPa3aMNWeUW24as+qNkK151Qbqdrzqo1S7QXVRqv2ompjVHtJtbGqvdwjPUT29J8QIpfR96ilL9XS95ilb6Cl73FL3yBL3xOWvsGWvictfUMsfU9Z+oZa+p629A2z9D1j6Rtu6XvW0jfC0vecpW+kpe95S98oS98Llr7Rlr4XLX1jLH0vWfrGWvpeTu/L+Dh5nJz+8+Rue559tx1+oUcmNiXGzjw8OhM7IdYuPvyiyZaJueMPjzHYrbFfHYRf0tkecV5JhMdqbO14rzrCL2d+HmK+QpleJMz6xRcx/m6yXhRoj0gsNutFQdoj60VB2iPrRUHaI+tFQdqPrBcFoYR8UeD6d3QAkt13/Hj4UTQbCqdiWZX3MRw7EvYIA1HswRP7iccx7Na0vccgBFslfZ/yhJsdcXJPM9jJdju1/3nSxc7/b680xMH2zbCveio+Wz3jHmxoXHantl97Oh5bVt/bDYvDljD2gc/EZpube8bhMdkmmfaXz8ZiUzPvRUfEYFMt+9bn7Owc2x53pJWtat0PP29j69r3zqMIvx+oe+eT/9Ikh6x/J5l+pwxUZwEiUfrZqoGEs1UzCWerxuGfG9/OVlEycud4hTDH//Ns1SvEtVHrDWptIONs1UCZs1Uj9ENjsGtxQ1TIKlG6TEMIMr1LkGl8AGQaLyDTBJ9kmuCxTFBrQxgyDZGR6Tn90BjsWtxwFbJqlC7TcIJMswgyTQyATBMFZHrVJ5le9VgmqLXhDJmGy8g0Uj80BrsWN0qFrBalyzSKINN7BJkmBUCmSQIyveaTTK95LBPU2iiGTKNkZHpePzQGuxY3VoWsEaXLNJYg02yCTJMDINNkAZle90mm1z2WCWptLEOmsTIyjdIPjcHObZUKWTNKl2kiQaY5BJmmBECmKQIyveGTTG94LBPU2kSGTBNlZHpBPzQGO4tXhawVpcs0hSDTXIJMUwMg01QBmd70SaY3PZYJam0KQ6YpMjLp5URd3HQVsk6ULtN0gkzzCDJNC4BM0wRkessnmd7yWCaotekMmabLyPSifmgMdi1ulgpZL0qXaRZBpvkEmaYHQKbpAjK97ZNMb3ssE9TaLIZMs2RkGqMfGoNdi5uvQjaI0mWaT5BpAUGmGQGQaYaATO/4JNM7HssEtTafIdN8GZle0g+Nwa7FLVYhG0XpMi0myLSQINPMAMg0U0Cmd32S6V2PZYJaW8yQabGMTGP1Q2Owa3HLVMjGUbpMywgyvU+QaVYAZJolINN7Psn0nscyQa0tY8i0TEaml/VDY7BrcStVyKZRukwrCTItIsg0OwAyzRaQaY5PMs3xWCaotZUMmVbKyDROPzQGuxa3VoVsFqXLtJYg0wcEmeYGQKa5AjLN80mmeR7LBLW2liHTWhmZXtEPjcGuxW1QIZtH6TJtIMi0mCDT/ADINF9ApgU+ybTAY5mg1jYwZNogI9N4/dAY7FrcZhWyZZQu02aCTB8SZFoYAJkWCsj0vk8yve+xTFBrmxkybZaRaYJ+aAx2LW6bChmN0mXaRpBpCUGmRQGQaZGATB/4JNMHHssEtbaNIdM2GZkm6ofGYNfidqmQraN0mXYRZPqIINPiAMi0WECmD32S6UOPZYJa28WQaZeMTK/qh8Zg1+L2qpBtonSZ9hJkWkqQaUkAZFoiINNHPsn0kccyQa3tZci0V0amSfqhMdi1uIMqZLsoXaaDBJk+Jsi0NAAyLRWQ6WOfZPrYY5mg1g4yZDooI9Nr+qEx2LW4IypkhyhdpiMEmZYRZFoWAJmWCcj0iU8yfeKxTFBrRxgyHZGRabJ+aAx2LS5UNxTqFKXLBONwbDj0CUGm5QGQabmATJ/6JNOnHssEtQa1Q82Frzf7IxlFhV83ZtUHuxaXU4XsHKXLlJMg03KCTCsCINMKAZk+80mmzzyWCWotJ0OmnDIyTdEPjcGuxeVRIbtG6TLlIcj0KUGmlQGQaaWATJ/7JNPnHssEtZaHIVMeGZne0A+Nwa7F5VMhu0fpMuUjyLSCINOqAMi0SkCm1T7JtNpjmaDW8jFkyicj01T90BjsWlxBFbJnlC5TQYJMnxFkWhMAmdYIyPSFTzJ94bFMUGsFGTIVlJHpTf3QGOxaXBEVsneULlMRgkwrCTKtDYBMawVk+tInmb70WCaotSIMmYrIyDRNPzQGuxZXTIXsE6XLVIwg0+cEmdYFQKZ1AjJ95ZNMX3ksE9RaMYZMxWRkeks/NAa7FldShewbpctUkiDTKoJM6wMg03oBmb72SaavPZYJaq0kQ6aSMjJN1w+Nwa7FlVEh+0XpMpUhyLSaINOGAMi0QUCmb3yS6RuPZYJaK8OQqYyMTG/rh8Zg1+LKq5D9o3SZyhNkWkOQaWMAZNooINO3Psn0rccyQa2VZ8hUXkamGfqhMdi1uEoq5IAoXaZKBJm+IMi0KQAybRKQ6TufZPrOY5mg1ioxZKokI9M7+qEx2HmLDxUyNUqXqQpBprUEmTYHQKbNAjJ975NM33ssE9RaFYZMVWRkmqkfGoOdF1JXIQdG6TLVIMj0JUGmLQGQaYuATD/4JNMPHssEtVaDIVMNGZne1Q+Nwc7L1aqQg6J0meoQZFpHkGlrAGTaKiDTjz7J9KPHMkGt1WHIVEdGpln6oTHYeVFAFXJwlC5TI4JMXxFk2hYAmbYJyPSTTzL95LFMUGuNGDI1kpHpPf3QGOy89JIKOSRKl6kZQab1BJm2B0Cm7QIy/eyTTD97LBPUWjOGTM1kZJqtHxqDnRe4UCGHRukyRQkyfU2QaUcAZNohINNOn2Ta6bFMUGtRhkxRGZnm6IfGYOfXiFXIYVG6TO0IMm0gyLQrADLtEpDpF59k+sVjmaDW2jFkaicj01z90Bjs/LKWCjk8SpepM0Gmbwgy7Q6ATLsFZPrVJ5l+9VgmqLXODJk6y8g079R/wpOaJ2R/UlMy/aE5QvEer+hPalI81rzdfSQOa97NOxyHzXSz4jiRM9+LNXZky60mI7FYy530Yka23SgsVmTrfZBiRLbf5iViZe13sbBHjnGRfmvkWNcgt0WOeYnlSOaumFeQtUSOfYHMzJHjXP8vU+R4lzeLGMfxrt5kRo57cRojcvxrb+iRHZcWiGQ8cHxzWovs+mJoxsjO771liOz+Wk/k1H+5v7XwX2TEh7JPRcZ85vRkZNRH6iJpP1CfGEqPjPtARFpk5PneE5Gxp7MiqmHfrYfI6DcjVWT8ey1JIcJLyQhhp0zeCJiPZBxWhD82fKp6wxn+oD0q92+q7VVtn2r7VftdtQOq/aHaQdX+VO2Qan+pdli1v1U7oto/qh1V7V/Vjql2XLVQT/Xnq5ZNteyq5VDtDNVyqnamarlUO6tneojs6T8hRC6j7zdL315L3z5L335L3++WvgOWvj8sfQctfX9a+g5Z+v6y9B229P1t6Tti6fvH0nfU0vevpe+Ype+4pQ/+Es2+sKUvm6Uvu6Uvh6XvDEtfTkvfmZa+XJa+s9L7Mj5O/gZOTv95YrddJuZuOwzzZ2S3xt6Zh8/U2R5xdvHhXD3xO/4Oq3m/SHLZ1po2zxxbppA1U1Vr/rCNrWtfazYLOy/G85I9M5sS6znMkYmdEPP5PkNja8d7vsNnEf5uVhYJs/5uKht/N1kvgLRHJBab9QIo7ZH1AijtkfUCKO2R9QIo7UfWC6BQQr4Acv07ugfJ7jt+PPwbmg2F92JZlXcfjh0Je4T9KPbgif3E7xh2a9re4wCCrZK+T/nDzY44uac56GS7ndr//Oli5/+3VzrkYPtm2Ff9FZ+tnnEPdjguu1Pbr/0djy2r7+2OxGFLGPvAf2Kzzc0949GYbJNM+8t/Y7Gpmfeix2KwqZZ963GCm4TXFGHqHvfkvwjJocy5rdfBUWcmRkTpZ9B6Es6gbSScQcvdE53BtzNolIzcOc4mzPH/PIN2NnFt1HqDWuvJOIPWU+YM2nz90BjsvNqACjkySpepL0Gmbwky5QmATHkEZDrHJ5nO8VgmqLW+DJn6ysi0QD80Bju/06lCjorSZRpAkGkTQaa8AZApr4BM5/ok07keywS1NoAh0wAZmRbqh8Zg5zdnVMjRUbpMgwgyfUeQKSkAMiUJyHSeTzKd57FMUGuDGDINkpHpff3QGOz8fLIKOSZKl2koQabNBJnyBUCmfAIyne+TTOd7LBPU2lCGTENlZFqkHxqDnS8IVcixUbpMIwgyfU+QKX8AZMovINMFPsl0gccyQa2NYMg0QkamD/RDY7Dzn10VclyULtNogkxbCDIVCIBMBQRkutAnmS70WCaotdEMmUbLyLRYPzQGOxenQo6P0mUaR5DpB4JMBQMgU0EBmS7ySaaLPJYJam0cQ6ZxMjJ9qB8ag12Lm6RCTozSZZpEkGkrQaZCAZCpkIBMF/sk08UeywS1Nokh0yQZmZboh8Zg1+KmqpCTonSZphJk+pEgU+EAyFRYQKZLfJLpEo9lglqbypBpqoxMH+mHxmDX4maokJOjdJlmEGTaRpCpSABkKiIg06U+yXSpxzJBrc1gyDRDRqal+qEx2LW42SrklChdptkEmX4iyJQcAJmSBWS6zCeZLvNYJqi12QyZZsvI9LF+aAx2LW6hCjk1SpdpIUGm7QSZigZApqICMl3uk0yXeywT1NpChkwLZWRaph8ag12LW6JCTovSZVpCkOlngkzFAiBTMQGZrvBJpis8lglqbQlDpiUyMn2iHxqDXYtbrkJOj9JlWk6QaQdBpuIBkKm4gEwlfJKphMcyQa0tZ8i0XEam5fqhMdh533YVckaULtMqgkw7CTKlBECmFAGZrvRJpis9lglqbRVDplUyMn2qHxqDnXfHVSFnRukyrSPItIsgU8kAyFRSQKarfJLpKo9lglpbx5BpnYxMK/RDY7DzHoQq5KwoXaaNBJl+IchUKgAylRKQ6WqfZLraY5mg1jYyZNooI9Nn+qEx2HmnJxVydpQu0xaCTLsJMpUOgEylBWS6xieZrvFYJqi1LQyZtsjItFI/NAY776ehQs6N0mXaTpDpV4JMZQIgUxkBma71SaZrPZYJam07Q6btMjJ9rh8ag51XLVch50fpMu0myLSHIFPZAMhUVkCm63yS6TqPZYJa282QabeMTKv0Q2Owa3H7VciFUbpM+wky/UaQqVwAZConINP1Psl0vccyQa3tZ8i0X0am1fqhMdi1uEMq5KIoXaZDBJn2EmQqHwCZygvIdINPMt3gsUxQa4cYMh2SkWmNfmgMdi3uqAq5OEqX6ShBpn0EmSoEQKYKAjLd6JNMN3osE9TaUYZMR2Vk+kI/NAa7FpetXii0JEqXCcbh2HBoP0GmigGQqaKATDf5JNNNHssEtQa1Q82Frzf7IxlFhdfqh8Zg1+JyqZBLo3SZchFk+p0gU6UAyFRJQKabfZLpZo9lglrLxZApl4xMX+qHxmDndepUyGVRukx5CTIdIMhUOQAyVRaQ6RafZLrFY5mg1vIyZMorI9M6/dAY7LwakAq5PEqXKT9Bpj8IMkUCIFNEQKZbfZLpVo9lglrLz5Apv4xMX+mHxmDnNRdUyBVRukyFCDIdJMhUJQAyVRGQ6TafZLrNY5mg1goxZCokI9N6/dAY7Pxmqwq5MkqXKZkg058EmaoGQKaqAjLd7pNMt3ssE9RaMkOmZBmZvtYPjcHO7w+pkKuidJmKE2Q6RJCpWgBkqiYgU3WfZKrusUxQa8UZMhWXkWmDfmgMdn5KW4VcE6XLVIog018EmWoEQKYaAjLd4ZNMd3gsE9RaKYZMpWRk+kY/NAY7PwunQq6N0mUqS5DpMEGmmgGQqaaATHf6JNOdHssEtVaWIVNZGZk26ofGYOcnDlTIdVG6TBUIMv1NkKlWAGSqJSBTbZ9kqu2xTFBrFRgyVZCR6Vv90BjsPK+jQq6P0mWqTJDpCEGmOgGQqY6ATHV9kqmuxzJBrVVmyFRZRqZN+qEx2PnumQq5IUqXqSpBpn8IMtULgEz1BGSq75NM9T2WCWqtKkOmqjIyfacfGoOdr1FUyI1Rukw1CTIdJcjUIAAyNRCQqaFPMjX0WCaotZoMmWrKyLRZPzQGO/8lUCE3Reky1SPI9C9BpkYBkKmRgEx3+STTXR7LBLVWjyFTPRmZvtcPjcGuxTVWITdH6TI1Jsh0jCBT4wDI1FhApiY+ydTEY5mg1hozZGosI9MW/dAY7FpccxVyS5QuU3OCTMcJMjUNgExNBWS62yeZ7vZYJqi15gyZmsvI9MOp/4QnNU/I/qSmZPpDc4TiPc7Wn9SkeKx5u/tIHNa8m3c4DpvpZsVxIme+F2vsyJZbTUZisZY76cWMbLtRWKzI1vsgxYhsv81LxMra72JhjxzjIv3WyLGuQW6LHPMSy5HMXTGvIGuJHPsCmZkjx7n+X6bI8S5vFjGO4129yYwc9+I0RuT4197QIzsuLRDJeOD45rQW2fXF0IyRnd97yxDZ/bWeyKn/cn9r4b/IiA9ln4qM+czpycioj9RF0n6gPjGUHhn3gYi0yMjzvSciY09nRVTDvlsPkdFvRqrI+PdakkKEl5IRwk6ZvBEwH8k4rAh/bPhU9YYz/EHNVO57VGuuWgvVWqp2r2pR1Vqp1lq1+1Rro1pb1dqp1l61Dqp1VK2Taver1lm1Lqp1Va2bat1V66FaT9V6qdZbtQdU66Pagz3TQ2RP/wkhchl991j6mlv6Wlj6Wlr67rX0RS19rSx9rS1991n62lj62lr62ln62lv6Olj6Olr6Oln67rf0dbb0dbH0dbX0dbP0dbf09bD09bT09bL09bb0PWDp62PpezC9L+Pj5G/g5PSfJ3bbZWLutsO9e+rs1tg78/ADOtsjzi4+3Kcnfsf/1GreL5JctrWmzTPHlqmrNVNVa/5uNraufa3dLey8GM9Lj8xsSqznsGcmdkLM57uXxtaO93yHHyT83ewqEmb93VQ2/m6yXgBpj0gsNusFUNoj6wVQ2iPrBVDaI+sFUNqPrBdAoYR8AeT6d7QZkt13/Hj4HjSr3vXEsipvCxw7EvYILVHswRP7iXsx7Na0vUcUwVZJ36e0crMjTu5pWjvZbqf2P/e52Pn/7ZXaONi+GfZVbeOz1TPuwdrFZXdq+7X28diy+t6uQxy2hLEP7BibbW7uGTvFZJtk2l/eH4tNzbwX7RyDTbXsW7sQ3CS8pghT97gn/0VIDmXObXO/db1QaGuUfgatNeEMWqg9Pk9f/PPo2xk0SkbuHA8R5vh/nkF7iLg2ar1BrbVmnEHD15v9kYyiwlv1Q2Owa3EdVMhtUbpMHQgyhQky9QuATP0EZHrYJ5ke9lgmqLUODJk6yMj0o35oDHYtrqsKuT1Kl6krQaZsBJn6B0Cm/gIyPeKTTI94LBPUWleGTF1lZNqmHxqDXYvrrULuiNJl6k2QKTtBpgEBkGmAgEyP+iTTox7LBLXWmyFTbxmZftIPjcHObZUKuStKl6kfQaYcBJlSAyBTqoBMj/kk02MeywS11o8hUz8Zmbbrh8ZgZ/GqkLujdJlSCTKdQZBpYABkGigg0+M+yfS4xzJBraUyZEqVkeln/dAY7FrcYBVyT5Qu02CCTDkJMg0KgEyDBGR6wieZnvBYJqi1wQyZBsvItEM/NAa7FjdMhdwbpcs0jCDTmQSZBgdApsECMj3pk0xPeiwT1NowhkzDZGTaqR8ag12LG6lC7o/SZRpJkCkXQaYhAZBpiIBMT/kk01MeywS1NpIh00gZmXbph8Zg1+LGqJAHonSZxhBkOosg09AAyDRUQKanfZLpaY9lglobw5BpjIxMv+iHxmDX4sarkAejdJnGE2TKTZBpWABkGiYg0zM+yfSMxzJBrY1nyDReRqbd+qEx2LW4ySrkoShdpskEmc4myDQ8ADINF5DpWZ9ketZjmaDWJjNkmiwj06/6oTHYtbhpKuThKF2maQSZ8hBkGhEAmUYIyPScTzI957FMUGvTGDJNk5Fpj35oDHYtbqYKeSRKl2kmQaZzCDKNDIBMIwVket4nmZ73WCaotZkMmWbKyPSbfmgMdi1urgp5NEqXaS5BprwEmUYFQKZRAjK94JNML3gsE9TaXIZMc2Vk2qsfGoNdi1ukQh6L0mVaRJDpXIJMowMg02gBmV70SaYXPZYJam0RQ6ZFMjLt0w+Nwc77equQoVZ0mZYSZEoiyDQmADKNEZDpJZ9kesljmaDWljJkWioj03790BjsvHuqCpmNIdMKgkznEWQaGwCZxgrI9LJPMr3ssUxQaysYMq2Qkel3/dAY7LxHnQqZgyHTGoJM+QgyjQuATOMEZHrFJ5le8VgmqLU1DJnWyMh0QD80BjvvBKRC5mTItJ4g0/kEmcYHQKbxAjJN8EmmCR7LBLW2niHTehmZ/tAPjcHO+y2okLkYMm0iyJSfINPEAMg0UUCmV32S6VWPZYJa28SQaZOMTAf1Q2Ow8wIXKmRuhkxbCTJdQJBpUgBkmiQg02s+yfSaxzJBrW1lyLRVRqY/9UNjsPNrxCpkHoZMOwgyFSDINDkAMk0WkOl1n2R63WOZoNZ2MGTaISPTIf3QGOz8spYKmZch0x6CTBcSZJoSAJmmCMj0hk8yveGxTFBrexgy7ZGR6S/90Bjs/Ei8CpnEkOkAQaaCBJmmBkCmqQIyvemTTG96LBPU2gGGTAdkZDqsHxqDnR88VCHzMWQ6TJDpIoJM0wIg0zQBmd7ySaa3PJYJau0wQ6bDMjL9rR8ag50f71Ah8zNkOkaQqRBBpukBkGm6gExv+yTT2x7LBLV2jCHTMRmZjuiHxmDnSbT6oVABhkwwDseGQxcTZJoRAJlmCMj0jk8yveOxTFBrUDvUXPh6sz+SUVT4H/3QGOx8q1KFLMiQKTdBpsIEmWYGQKaZAjK965NM73osE9RaboZMuWVkOqofGoOdLwhVyEIMmZIIMl1CkGlWAGSaJSDTez7J9J7HMkGtJTFkSpKR6V/90Bjs/GdXhSzMkKkAQaYiBJlmB0Cm2QIyzfFJpjkeywS1VoAhUwEZmY7ph8Zg5+JUyCIMmQoTZLqUINPcAMg0V0CmeT7JNM9jmaDWCjNkKiwj03H90BjsWlxRCMmQqShBpmSCTPMDINN8AZkW+CTTAo9lglorypCpqIhM2YxZjcGuxaWokEUZMqUQZLqMINPCAMi0UECm932S6X2PZYJaS2HIlCIjU1if1RjsWlxpFbIYQ6bSBJmKEmRaFACZFgnI9IFPMn3gsUxQa6UZMpWWkUn/p4m6uHIqZHGGTOUIMl1OkGlxAGRaLCDThz7J9KHHMkGtlWPIVE5GJv0ppC6uogqZwpCpIkGmYgSZlgRApiUCMn3kk0wfeSwT1FpFhkwVZWTKoc9qDHYtLqJClmTIFCHIdAVBpqUBkGmpgEwf+yTTxx7LBLUWYcgUkZHpDH1WY7BrcdVUyFIMmaoRZCpOkGlZAGRaJiDTJz7J9InHMkGtVWPIVE1Gppz6rMZg1+JqqZClGTLVIshUgiDT8gDItFxApk99kulTj2WCWqvFkKmWjExnnvpPeFLzhOxPakqmPzRHKN7jIf1JTYrHmre7j8Rhzbt5h+OwmW5WHCdy5nuxxo5sudVkJBZruZNezMi2G4XFimy9D1KMyPbbvESsrP0uFvbIMS7Sb40c6xrktsgxL7EcydwV8wqylsixL5CZOXKc6/9lihzv8mYR4zje1ZvMyHEvTmNEjn/tDT2y49ICkYwHjm9Oa5FdXwzNGNn5vbcMkd1f64mc+i/3txb+i4z4UPapyJjPnJ6MjPpIXSTtB+oTQ+mRcR+ISIuMPN97IjL2dFZENey79RAZ/Wakiox/ryUpRHgpGSHslMkbAfORjMOK8MeGT1VvOMMftELl/ky1lap9rtoq1Vartka1L1Rbq9qXqq1T7SvV1qv2tWobVPtGtY2qfavaJtW+U22zat+rtkW1H1TbqtqPqm1T7SfVtqv2c8/0ENnTf0KIXEbfZ5a+lZa+zy19qyx9qy19ayx9X1j61lr6vrT0rbP0fWXpW2/p+9rSt8HS942lb6Ol71tL3yZL33eWvs2Wvu8tfVssfT9Y+rZa+n609G2z9P1k6dtu6fs5vS/j4+Rv4OT0nyd222Vi7rbD23rq7NbYO/PwTzrbI84uPry9J37HP2017xdJLtta0+aZY8u02ZqpqjX/9za2rn2tWyzsvBjPyw+Z2ZRYz+HWTOyEmM/3jxpbO97zHf6Z8HeT89Iw6++msvF3k/UCSHtEYrFZL4DSHlkvgNIeWS+A0h5ZL4DSfmS9AAol5Asg5zX+key+48fDn6HZUHglllV5P8exI2GPsArFHjyxn1iNYbem7T3WINgq6fuUL9zsiJN7mrVOttup/c+XLnb+f3uldQ62b4Z91Vfx2eoZ92Dr47I7tf3a1/HYsvrebkMctoSxD/wmNtvc3DNujMk2ybS//DYWm5p5L7opBptq2bd+R3CT8JoiTN3jnvwXITmUObfN/QbqzESZVvQzaA0IZ9BSCGfQduCfR9/OoFEycufYSZjj/3kGbSdxbdR6g1prwDiD1kDmDJr+lgV1cU1VyLIMmZoSZLqSINOuAMi0S0CmX3yS6RePZYJaa8qQqamMTGfpsxqDXYtrqUKWY8jUkiBTSYJMuwMg024BmX71SaZfPZYJaq0lQ6aWMjLl1mc1BrsW10aFLM+QqQ1BpqsIMu0JgEx7BGT6zSeZfvNYJqi1NgyZ2sjIdLY+qzHYtbhOKmQFhkydCDKVIsi0NwAy7RWQaZ9PMu3zWCaotU4MmTrJyJRHn9UY7FpcdxWyIkOm7gSZribItD8AMu0XkOl3n2T63WOZoNa6M2TqLiPTOfqsxmDX4vqokJUYMvUhyFSaINOBAMh0QECmP3yS6Q+PZYJa68OQqY+MTHn1WY3BrsX1VyErM2TqT5DpGoJMBwMg00EBmf70SaY/PZYJaq0/Q6b+MjKdq89qDHYtbqAKGWHINJAgUxmCTIcCINMhAZn+8kmmvzyWCWptIEOmgTIyJemzGoNdixuiQlZhyDSEINO1BJkOB0CmwwIy/e2TTH97LBPU2hCGTENkZDpPn9UY7FrccBWyKkOm4QSZyhJkOhIAmY4IyPSPTzL947FMUGvDGTINl5Epnz6rMdi1uFEqZDWGTKMIMl1HkOloAGQ6KiDTvz7J9K/HMkGtjWLINEpGpvP1WY3BrsWNVSFrMGQaS5CpHEGmYwGQ6ZiATMd9kum4xzJBrY1lyDRWRqb8+qzGYNfiJqqQNRkyTSTIdD1BplCvxJeJkvG/QbQ5wr38kSncy1uZoNYmMmSaKCPTBfqsxmDnfdtVyFoMmaYQZCpPkClbAGTKJiBTdp9kyu6xTFBrUxgyTZGRqYA+qzHYeXdcFbIOQ6bpBJluIMiUIwAy5RCQ6QyfZDrDY5mg1qYzZJouI9OF+qzGYOc9CFXIegyZZhFkqkCQKWcAZMopINOZPsl0pscyQa3NYsg0S0amgvqsxmDnnZ5UyAYMmeYTZLqRIFOuAMiUS0Cms3yS6SyPZYJam8+Qab6MTBfpsxqDnffTUCEbMWRaTJCpIkGm3AGQKbeATGf7JNPZHssEtbaYIdNiGZkK6bMag51XLVchGzNkWkaQ6SaCTHkCIFMeAZnO8UmmczyWCWptGUOmZTIyXazPagx2LW6lCtmUIdNKgkyVCDLlDYBMeQVkOtcnmc71WCaotZUMmVbKyFRYn9UY7FrcWhWyGUOmtQSZbibIlBQAmZIEZDrPJ5nO81gmqLW1DJnWysh0iT6rMdi1uA0qZHOGTBsIMlUmyJQvADLlE5DpfJ9kOt9jmaDWNjBk2iAjk365ceriNquQLRkybSbIdAtBpvwBkCm/gEwX+CTTBR7LBLW2mSHTZhmZLtVnNQa7FrdNhYwyZNpGkClCkKlAAGQqICDThT7JdKHHMkGtbWPItE1GJh2jLm6XCtmaIdMugky3EmQqGACZCgrIdJFPMl3ksUxQa7sYMu2SkekyfVZjsPNqQCpkG4ZMewkyVSHIVCgAMhUSkOlin2S62GOZoNb2MmTaKyNTUX1WY7DzmgsqZDuGTAcJMt1GkKlwAGQqLCDTJT7JdInHMkGtHWTIdFBGpsv1WY3Bzm+2qpAdGDIdIchUlSBTkQDIVERApkt9kulSj2WCWjvCkOmIjEzF9FmNwc7vDzUIhToxZIJxODYcup0gU3IAZEoWkOkyn2S6zGOZoNagdqi58PVmfySjqGxXGLPqg52f0lYhOzNkykmQqRpBpqIBkKmogEyX+yTT5R7LBLWWkyFTThmZiuuzGoOdn4VTIbsyZMpDkKk6QaZiAZCpmIBMV/gk0xUeywS1lochUx4ZmUrosxqDnZ84UCG7M2TKR5CpBkGm4gGQqbiATCV8kqmExzJBreVjyJRPRqYUfVZjsPO8jgrZkyFTQYJMdxBkSgmATCkCMl3pk0xXeiwT1FpBhkwFZWS6UjukLq6ICtmbIVMRgkw1CTKVDIBMJQVkusonma7yWCaotSIMmYrIyFRSn9UY7HyNokL2YchUjCDTnQSZSgVAplICMl3tk0xXeywT1FoxhkzFZGS6Sp/VGOz8l0CF7MuQqSRBploEmUoHQKbSAjJd45NM13gsE9RaSYZMJWVkKqXPagx23rBXhezHkKkMQabaBJnKBECmMgIyXeuTTNd6LBPUWhmGTGVkZLpan9UY7LwtogrZnyFTeYJMdQgylQ2ATGUFZLrOJ5mu81gmqLXyDJnKy8hUWp/VGOy8+ZQKOYAhUyWCTHUJMpULgEzlBGS63ieZrvdYJqi1SgyZKsnIdM2p/4QnFW7KaXtSUzL9oTlC8R47e2oBkuKx5u3uI3FY827e4ThsppsVx4mc+V6ssSNbbjUZicVa7qQXM7LtRmGxIlvvgxQjsv02LxEra7+LhT1yjIv0WyPHuga5LXLMSyxHMnfFvIKsJXLsC2Rmjhzn+n+ZIse7vFnEOI539SYzctyL0xiR4197Q4/suLRAJOOB45vTWmTXF0MzRnZ+7y1DZPfXeiKn/sv9rYX/IiM+lH0qMuYzpycjoz5SF0n7gfrEUHpk3Aci0iIjz/eeiIw9nRVRDftuPURGvxmpIuPfa0kKEV5KRgg7ZfJGwHwk47Ai/LHhU9UbzvAHlVe5b1Ctgmo3qlZRtZtUq6TazapVVu0W1SKq3apaFdVuU62qarerVk216qrVUO0O1WqqdqdqtVSrrVod1eqqVk+1+qo1UK1hr/QQ2dN/QohcRt8Nlr4Klr4bLX0VLX03WfoqWfputvRVtvTdYumLWPputfRVsfTdZumraum73dJXzdJX3dJXw9J3h6WvpqXvTktfLUtfbUtfHUtfXUtfPUtffUtfA0tfw/S+jI+T9+JNTv+p77abmLvtcPVeMdjUTDvzcI0YbGrmXXz4Djs7x7LjD9e0slVtrw7Cd9rYutZXEuFaFnae/VVHuHZmNiXGK5RwnUzshFivZsJ1TbZMzFc+4XoGuzX2q6RwfZ3tEecVVbiBxtaO9+or3DBWPVheqT3UJ8z6B6Bi+s/kUz1ZL44yPCKx2KwXR2mPrBdHaY+sF0dpj6wXR2k/sl4chRLyxZHzdBWS3Xf8ePgGNBsKV8CyKu+NOHYk7BEqotiDJ/YTN2HYrWl7j0oItkr6PuVmNzvi5J6mspPtdmr/c4uLnf/fXiniYPtm2FfdGp+tnnEPViUuu1Pbr90Wjy2r7+2qxmFLGPvA22Ozzc09YzWCF9Q948nfsMmhOH8nGe+hrc4CpLain62qQjhbVY9wtqoR/rnx7WwVJSN3jrsIc/w/z1bdRVwbtd6g1qowzlbh683+SEZR2crosxqDnXcqVSEHMmSqQZCpPkGmxgGQqbGATE18kqmJxzJBrdVgyFRDRqZr9VmNwc77wamQgxgy1SHI1IAgU9MAyNRUQKa7fZLpbo9lglqrw5CpjoxMZfVZjcHObZUKOZghUyOCTA0JMjULgEzNBGS6xyeZ7vFYJqi1RgyZGsnIdJ0+qzHYWbwq5BCGTM0IMjUiyNQ8ADI1F5CphU8ytfBYJqi1ZgyZmsnIVE6f1RjsvIK0CjmUIVOUINNdBJlaBkCmlgIy3euTTPd6LBPUWpQhU1RGpuv1WY3Bzut0qpDDGDK1I8jUmCBTNAAyRQVkauWTTK08lglqrR1DpnYyMpXXZzUGO6+GpkIOZ8jUmSBTE4JMrQMgU2sBme7zSab7PJYJaq0zQ6bOMjLdoM9qDHZec0aFHMGQqSdBpqYEmdoEQKY2AjK19Ummth7LBLXWkyFTTxmZKuizGoOd3+xXIUcyZOpLkOlugkztAiBTOwGZ2vskU3uPZYJa68uQqa+MTDfqsxqDnd+fVCFHMWQaQJCpGUGmDgGQqYOATB19kqmjxzJBrQ1gyDRARqaK+qzGYOdJNBVyNEOmQQSZ7iHI1CkAMnUSkOl+n2S632OZoNYGMWQaJCPTTfqsxmDnW5Uq5BiGTEMJMjUnyNQ5ADJ1FpCpi08ydfFYJqi1oQyZhsrIVEmf1RjsfEGoQo5lyDSCIFMLgkxdAyBTVwGZuvkkUzePZYJaG8GQaYSMTDfrsxqDnf/sqpDjGDKNJsjUkiBT9wDI1F1Aph4+ydTDY5mg1kYzZBotI1NlfVZjsHNxKuR4hkzjCDLdS5CpZwBk6ikgUy+fZOrlsUxQa+MYMo2TkekWfVZjsGtxk1TIiQyZJhFkihJk6h0AmXoLyPSATzI94LFMUGuTGDJNkpEpoh1SFzdVhZzEkGkqQaZWBJn6BECmPgIyPeiTTA96LBPU2lSGTFNlZLpVn9UY7FrcDBVyMkOmGQSZWhNk6hsAmfoKyPSQTzI95LFMUGszGDLNkJGpij6rMdi1uNkq5BSGTLMJMt1HkKlfAGTqJyDTwz7J9LDHMkGtzWbINFtGptv0WY3BrsUtVCGnMmRaSJCpDUGm/gGQqb+ATI/4JNMjHssEtbaQIdNCGZmq6rMag12LW6JCTmPItIQgU1uCTAMCINMAAZke9UmmRz2WCWptCUOmJTIy3a7Pagx2LW65CjmdIdNygkztCDKlBkCmVAGZHvNJpsc8lglqbTlDpuUyMlXTZzUGuxa3SoWcwZBpFUGm9gSZBgZApoECMj3uk0yPeywT1NoqhkyrZGSqrs9qDHYtbp0KOZMh0zqCTB0IMg0KgEyDBGR6wieZnvBYJqi1dQyZ1snIVEOf1RjsWtxGFXIWQ6aNBJk6EmQaHACZBgvI9KRPMj3psUxQaxsZMm2UkekOfVZjsGtxW1TI2QyZthBk6kSQaUgAZBoiINNTPsn0lMcyQa1tYci0RUammvqsxmDX4rarkHMZMm0nyHQ/QaahAZBpqIBMT/sk09MeywS1tp0h03YZme7UZzUGuxa3W4Wcz5BpN0GmzgSZhgVApmECMj3jk0zPeCwT1Npuhky7ZWSqpc9qDHYtbr8KuZAh036CTF0IMg0PgEzDBWR61ieZnvVYJqi1/QyZ9svIVFuf1RjsWtwhFXIRQ6ZDBJm6EmQaEQCZRgjI9JxPMj3nsUxQa4cYMh2SkamOPqsx2LW4oyrkYoZMRwkydSPINDIAMo0UkOl5n2R63mOZoNaOMmQ6KiNTXX1WY7BrcdkahkJLGDLBOBwbDnUnyDQqADKNEpDpBZ9kesFjmaDWoHaoufD1Zn8ko6hs9fRZjcGuxeVSIZcyZMpFkKkHQabRAZBptIBML/ok04seywS1loshUy4ZmerrsxqDXYvLq0IuY8iUlyBTT4JMYwIg0xgBmV7ySaaXPJYJai0vQ6a8MjI10Gc1BrsWl1+FXM6QKT9Bpl4EmcYGQKaxAjK97JNML3ssE9RafoZM+WVkaqjPagx2La6QGr6CIVMhgky9CTKNC4BM4wRkesUnmV7xWCaotUIMmQrJyNRIn9UY7Fpcsgq5kiFTMkGmBwgyjQ+ATOMFZJrgk0wTPJYJai2ZIVOyjEx36bMag12LK65CrmLIVJwgUx+CTBMDINNEAZle9UmmVz2WCWqtOEOm4jIyNdZnNQa7FldKhVzDkKkUQaYHCTJNCoBMkwRkes0nmV7zWCaotVIMmUrJyNTk1H/Ck5onZH9SUzL9oTlC8R536U9qUjzWvN19JA5r3s07HIfNdLPiOJEz34s1dmTLrSYjsVjLnfRiRrbdKCxWZOt9kGJEtt/mJWJl7XexsEeOcZF+a+RY1yC3RY55ieVI5q6YV5C1RI59gczMkeNc/y9T5HiXN4sYx/Gu3mRGjntxGiNy/Gtv6JEdlxaIZDxwfHNai+z6YmjGyM7vvWWI7P5aT+TUf7m/tfBfZMSHsk9Fxnzm9GRk1EfqImk/UJ8YSo+M+0BEWmTk+d4TkbGnsyKqYd+th8joNyNVZPx7LUkhwkvJCGGnTN4ImI9kHFaEPzZ8qnrDGf6gySr366pNUe0N1aaq9qZq01R7S7Xpqr2t2gzV3lFtpmrvqjZLtfdUm63aHNXmqjZPtfmqLVBtoWrvq7ZItQ9UW6zah6otUe2jXukhsqf/hBC5jL7XLX1TLH1vWPqmWvretPRNs/S9Zembbul729I3w9L3jqVvpqXvXUvfLEvfe5a+2Za+OZa+uZa+eZa++Za+BZa+hZa+9y19iyx9H1j6Flv6PrT0LbH0fZTel/GRN/1ncvpPfbfdxNxth+f0isGmZtqZh+fGYFMz7+LD8+zsHMuOPzzfyla1vToIL7Cxda2vJMILLew8+6uO8PuZ2ZQYr1DCizKxE2K9mgl/YLJlYr7yCS822K2xXyWFP9TZHnFeUYWXaGzteK++wh/FqgfLK7UX+4RZ/wCcvPdZ8qmerBdHGR6RWGzWi6O0R9aLo7RH1oujtEfWi6O0H1kvjkIJ+eLIeQlpJLvv+PHw62g2FJ6CZVXeN3DsSNgjTEWxB0/sJ97EsFvT9h7TEGyV9H3KW252xMk9zXQn2+3U/udtFzv/v73SDAfbN8O+6p34bPWMe7CZcdmd2n7t3XhsWX1vNysOW8LYB74Xm21u7hlnE7yg7hlP/oZNDsX5O8ngUtmGodDaVvSzVTAOx4ZDfQlnq5binxvfzlZRMnLn+Jgwx//zbNXHxLVR6w1qDWqHmgtfb/ZHMorK1lSf1RjsWlwFFXIdQ6YKBJkeIsi0LAAyLROQ6ROfZPrEY5mg1iowZKogI9Pd+qzGYNfiKquQ6xkyVSbI1I8g0/IAyLRcQKZPfZLpU49lglqrzJCpsoxMzfRZjcGuxVVVITcwZKpKkOlhgkwrAiDTCgGZPvNJps88lglqrSpDpqoyMt2jz2oMdi2upgq5kSFTTYJM/QkyrQyATCsFZPrcJ5k+91gmqLWaDJlqysjUXJ/VGOxaXD0VchNDpnoEmR4hyLQqADKtEpBptU8yrfZYJqi1egyZ6snI1EKf1RjsWlxjFXIzQ6bGBJkGEGRaEwCZ1gjI9IVPMn3hsUxQa40ZMjWWkamlPqsx2LW45irkFoZMzQkyPUqQaW0AZForINOXPsn0pccyQa01Z8j0P/bOBN6m6n3jZ5szJfPskBAlaZJUN92LZGokoRJC5vGiQWaSzImiMs/zmFSoZEoICUmin2QKmf3f1T2Xs/dd5+z1rGu92/78nc/n7WbdZ933XXu/32ftfc+559Tjgekle1bHZLfFNaQi92rA1BCAqTsA02YfwLSZAaYtHsG0xTBMotcaasDUkAeml23/RBfXlIrcpwFTUwCmdwCYtvoApq0MMP3kEUw/GYZJ9FpTDZia8sD0ij2rY7Lb4lpRkfs1YGoFwNQDgGmbD2DaxgDTdo9g2m4YJtFrrTRgasUDU0N7Vsdkt8V1oCIPaMDUAYCpJwDTDh/AtIMBpp89gulnwzCJXuugAVMHHphetWd1THZbXFcq8k8NmLoCMPUCYNrpA5h2MsD0i0cw/WIYJtFrXTVg6soDUyN7Vsdk189IpyIPacDUHYCpNwDTLh/AtIsBpt0ewbTbMEyi17prwNSdB6bG9qyOya6fREtFHtaAqQ8AUx8Apj0+gGkPA0y/egTTr4ZhEr3WRwOmPjwwNbFndUx2/bw/KvKIBkwDAZj6AjDt9QFMexlg+s0jmH4zDJPotYEaMA3kgek1e1bHZNdPVaIij2nANBSAqR8A0z4fwLSPAabfPYLpd8MwiV4bqgHTUB6YmtqzOia7fnYFFXlCA6ZRAEz9AZj2+wCm/Qww/eERTH8Yhkn02igNmEbxwNTMntUx2fUdwqnIkxowjQVgGgDAdMAHMB1ggOmgRzAdNAyT6LWxGjCN5YGpuT2rY7LrW0BQkac1YJoAwPQuANOfPoDpTwaY/ucRTP8zDJPotQkaME3ggel1e1bHZLfFTaMiz2jANA2AaSAA0yEfwHSIAaa/PILpL8MwiV6bpgHTNB6YWtizOia7LW4OFXlOA6Y5AEzvATAd9gFMhxlg+tsjmP42DJPotTkaMM3hgamlPatjstviFlGRFzRgWgTANAiA6YgPYDrCANNRj2A6ahgm0WuLNGBaxANTK3tWx2S3xS2nIi9pwLQcgOl9AKZjPoDpGANMxz2C6bhhmESvLdeAaTkPTK3tWR2TXd+njooMNMRhWgnANBiA6YQPYDrBANM/HsH0j2GYRK+t1IBpJQ9MbexZHZNd3w3omYQXnqMwrQFgGgLAdNIHMJ1kgOmURzCdMgyT6LU1GjCt4YGprT2rY7Lrey5Qkak0YNoIwDQUgOm0D2A6zQDTvx7B9K9hmESvbdSAaSMPTO3sWR2TXf+ylYpMowHTVgCmYQBMZ3wA0xkGmM56BNNZwzCJXtuqAdNWHpja27M6Jrv+/RAVmU4Dpp0ATMMBmM75AKZzDDCd9wim84ZhEr22UwOmnTwwdbBndUx2fZU2FZleA6a9AEwjAJgu+ACmCwwwXfQIpouGYRK9tlcDpr08MHW0Z3VMdn0tHBWZUQOmAwBMIwGYLvkApksMMF32CKbLhmESvXZAA6YDPDB1smd1THZ9xQEVmVkDpsMATB8AMAU6XP8wITVenYTlsDp4A5PVwSxMotcOa8B0mAemzvasjsmuz+tQkVk0YDoBwDQKgCmFD2BKwQBTSo9gSmkYJtFrJzRgOsEDU7w9q2Oy62/PqMisGjCdAWD6EIAplQ9gSsUAU2qPYEptGCbRa2c0YDrDA1MXe1bHZNd7FCoyuwZMlwCYRgMwpfEBTGkYYErrEUxpDcMkeu2SBkyXeGDqas/qmOy6EzwbCOTUgEnMU9NagTEATOl8AFM6Bphu8gimmwzDJHpN9A58NfAsfszDH0ElVYpu9qyOya6/qqQic2vAlB6A6SMApvQ+gCk9A0wZPIIpg2GYRK+l14ApPQ9Mb9izOia73hBSkXk1YMoCwPQxAFNGH8CUkQGmTB7BlMkwTKLXsmjAlIUHpjftWR2TXbddKjK/Bkw5AZjGAjBl9gFMmRlgutkjmG42DJPotZwaMOXkgekte1bHZNfFUZEFNWDKD8A0DoApiw9gysIA0y0ewXSLYZhEr+XXgCk/D0xvX/lfcVAzBuQHtUSSH5oqEO2xyv5MeJZoWufH3cdE0To/zduKok3yYcVRSk76WayRS5Z81GRMJK3kk/Qiliz7oLBIJUs/BylCyfKPeYmRauWfYiEvOcKb9EtLjvQe5LKSI77FckzSoYjvICspOfIbZCYtOcr7/yUpOdrbm8U4/h3t3ZucJUd9cxpHydHfe8NesstbC8SE/8PlL6dtJbv9YWh4ya5/9xZWsvuf9cRc+T/3v1q4WrLCi7KvlKzymtPEkpVeUheT8EXpFUOhktVeEJFQsuLzvf+VrPp0VgyF6m/rRcnKv4ykktV/15IlANxKxgBXyvCFgPMRVJMV1J9rXeleK+wHZaW6s1Fkp8hBkZMiF0VuijwUeSnyUeSnKEBRkKKQWCtFYYoiFLdSFKW4jaIYRXGKEhS3U5SkKEVxB8WdFKUp7uoQKiJl6KsoIp1jLJtkLLtkLIdkLKdkLJdkLLdkLI9kLK9kLJ9kLL9krIBkrKBkrJBkLCgZKywZKyIZu1UyVlQydptkrJhkrLhkrIRk7HbJWEnJWCnJ2B2SsTslY6UlY3eFxsIfmUNfg6Gv9qvt2s6rbevWDhG03ZNcmVtFI2i7J72Kt26TaxdKrvitYlJtrOzuwCou09aU3klYJSTaxfK7Duv2pNoSEe5QrJJJtOMi3c1YpZzaMhHvfKw7HNq9ke+SrDvt2rZR7qis0jZt9Wh3X9ZdkfpBcqe2sJOltQGUD30NXhm5cXMU9oiJpL1xc5TwuHFzlPC4cXOU8Lhxc5Tw5cbNUeC6vDlyff2iovbo5ctWNmVtwMquqqV6c6hph4prhJxK2pP/XU/kUtHuTbj2yK2grRi6Tsnjrh2ceE2T11Xb+sr1Tz437ZKr10r5XbTxYddVBaJrK4dfgxWMqj1ou14rFE1b1n5tF4yiLe64DiwcWVvPec1YBOACvWZMdNhgIMo5CWOpyLOk1Xi26r95atLAJ8CzVWXUj41nz1YhNermuNujZ6vuBteG9pvotSIaz1ap95v8EVRSpehu+ye6uBJUZBENmEoAMH0KwFTWBzCVZYDpHo9guscwTKLXSmjAVIIHpnfsWR2T3RZXmoosqgFTaQCmzwCY7vUBTPcywHSfRzDdZxgm0WulNWAqzQNTD3tWx2TX5qUii2nAdC8A03gApvt9ANP9DDA94BFMDxiGSfTavRow3csDU097Vsdkt8WVpyJLaMBUHoBpAgBTOR/AVI4Bpgc9gulBwzCJXiuvAVN5Hph62bM6JrstLoaKLKkBUwwA00QApvI+gKk8A0wPeQTTQ4ZhEr0WowFTDA9Mve1ZHZPdFleJirxDA6ZKAEyTAJgq+ACmCgwwPewRTA8bhkn0WiUNmCrxwNTHntUx2W1x1ajI0howVQNgmgzA9IgPYHqEAaZHPYLpUcMwiV6rpgFTNR6Y+tqzOia7Le5pKrKMBkxPAzBNAWCK8QFMMQwwPeYRTI8Zhkn02tMaMD3NA1M/e1bHZLfF1aEiy2rAVAeAaSoAU0UfwFSRAabHPYLpccMwiV6rowFTHR6Y+tuzOia7La4BFXmvBkwNAJimATDF+gCmWAaY4jyCKc4wTKLXGmjA1IAHpgH2rI7JbotrREXerwFTIwCm6QBMlXwAUyUGmCp7BFNlwzCJXmukAVMjHpjetWd1THZbXHMqspwGTM0BmGYAMFXxAUxVGGB6wiOYnjAMk+i15howNeeBaaA9q2Oy2+LaUJHlNWBqA8A0E4Cpqg9gqsoA05MewfSkYZhEr7XRgKkND0zv2bM6JrstrhMVWUEDpk4ATLMAmKr5AKZqDDBV9wim6oZhEr3WSQOmTjwwDbJndUx2W9wbVOQjGjC9AcA0G4Cphg9gqsEAU02PYKppGCbRa29owPQGD0zv27M6JrstrgcVGaMBUw8ApjkATLV8AFMtBpie8gimpwzDJHqthwZMPXhgGmzP6pjstrh+VGRFDZj6ATDNBWB62gcwPc0A0zMewfSMYZhEr/XTgKkfD0xD7Fkdk90WN4iKjNWAaRAA0zwApmd9ANOzDDA95xFMzxmGSfTaIA2YBvHANNSe1THZbXHDqchKGjANB2CaD8D0vA9gep4BptoewVTbMEyi14ZrwDScB6Zh9qyOyW6LG01FVtGAaTQA0wIApjo+gKkOA0wveATTC4ZhEr02WgOm0TwwDbdndUx2W9wnVGRVDZg+AWBaCMBU1wcw1WWA6UWPYHrRMEyi1z7RgOkTHphG2LM6JrstbhIVWU0DpkkATIsAmOr5AKZ6DDDV9wim+oZhEr02SQOmSTww2dsJXdwMKrKGBkwzAJgWAzA18AFMDRhgeskjmF4yDJPotRkaMM3ggekDe1bHZLfFzaMia2nANA+AaQkA08s+gOllBphe8QimVwzDJHptngZM83hgGmXP6pjstrglVOTTGjAtAWBaCsDU0AcwNWSA6VWPYHrVMEyi15ZowLSEB6YP7Vkdk90Wt4KKfFYDphUATMsAmBr5AKZGDDA19gimxoZhEr22QgOmFTwwjbZndUx2W9xqKvJ5DZhWAzB9DsDUxAcwNWGA6TWPYHrNMEyi11ZrwLSaB6Yx9qyOyW6LW0tF1tGAaS0A03IApqY+gKkpA0zNPIKpmWGYRK+t1YBpLQ9MH9mzOia7LW4TFVlXA6ZNAExfADA19wFMzRlget0jmF43DJPotU0aMG3igelje1bHZLfFbaMi62nAtA2AaQUAUwsfwNSCAaaWHsHU0jBMote2acC0jQemsfasjslui9tFRTbQgGkXANOXAEytfABTKwaYWnsEU2vDMIle26UB0y4emMbZszomuy1uHxX5sgZM+wCYvgJgauMDmNowwNTWI5jaGoZJ9No+DZj28cD0ie2f6OL+pCIbasD0JwDT1wBM7XwAUzsGmNp7BFN7wzCJXvtTA6Y/eWD61J7VMdltcUeoyEYaMB0BYFoJwNTBBzB1YICpo0cwdTQMk+i1IxowHeGB6TN7Vsdkt8WdpCKbaMB0EoBpFQBTJx/A1IkBps4ewdTZMEyi105qwHSSB6bx9qyOyW6LO0dFNtWA6RwA02oApngfwBTPAFMXj2DqYhgm0WvnNGA6xwPTBHtWx2S3xQWeo+d2NGAS89S0VuAbAKauPoCpKwNM3TyCqZthmESvid5B61LvN/kjqKRKMdGR1T7ZbXFpqMgWGjClAWD6FoDpDR/A9AYDTG96BNObhmESvZZGA6Y0PDBNsmd1THZbXEYqspUGTBkBmL4DYHrLBzC9xQDT2x7B9LZhmESvZdSAKSMPTJOv/K84qBkD8oNaIskPTRWI9rjbflCzRNM6P+4+JorW+WneVhRtkg8rjlJy0s9ijVyy5KMmYyJpJZ+kF7Fk2QeFRSpZ+jlIEUqWf8xLjFQr/xQLeckR3qRfWnKk9yCXlRzxLZZjkg5FfAdZScmR3yAzaclR3v8vScnR3t4sxvHvaO/e5Cw56pvTOEqO/t4b9pJd3logJvwfLn85bSvZ7Q9Dw0t2/bu3sJLd/6wn5sr/uf/VwtWSFV6UfaVkldecJpas9JK6mIQvSq8YCpWs9oKIhJIVn+/9r2TVp7NiKFR/Wy9KVv5lJJWs/ruWLAHgVjIGuFKGLwScj6CarKD+XOtK91phP6g71f0ORQ+KnhS9KHpT9KHoS9GPoj/FAIp3KQZSvEcxiOJ9isEUQyiGUgyjGE4xgmIkxQcUoyg+pBhNMYbiI4qPO4SKSBn6KopI5xh7RzLWQzLWUzLWSzLWWzLWRzLWVzLWTzLWXzI2QDL2rmRsoGTsPcnYIMnY+5KxwZKxIZKxoZKxYZKx4ZKxEZKxkZKxDyRjoyRjH0rGRkvGxkjGPpKMfRwaC38k/jsY+prkarus7WrbGtQhsra4/crcej+ytp7jKt4aHFFb23nFbw2JpO2e5O7AGhpB2z3pnYQ1zKatHu2uw/o4ynFw3qF0KWRpGV/6yOdmoaym4dKaYqX1j5Bpa8rXOlKiXRzhuHyQVFsi0jEclUQ7LuLx/tCpLRP53Ix2aPdGOY9j7Nq20c75R8A576p5zss5zvmNG0HbIyaS9saNYMLjxo1gwuPGjWDC48aNYMKXGzeCgevyRtBtH+2uqD16+bL1jrI2YPVQ1VK9PdW0Q8U1Qi8l7cn/rid6q2j3Jlx79FHQVgxdp/R11w5OvKbp56ptfeX6p7+bdsnVa6UBLtr4sOuqd6NrK4dfgw2Mqj1ou157D+hJ4BrdQq/tEp0wGIhUt73ns9IzE200nkHLCjyDtgZ4Bm2s+nH07Bk0pEbdHOOAHNfyGbRx4NrQfhO9llXjGbSsPM+gTbFndUx2W1xuKrKdBky5AZi+B2D6xAcwfcIA06cewfSpYZhEr+XWgCk3D0xT7Vkdk90WV5CK7KABU0EAprUATJ/5AKbPGGAa7xFM4w3DJHqtoAZMBXlgmmbP6pjstriiVGQnDZiKAjCtA2Ca4AOYJjDANNEjmCYahkn0WlENmIrywDTdntUx2W1xJanIeA2YSgIwrQdgmuQDmCYxwDTZI5gmG4ZJ9FpJDZhK8sA0w57VMdltcWWoyK4aMJUBYNoAwDTFBzBNYYBpqkcwTTUMk+i1MhowleGBaaY9q2Oy2+LupyLf0IDpfgCmjQBM03wA0zQGmKZ7BNN0wzCJXrtfA6b7eWCaZc/qmOy2uApU5FsaMFUAYPoBgGmGD2CawQDTTI9gmmkYJtFrFTRgqsAD02x7Vsdk18/1piK7a8BUEYBpEwDTLB/ANIsBptkewTTbMEyi1ypqwFSRB6Y59qyOya6fnkpF9tCAqQoA048ATHN8ANMcBpjmegTTXMMwiV6rogFTFR6Y5tqzOia7fkYdFdlLA6YaAEybAZjm+QCmeQwwzfcIpvmGYRK9VkMDpho8MM2zZ3VMdv0kICqyjwZMzwIwbQFgWuADmBYwwLTQI5gWGoZJ9NqzGjA9ywPTfHtWx2TXz1ugIvtpwFQXgGkrANMiH8C0iAGmxR7BtNgwTKLX6mrAVJcHpgX2rI7Jru9qTUUO0IDpZQCmnwCYlvgApiUMMC31CKalhmESvfayBkwv88C00J7VMdn1vUOpyIEaMDUBYNoGwLTMBzAtY4Dpc49g+twwTKLXmmjA1IQHpkX2rI7Jru/QRkUO0oCpBQDTdgCm5T6AaTkDTF94BNMXhmESvdZCA6YWPDAttmd1THZ9STwVOVgDpnYATDsAmFb4AKYVDDB96RFMXxqGSfRaOw2Y2vHAtMSe1THZ9YWHVORQDZjiAZh+BmD6ygcwfcUA09cewfS1YZhEr8VrwBTPA9NSe1bHZNeXd1CRwzVgeguAaScA00ofwLSSAaZVHsG0yjBMotfe0oDpLR6YltmzOia7PolGRY7UgKkXANMvAEyrfQDTagaYvvEIpm8MwyR6rZcGTL14YPrcntUx2fVXlVTkKA2YBgAw7QJg+tYHMH3LANN3HsH0nWGYRK8N0IBpAA9My+1ZHZNdbwipyNEaMA0GYNoNwLTGBzCtYYDpe49g+t4wTKLXBmvANJgHpi/sWR2TXbddKvIjDZhGAjDtAWBa6wOY1jLAtM4jmNYZhkn02kgNmEbywLTCntUx2XVxVORYDZg+AmD6FYBpvQ9gWs8A0waPYNpgGCbRax9pwPQRD0xf2rM6Jru+GxAV+YkGTJ8BMO0FYNroA5g2MsD0g0cw/WAYJtFrn2nA9BkPTF/Z/okubgoV+ZkGTFMAmH4DYNrkA5g2McD0o0cw/WgYJtFrUzRgmsID09f2rI7Jrn/ZSkVO0IBpFgDTPgCmzT6AaTMDTFs8gmmLYZhEr83SgGkWD0wr7Vkdk13/foiKnKQB0wIApt8BmLb6AKatDDD95BFMPxmGSfTaAg2YFvDAtMqe1THZ9VXaVOQUDZiWATDtB2Da5gOYtjHAtN0jmLYbhkn02jINmJbxwLTantUx2fW1cFTkNA2YvgJg+gOAaYcPYNrBANPPHsH0s2GYRK99pQHTVzwwfWPP6pjs+ooDKnKGBkzfAjAdAGDa6QOYdjLA9ItHMP1iGCbRa99qwPQtD0zf2rM6Jrs+r0NFztKAaT0A00EApl0+gGkXA0y7PYJpt2GYRK+t14BpPQ9M39mzOia7/vaMipyjAdNmAKY/AZj2+ACmPQww/eoRTL8ahkn02mYNmDbzwLTGntUx2fUehYqcpwHTDgCm/wEw7fUBTHsZYPrNI5h+MwyT6LUdGjDt4IHpe3tWx2TXnYCKXKAB0x4ApkMATPt8ANM+Bph+9wim3w3DJHptjwZMe3hgWmvP6pjstrj9VOQiDZj2AzD9BcC03wcw7WeA6Q+PYPrDMEyi1/ZrwLSfB6Z19qyOyW6LO0RFLtGA6RAA02EApgM+gOkAA0wHPYLpoGGYRK8d0oDpEA9M6+1ZHZPdFneMilymAdMxAKa/AZj+9AFMfzLA9D+PYPqfYZhErx3TgOkYD0wb7Fkdk90Wd5qKXK4B02kApiMATId8ANMhBpj+8gimvwzDJHrttAZMp3lg2mjP6pjstrgLVOQKDZguADAdBWA67AOYDjPA9LdHMP1tGCbRaxc0YLrAA9MPV/5XHNSMAflBLZHkh6YKRHuMsx/ULNG0zo+7j4midX6atxVFm+TDiqOUnPSzWCOXLPmoyZhIWskn6UUsWfZBYZFKln4OUoSS5R/zEiPVyj/FQl5yhDfpl5Yc6T3IZSVHfIvlmKRDEd9BVlJy5DfITFpylPf/S1JytLc3i3H8O9q7NzlLjvrmNI6So7/3hr1kl7cWiAn/h8tfTttKdvvD0PCSXf/uLaxk9z/ribnyf+5/tXC1ZIUXZV8pWeU1p4klK72kLibhi9IrhkIlq70gIqFkxed7/ytZ9emsGArV39aLkpV/GUklq/+uJUsAuJWMAa6U4QsB5yOoJiuoP9e60r1W2A86QnUfpThGcZziBMU/FCcpTlGcpviX4gzFWYpzFOcpLlBcpLhEcZki0JF+LkUKipQUqShSU6ShSEuRjuImivQUGTqGikgZ+iqKSOcYOyoZOyYZOy4ZOyEZ+0cydlIydkoydloy9q9k7Ixk7Kxk7Jxk7Lxk7IJk7KJk7JJk7LJkTJwk55glGUshGUspGUslGUstGUsjGUsrGUsnGbtJMpZeMpYhNBb+SPx3MPQ1ydV2WdvVtnWhQ2RtcfuVuXUxsrae4yreuhRRW9t5xW9djqTtnuTuwBLnU6btnvROwrJs2urR7jqsDB2jHDPHHcqIQpaW8aWPfG4WympKIa0pVlp/Spm2pnytqSTaxRGOS+qk2hKRjmGaJNpxEY93Wqe2TORzk86h3RvlPN5k17aNds7TA+d8pOY5L+c45zduBG2PmEjaGzeCCY8bN4IJjxs3ggmPGzeCCV9u3AgGrssbQbd99Iii9ujly9ZRZS09L6mqpXqPq2mHimuEE0rak/9dT/yjot2bcO1xUkFbMXSdcspdOzjxmua0q7b1leuff920S65eK51x0caHXVedja6tHH4Ndi6q9qDteu080JPANbqFXtslOmEwEKlue8+neD4Q+ErjGTQxT01rBY4Bz6Bl7Khcg2fPoCE16ubIBOS4ls+gZQLXhvab6DXRO2hd6v0mfwSVVCk22bM6JrstLh0VuVIDpnQATMcBmDL7AKbMDDDd7BFMNxuGSfRaOg2Y0vHA9KM9q2Oya/NSkas1YMoMwHQCgCmLD2DKwgDTLR7BdIthmESvZdaAKTMPTJvtWR2T3RaXnYr8VgOm7ABM/wAwZfUBTFkZYMrmEUzZDMMkei27BkzZeWDaYs/qmOy2uLxU5BoNmPICMJ0EYMruA5iyM8CUwyOYchiGSfRaXg2Y8vLAtNWe1THZbXFBKnKtBkxBAKZTAEw5fQBTTgaYcnkEUy7DMIleC2rAFOSB6Sd7Vsdkt8UVoyLXa8BUDIDpNABTbh/AlJsBpjwewZTHMEyi14ppwFSMB6Zt9qyOyW6Lu4OK3KgB0x0ATP8CMOX1AUx5GWDK5xFM+QzDJHrtDg2Y7uCBabs9q2Oy2+LKUpGbNGAqC8B0BoApvw9gys8AUwGPYCpgGCbRa2U1YCrLA9MOe1bHZLfFlaMiN2vAVA6A6SwAU0EfwFSQAaZCHsFUyDBMotfKacBUjgemn+1ZHZPdFvcIFblVA6ZHAJjOATAFfQBTkAGmwh7BVNgwTKLXHtGA6REemHbaszomuy0ulorcpgFTLADTeQCmIj6AqQgDTLd6BNOthmESvRarAVMsD0y/2LM6JrstrioVuUMDpqoATBcAmIr6AKaiDDDd5hFMtxmGSfRaVQ2YqvLAtMue1THZbXG1qMidGjDVAmC6CMBUzAcwFWOAqbhHMBU3DJPotVoaMNXigWm3Patjstvinqcid2nA9DwA0yUAphI+gKkEA0y3ewTT7YZhEr32vAZMz/PAtMee1THZbXH1qMg9GjDVA2C6DMBU0gcwlWSAqZRHMJUyDJPotXoaMNXjgelXe1bHZLfFNaQi92rA1BCAKdBUvZ47fADTHQww3ekRTHcahkn0WkMNmBrywLTX9k90cU2pyH0aMDUFYLIAmEr7AKbSDDDd5RFMdxmGSfRaUw2YmvLA9Js9q2Oy2+JaUZH7NWBqBcCUAoCpjA9gKsMA090ewXS3YZhEr7XSgKkVD0z77Fkdk90W14GKPKABUwcAppQATGV9AFNZBpju8QimewzDJHqtgwZMHXhg+t2e1THZbXFdqcg/NWDqCsCUCoDpXh/AdC8DTPd5BNN9hmESvdZVA6auPDDtt2d1THZbXHcq8pAGTN0BmFIDMN3vA5juZ4DpAY9gesAwTKLXumvA1J0Hpj/sWR2T3RbXh4o8rAFTHwCmNABM5XwAUzkGmB70CKYHDcMkeq2PBkx9eGA6YM/qmOy2uIFU5BENmAYCMKUFYCrvA5jKM8D0kEcwPWQYJtFrAzVgGsgD00F7Vsdkt8UNpSKPacA0FIApHQBTBR/AVIEBpoc9gulhwzCJXhuqAdNQHpj+tGd1THZb3Cgq8oQGTKMAmG4CYHrEBzA9wgDTox7B9KhhmESvjdKAaRQPTP+zZ3VMdlvcWCrypAZMYwGY0gMwxfgAphgGmB7zCKbHDMMkem2sBkxjeWA6ZM/qmOy2uAlU5GkNmCYAMGUAYKroA5gqMsD0uEcwPW4YJtFrEzRgmsAD01/2rI7JboubRkWe0YBpGgBTRgCmWB/AFMsAU5xHMMUZhkn02jQNmKbxwHTYntUx2W1xc6jIcxowzQFgygTAVMkHMFVigKmyRzBVNgyT6LU5GjDN4YHpb3tWx2S3xS2iIi9owLQIgCkzAFMVH8BUhQGmJzyC6QnDMIleW6QB0yIemI7Yszomuy1uORV5SQOm5QBMNwMwVfUBTFUZYHrSI5ieNAyT6LXlGjAt54HpqD2rY7LrR3xQkYFXcZhWAjBlAWCq5gOYqjHAVN0jmKobhkn02koNmFbywHTMntUx2fWN1KnIFBowrQFgugWAqYYPYKrBAFNNj2CqaRgm0WtrNGBawwPTcXtWx2TXt6ulIlNpwLQRgCkrAFMtH8BUiwGmpzyC6SnDMIle26gB00YemE7Yszomu74pIBWZRgOmrQBM2QCYnvYBTE8zwPSMRzA9Yxgm0WtbNWDaygPTP/asjsmub71ERabTgGknAFN2AKZnfQDTswwwPecRTM8Zhkn02k4NmHbywHTSntUx2fUNLqjI9Bow7QVgygHA9LwPYHqeAabaHsFU2zBMotf2asC0lwemU/asjsmuf0ZMRWbUgOkAAFNOAKY6PoCpDgNML3gE0wuGYRK9dkADpgM8MJ22Z3VMdv1jLSoyswZMhwGYcgEw1fUBTHUZYHrRI5heNAyT6LXDGjAd5oHp3yv/Kw5qxoD8oJZI8kNTBaI9MtkPapZoWufH3cdE0To/zduKok3yYcVRSk76WayRS5Z81GRMJK3kk/Qiliz7oLBIJUs/BylCyfKPeYmRauWfYiEvOcKb9EtLjvQe5LKSI77FckzSoYjvICspOfIbZCYtOcr7/yUpOdrbm8U4/h3t3ZucJUd9cxpHydHfe8NesstbC8SE/8PlL6dtJbv9YWh4ya5/9xZWsvuf9cRc+T/3v1q4WrLCi7KvlKzymtPEkpVeUheT8EXpFUOhktVeEJFQsuLzvf+VrPp0VgyF6m/rRcnKv4ykktV/15IlANxKxgBXyvCFgPMRVJMV1J9rXeleK+wH1aO661M0oHiJ4mWKVygaUrxK0YiiMUUTitcomlI0o2hO8TpFC4qWFK0oWlO0oWhL0Y6iPUUHio4UnSg6U8RTdOkYKiJl6KsoIp1jrL5krIFk7CXJ2MuSsVckYw0lY69KxhpJxhpLxppIxl6TjDWVjDWTjDWXjL0uGWshGWspGWslGWstGWsjGWsrGWsnGWsvGesgGesoGeskGessGYuXjHUJjYU/Ev8dDH1NcrVd1na1bTXvGFlb3H5lbr0eWVvPcRVvtYiore284rdaRtJ2T3J3YLWKoO2e9E7Cam3TVo9212F1iXIcnHcocwtZWsaXPvK5WSirqY20plhp/W1l2prytbaTaBdHOC7tk2pLRDqGHZJox0U83h2d2jKRz00nh3ZvlPPY2a5tG+2cxwPnfJ7mOS/nOOc3bgRtj5hI2hs3ggmPGzeCCY8bN4IJjxs3gglfbtwIBq7LG0HXT+FR1B69fNmqr6wNWA1UtVTvS2raoeIa4WUl7cn/rideUdHuTbj2aKigrRi6TnnVXTs48Zqmkau29ZXrn8Zu2iVXr5WauGjjw66rXouurRx+DdY0qvag7XqtGdCTwDW6hV7bJTphMBCpbsf74NAzE1k0nkE7ATyDlht4Bq2r+nH07Bk0pEbdHN2AHNfyGbRu4NrQfhO9dkLjGbQTPM+gnbFndUx2fbcBKjKrBkxnAJjyADC94QOY3mCA6U2PYHrTMEyi185owHSGB6az9qyOya5/00lFZteA6RIAU14Aprd8ANNbDDC97RFMbxuGSfTaJQ2YLvHAdM6e1THZ9S9nagcCOTVgEvPUtFYgHwBTdx/A1J0Bpnc8gukdwzCJXhO9g9al3m/yR1BJleK8Patjsuvrk6nI3BowpQdgyg/A1MMHMPVggKmnRzD1NAyT6LX0GjCl54Hpgj2rY7LrDSEVmVcDpiwATAUAmHr5AKZeDDD19gim3oZhEr2WRQOmLDwwXbRndUx23XapyPwaMOUEYCoIwNTHBzD1YYCpr0cw9TUMk+i1nBow5eSB6ZI9q2Oy6+KoyIIaMOUHYCoEwNTPBzD1Y4Cpv0cw9TcMk+i1/Bow5eeB6bI9q2Oy2+KKiCI1YCoCwBQEYBrgA5gGMMD0rkcwvWsYJtFrRTRgKsICk+MIoosrQUUW0YCpBABTYQCmgT6AaSADTO95BNN7hmESvVZCA6YSPDBZ9qyOyW6LK01FFtWAqTQAUxEApkE+gGkQA0zvewTT+4ZhEr1WWgOm0jwwpbBndUx2/dx2KrKYBkz3AjDdCsA02AcwDWaAaYhHMA0xDJPotXs1YLqXByb7IUQXV56KLKEBU3kApqIATEN9ANNQBpiGeQTTMMMwiV4rrwFTeR6Y7H8dgS4uhoosqQFTDADTbQBMw30A03AGmEZ4BNMIwzCJXovRgCmGB6bU9qyOya6f9ERF3qEBUyUApmIATCN9ANNIBpg+8AimDwzDJHqtkgZMlXhgSmPP6pjs+nkaVGRpDZiqATAVB2Aa5QOYRjHA9KFHMH1oGCbRa9U0YKrGA1Nae1bHZNd3Laciy2jA9DQAUwkAptE+gGk0A0xjPIJpjGGYRK89rQHT0zww2d+CBV1cHSqyrAZMdQCYbgdg+sgHMH3EANPHHsH0sWGYRK/V0YCpDg9MN9mzOia7La4BFXmvBkwNAJhKAjCN9QFMYxlgGucRTOMMwyR6rYEGTA14YEpvz+qY7La4RlTk/RowNQJgKgXA9IkPYPqEAaZPPYLpU8MwiV5rpAFTIx6YMtizOia7La45FVlOA6bmAEx3ADB95gOYPmOAabxHMI03DJPoteYaMDXngSmjPatjstvi2lCR5TVgagPAdCcA0wQfwDSBAaaJHsE00TBMotfaaMDUhgemTPasjslui+tERVbQgKkTAFNpAKZJPoBpEgNMkz2CabJhmESvddKAqRMPTJntWR2TXd8NiIp8RAOmNwCY7gJgmuIDmKYwwDTVI5imGoZJ9NobGjC9wQPTzfasjsmu77lARcZowNQDgKkMANM0H8A0jQGm6R7BNN0wTKLXemjA1IMHpiz2rI7Jrn/ZSkVW1ICpHwDT3QBMM3wA0wwGmGZ6BNNMwzCJXuunAVM/HphusWd1THb9+yEqMlYDpkEATGUBmGb5AKZZDDDN9gim2YZhEr02SAOmQTwwZbVndUx2fZU2FVlJA6bhAEz3ADDN8QFMcxhgmusRTHMNwyR6bbgGTMN5YMpmz+qY7PpaOCqyigZMowGY7gVgmucDmOYxwDTfI5jmG4ZJ9NpoDZhG88CU3Z7VMdn1FQdUZFUNmD4BYLoPgGmBD2BawADTQo9gWmgYJtFrn2jA9AkPTDnsWR2TXZ/XoSKracA0CYDpfgCmRT6AaREDTIs9gmmxYZhEr03SgGkSD0w57Vkdk11/e0ZF1tCAaQYA0wMATEt8ANMSBpiWegTTUsMwiV6boQHTDB6YctmzOia73qNQkbU0YJoHwFQOgGmZD2BaxgDT5x7B9LlhmESvzdOAaR4PTLntWR2TXXcCKvJpDZiWADA9CMC03AcwLWeA6QuPYPrCMEyi15ZowLSEB6Y89qyOyW6LW0FFPqsB0woApvIATCt8ANMKBpi+9AimLw3DJHpthQZMK3hgymvP6pjstrjVVOTzGjCtBmB6CIDpKx/A9BUDTF97BNPXhmESvbZaA6bVPDDls2d1THZb3Foqso4GTGsBmCoAMK30AUwrGWBa5RFMqwzDJHptrQZMa3lgym/P6pjstrhNVGRdDZg2ATA9DMC02gcwrWaA6RuPYPrGMEyi1zZpwLSJB6YC9qyOyW6L20ZF1tOAaRsA0yMATN/6AKZvGWD6ziOYvjMMk+i1bRowbeOBqaA9q2Oy2+J2UZENNGDaBcD0KADTGh/AtIYBpu89gul7wzCJXtulAdMuHpgKXflfcVDFH7HLDmqJJD80VSDao5v9oGaJpnV+3H1MFK3z07ytKNokH1YcpeSkn8UauWTJR03GRNJKPkkvYsmyDwqLVLL0c5AilCz/mJcYqVb+KRbykiO8Sb+05EjvQS4rOeJbLMckHYr4DrKSkiO/QWbSkqO8/1+SkqO9vVmM49/R3r3JWXLUN6dxlBz9vTfsJbu8tUBM+D9c/nLaVrLbH4aGl+z6d29hJbv/WU/Mlf9z/6uFqyUrvCj7SskqrzlNLFnpJXUxCV+UXjEUKlntBREJJSs+3/tfyapPZ8VQqP62XpSs/MtIKln9dy1ZAsCtZAxwpQxfCDgfQTVZQf251pXutcJ+0Fqqex3FeooNFBspfqDYRPEjxWaKLRRbKX6i2EaxnWIHxc8UOyl+odhFsZtiD8WvFHspfqPYR/E7xX6KPygOUBzsGCoiZeirKCKdY2ydZGy9ZGyDZGyjZOwHydgmydiPkrHNkrEtkrGtkrGfJGPbJGPbJWM7JGM/S8Z2SsZ+kYztkoztloztkYz9KhnbKxn7TTK2TzL2u2Rsv2TsD8nYAcnYwdBY+CPx1e7B0FfZ1Xb81att66eOUbWVw67MrW1RtQfDr+Kt7dG0ZW1X/NaOKNri9rsD6+fI2nqOOwlrZ0Rtbeddh/VLJG33JHco1q4I2u5J72as3XLtQsmdj7VHqo2V3SVZv8q0NaV3VNZeiXax/O7L+i2ptkSEOzVrXxLtuEh3ddbvTm2ZiHeA1n6Hdm/ku0XrD7u2bZQ7S+uATVs92l2odTA6F7Y71rs7W1ob4b2hr8ErIzduEsMeMZG0N24SEx43bhITHjduEhMeN24SE77cuEkMXJc3ia4vKFHUHr182VqnrA1Y61W1VO8GNe1QcY2wUUl78r/riR9UtHsTrj02KWgrhq5TfnTXDk68ptnsqm195fpni5t2ydVrpa1AP6DXSonOEnQ7dqEe2kfPArys8WzVPuDZqhjg2ao/1Y+NZ89WITXq5vgfkONaPlv1P3BtaL+JXtun8WzVPp5nq+wydHF/UpENNWD6E4DpMQCmQz6A6RADTH95BNNfhmESvfanBkx/8sBU2J7VMdltcUeoyEYaMB0BYKoIwHTYBzAdZoDpb49g+tswTKLXjmjAdIQHpiL2rI7Jbos7SUU20YDpJADT4wBMR3wA0xEGmI56BNNRwzCJXjupAdNJHphutWd1THZb3DkqsqkGTOcAmGIBmI75AKZjDDAd9wim44ZhEr12TgOmczwwFbVndUx2W1ygTiDQXAMmMU9NawXiAJhO+ACmEwww/eMRTP8Yhkn0mugdtC71fpM/gkqqlLc5stonuy0uDRXZQgOmNABMlQCYTvoAppMMMJ3yCKZThmESvZZGA6Y0PDAVs2d1THZbXEYqspUGTBkBmCoDMJ32AUynGWD61yOY/jUMk+i1jBowZeSBqbg9q2Oy2+KyUpFtNGDKCsBUBYDpjA9gOsMA01mPYDprGCbRa1k1YMrKA1MJe1bHZLfF5aYi22nAlBuA6QkApnM+gOkcA0znPYLpvGGYRK/l1oApNw9Mt9uzOia7La4gFdlBA6aCAExVAZgu+ACmCwwwXfQIpouGYRK9VlADpoI8MJW0Z3VMdltcUSqykwZMRQGYngRguuQDmC4xwHTZI5guG4ZJ9FpRDZiK8sBUyp7VMdltcSWpyHgNmEoCMFUDYAp0uv5hQmq8OgnLYXXyBiark1mYRK+V1ICpJA9Md9izOia7La4MFdlVA6YyAEzVAZhS+ACmFAwwpfQIppSGYRK9VkYDpjI8MN1pz+qY7La4+6nINzRguh+AqQYAUyofwJSKAabUHsGU2jBMotfu14Dpfh6YStuzOia7La4CFfmWBkwVAJhqAjCl8QFMaRhgSusRTGkNwyR6rYIGTBV4YLrLntUx2fUztKnI7howVQRgqgXAlM4HMKVjgOkmj2C6yTBMotcqasBUkQemMvasjsmun1RKRfbQgKkKANNTAEzpfQBTegaYMngEUwbDMIleq6IBUxUemO62Z3VMdv08OCqylwZMNQCYngZgyugDmDIywJTJI5gyGYZJ9FoNDZhq8MBU1p7VMdn1U3eoyD4aMD0LwPQMAFNmH8CUmQGmmz2C6WbDMIlee1YDpmd5YLrHntUx2fWzDajIfhow1QVgehaAKYsPYMrCANMtHsF0i2GYRK/V1YCpLg9M99qzOia7vsEFFTlAA6aXAZieA2DK6gOYsjLAlM0jmLIZhkn02ssaML3MA9N99qyOya5/RkxFDtSAqQkA0/MATNl9AFN2BphyeARTDsMwiV5rogFTEx6Y7rdndUx2/WMtKnKQBkwtAJhqAzDl9AFMORlgyuURTLkMwyR6rYUGTC14YHrAntUx2fUl8VTkYA2Y2gEw1QFgyu0DmHIzwJTHI5jyGIZJ9Fo7DZja8cBUzp7VMdn1hYdU5FANmOIBmF4AYMrrA5jyMsCUzyOY8hmGSfRavAZM8TwwPWjP6pjs+vIOKnK4BkxvATDVBWDK7wOY8jPAVMAjmAoYhkn02lsaML3FA1N5e1bHZNcn0ajIkRow9QJgehGAqaAPYCrIAFMhj2AqZBgm0Wu9NGDqxQPTQ/asjsmuv6qkIkdpwDQAgKkeAFPQBzAFGWAq7BFMhQ3DJHptgAZMA3hgqmDP6pjsekNIRY7WgGkwAFN9AKYiPoCpCANMt3oE062GYRK9NlgDpsE8MD1sz+qY7LrtUpEfacA0EoCpAQBTUR/AVJQBpts8guk2wzCJXhupAdNIHpgesWd1THZdHBU5VgOmjwCYXgJgKuYDmIoxwFTcI5iKG4ZJ9NpHGjB9xAPTo/asjslui/uMivxEA6bPAJheBmAq4QOYSjDAdLtHMN1uGCbRa59pwPQZD0wxtn+ii5tCRX6mAdMUAKZXAJhK+gCmkgwwlfIIplKGYRK9NkUDpik8MD1mz+qY7La4WVTkBA2YZgEwNQRgusMHMN3BANOdHsF0p2GYRK/N0oBpFg9MFe1ZHZPdFreAipykAdMCAKZXAZhK+wCm0gww3eURTHcZhkn02gINmBbwwPS4PatjstvillGRUzRgWgbA1AiAqYwPYCrDANPdHsF0t2GYRK8t04BpGQ9Msfasjslui/uKipymAdNXAEyNAZjK+gCmsgww3eMRTPcYhkn02lcaMH3FA1OcPatjstvivqUiZ2jA9C0AUxMApnt9ANO9DDDd5xFM9xmGSfTatxowfcsDUyV7Vsdkt8WtpyJnacC0HoDpNQCm+30A0/0MMD3gEUwPGIZJ9Np6DZjW88BU+cr/ioOaMSA/qCWS/NBUgWiP/9nfwD1LNK3z4+5jomidn+ZtRdEm+bDiKCUn/SzWyCVLPmoyJpJW8kl6EUuWfVBYpJKln4MUoWT5x7zESLXyT7GQlxzhTfqlJUd6D3JZyRHfYjkm6VDEd5CVlBz5DTKTlhzl/f+SlBzt7c1iHP+O9u5NzpKjvjmNo+To771hL9nlrQViwv/h8pfTtpLd/jA0vGTXv3sLK9n9z3pirvyf+18tXC1Z4UXZV0pWec1pYslKL6mLSfii9IqhUMlqL4hIKFnx+d7/SlZ9OiuGQvW39aJk5V9GUsnqv2vJEgBuJWOAK2X4QsD5CKrJCurPta50rxX2g8pR3Q9SlKd4iKICxcMUj1A8ShFD8RhFRYrHKWIp4igqUVSmqELxBEVViicpqlFUp6hBUZOiFsVTFE9TPEPxLMVznUJFpAx9FUWkc4w9KBkrLxl7SDJWQTL2sGTsEcnYo5KxGMnYY5KxipKxxyVjsZKxOMlYJclYZclYFcnYE5KxqpKxJyVj1SRj1SVjNSRjNSVjtSRjT0nGnpaMPSMZe1Yy9lxoLPyRPfQ1GPoqu9qOv3q1bT3eKaq2ctiVuRUbVXsw/CreioumLWu74rcqRdEWt98dWJUja+s57iSsKhG1tZ13HdYTkbTdk9yhWFUjaLsnvZuxnpRrF0rufKxqUm2s7C7Jqi7T1pTeUVk1JNrF8rsvq2ZSbYkId2pWrSTacZHu6qynnNoyEe8Aracd2r2R7xatZ+zatlHuLK1nbdrq0e5Creeic2G7Y63Z2dLaCBPfAS14ZeTGTWLYIyaS9sZNYugn3LhJ/O9x4yYx4XHjJjHhy42bxMB1eZPoto+WU9QevXzZelBZG7DKq2qp3ofUtEPFNUIFJe3J/64nHlbR7k249nhEQVsxdJ3yqLt2cOI1TYyrtvWV65/H3LRLrl4rVQT6Ab1WSnSWoNuxC/XQZnoWYI7Gs1WbgWermgLPVj2vfmw8e7YKqVE3R20gx7V8tqo2uDa030SvbdZ4tmozz7NVVexZHZPdFreDipynAdMOAKZmAEx1fABTHQaYXvAIphcMwyR6bYcGTDt4YHrCntUx2W1xe6jIBRow7QFgag7AVNcHMNVlgOlFj2B60TBMotf2aMC0hwemqvasjslui9tPRS7SgGk/ANPrAEz1fABTPQaY6nsEU33DMIle268B034emJ60Z3VMdlvcISpyiQZMhwCYWgAwNfABTA0YYHrJI5heMgyT6LVDGjAd4oGpmj2rY7Lb4o5Rkcs0YDoGwNQSgOllH8D0MgNMr3gE0yuGYRK9dkwDpmM8MFW3Z3VMdlvcaSpyuQZMpwGYWgEwNfQBTA0ZYHrVI5heNQyT6LXTGjCd5oGphj2rY7Lb4i5QkSs0YLoAwNQagKmRD2BqxABTY49gamwYJtFrFzRgusADU017Vsdkt8WleCEQ+EoDJjFPTWsF2gAwNfEBTE0YYHrNI5heMwyT6DXRO2hd6v0mfwSVVClr2bM6JrstLh0VuVIDpnQATG0BmJr6AKamDDA18wimZoZhEr2WTgOmdDwwPWXP6pjs+hnpVORqDZgyAzC1A2Bq7gOYmjPA9LpHML1uGCbRa5k1YMrMA9PT9qyOya6fREtFfqsBU3YApvYATC18AFMLBphaegRTS8MwiV7LrgFTdh6YnrFndUx2/bw/KnKNBkx5AZg6ADC18gFMrRhgau0RTK0NwyR6La8GTHl5YHrWntUx2fVTlajItRowBQGYOgIwtfEBTG0YYGrrEUxtDcMkei2oAVOQB6bn7Fkdk10/u4KKXK8BUzEApk4ATO18AFM7BpjaewRTe8MwiV4rpgFTMR6YnrdndUx2fYdwKnKjBkx3ADB1BmDq4AOYOjDA1NEjmDoahkn02h0aMN3BA1Nte1bHZNf3YaUiN2nAVBaAKR6AqZMPYOrEAFNnj2DqbBgm0WtlNWAqywNTHXtWx2TXPzClIjdrwFQOgKkLAFO8D2CKZ4Cpi0cwdTEMk+i1chowleOB6QV7Vsdkt8U9QtO3asD0CABTVwCmrj6AqSsDTN08gqmbYZhErz2iAdMjPDDVtWd1THZbXCwVuU0DplgApm4ATG/4AKY3GGB60yOY3jQMk+i1WA2YYnlgetGe1THZbXFVqcgdGjBVBWB6A4DpLR/A9BYDTG97BNPbhmESvVZVA6aqPDDVs2d1THZbXC0qcqcGTLUAmN4EYOruA5i6M8D0jkcwvWMYJtFrtTRgqsUDU317Vsdk13cDoiJ3acD0PADTWwBMPXwAUw8GmHp6BFNPwzCJXnteA6bneWBqYM/qmOz6ngtU5B4NmOoBML0NwNTLBzD1YoCpt0cw9TYMk+i1ehow1eOB6SV7Vsdk179spSL3asDUEICpOwBTHx/A1IcBpr4ewdTXMEyi1xpqwNSQB6aXbf9EF9eUitynAVNTAKZ3AJj6+QCmfgww9fcIpv6GYRK91lQDpqY8ML1iz+qY7PoqbSpyvwZMrQCYegAwDfABTAMYYHrXI5jeNQyT6LVWGjC14oGpoT2rY7Lra+GoyAMaMHUAYOoJwDTQBzANZIDpPY9ges8wTKLXOmjA1IEHplftWR2TXV9xQEX+qQFTVwCmXgBMg3wA0yAGmN73CKb3DcMkeq2rBkxdeWBqZM/qmOz6vA4VeUgDpu4ATL0BmAb7AKbBDDAN8QimIYZhEr3WXQOm7jwwNbZndUx2/e0ZFXlYA6Y+AEx9AJiG+gCmoQwwDfMIpmGGYRK91kcDpj48MDWxZ3VMdr1HoSKPaMA0EICpLwDTcB/ANJwBphEewTTCMEyi1wZqwDSQB6bX7Fkdk113AirymAZMQwGY+gEwjfQBTCMZYPrAI5g+MAyT6LWhGjAN5YGpqT2rY7Lb4kZRkSc0YBoFwNQfgGmUD2AaxQDThx7B9KFhmESvjdKAaRQPTM3sWR2T3RY3loo8qQHTWACmAQBMo30A02gGmMZ4BNMYwzCJXhurAdNYHpia27M6JrstbgIVeVoDpgkATO8CMH3kA5g+YoDpY49g+tgwTKLXJmjANIEHptftWR2T3RY3jYo8owHTNACmgQBMY30A01gGmMZ5BNM4wzCJXpumAdM0Hpha2LM6Jrt+YC8VeU4DpjkATO8BMH3iA5g+YYDpU49g+tQwTKLX5mjANIcHppb2rI7Jrh+LSEVe0IBpEQDTIACmz3wA02cMMI33CKbxhmESvbZIA6ZFPDC1smd1THb98Ckq8pIGTMsBmN4HYJrgA5gmMMA00SOYJhqGSfTacg2YlvPA1PrK/4qDmjEgP6glkvzQVIFoj9r2g5olmtb5cfcxUbTOT/O2omiTfFhxlJKTfhZr5JIlHzUZE0kr+SS9iCXLPigsUsnSz0GKULL8Y15ipFr5p1jIS47wJv3SkiO9B7ms5IhvsRyTdCjiO8hKSo78BplJS47y/n9JSo729mYxjn9He/cmZ8lR35zGUXL0996wl+zy1gIx4f9w+ctpW8lufxgaXrLr372Flez+Zz0xV/7P/a8Wrpas8KLsKyWrvOY0sWSll9TFJHxResVQqGS1F0QklKz4fO9/Jas+nRVDofrbelGy8i8jqWT137VkCQC3kjHAlTJ8IeB8BNVkBfXnWle61wr7QZOo7skUUyimUkyjmE4xg2ImxSyK2RRzKOZSzKOYT7GAYiHFIorFFEsollIso/icYjnFFxQrKL6k+Iria4qVFKs6hYpIGfoqikjnGJssGZsiGZsqGZsmGZsuGZshGZspGZslGZstGZsjGZsrGZsnGZsvGVsgGVsoGVskGVssGVsiGVsqGVsmGftcMrZcMvaFZGyFZOxLydhXkrGvJWMrJWOrQmPhj+yhr8HQV9nVdvzVq21rbqeo2sphV+bWvKjag+FX8db8aNqytit+a0EUbXH73YG1MLK2nuNOwloUUVvbeddhLY6k7Z7kDsVaEkHbPendjLVUrl0oufOxlkm1sbK7JOtzmbam9I7KWi7RLpbffVlfJNWWiHCnZq1Ioh0X6a7O+tKpLRPxDtD6yqHdG/lu0frarm0b5c7SWmnTVo92F2qtis6F7Y61ZWdLayO8N/Q1eGXkxk1i2CMmkvbGTWLC48ZNYsLjxk1iwuPGTWLClxs3iYHr8ibRbR+dpKg9evmyNVlZG7CmqGqp3qlq2qHiGmGakvbkf9cT01W0exOuPWYoaCuGrlNmumsHJ17TzHLVtr5y/TPbTbvk6rXSHKAf0GulRGcJuh27xM/QFp8e0Ah/tmol8GzVYODZqtXqx8azZ6uQGnVzfAPkuJbPVn0Drg3tN9FrKzWerVrJ82xVG3tWx2TXTyqlIlNowLQGgGkIANO3PoDpWwaYvvMIpu8MwyR6bY0GTGt4YGprz+qY7Pp5cFRkKg2YNgIwDQVgWuMDmNYwwPS9RzB9bxgm0WsbNWDayANTO3tWx2TXT92hItNowLQVgGkYANNaH8C0lgGmdR7BtM4wTKLXtmrAtJUHpvb2rI7Jrp9tQEWm04BpJwDTcACm9T6AaT0DTBs8gmmDYZhEr+3UgGknD0wd7Fkdk13fQZqKTK8B014AphEATBt9ANNGBph+8AimHwzDJHptrwZMe3lg6mjP6pjs+j6dVGRGDZgOADCNBGDa5AOYNjHA9KNHMP1oGCbRawc0YDrAA1Mne1bHZNd3Q6MiM2vAdBiA6QMAps0+gGkzA0xbPIJpi2GYRK8d1oDpMA9Mne1ZHZNd33OGisyiAdMJAKZRAExbfQDTVgaYfvIIpp8MwyR67YQGTCd4YIq3Z3VMdv3LfioyqwZMZwCYPgRg2uYDmLYxwLTdI5i2G4ZJ9NoZDZjO8MDUxZ7VMdn17yepyOwaMF0CYBoNwLTDBzDtYIDpZ49g+tkwTKLXLmnAdIkHpq72rI7Jrk+i1Q0EcmrAJOapaa3AGACmnT6AaScDTL94BNMvhmESvSZ6B61Lvd/kj6CSKmU3e1bHZNdfVVKRuTVgSg/A9BEA0y4fwLSLAabdHsG02zBMotfSa8CUngemN+xZHZNdbwipyLwaMGUBYPoYgGmPD2DawwDTrx7B9KthmESvZdGAKQsPTG/aszomu267VGR+DZhyAjCNBWDa6wOY9jLA9JtHMP1mGCbRazk1YMrJA9Nb9qyOya6LoyILasCUH4BpHADTPh/AtI8Bpt89gul3wzCJXsuvAVN+Hpjetmd1THZbXBFRpAZMRQCYPgFg2u8DmPYzwPSHRzD9YRgm0WtFNGAqwgNTd9s/0cWVoCKLaMBUAoDpUwCmAz6A6QADTAc9gumgYZhEr5XQgKkED0zv2LM6JrstrjQVWVQDptIATJ8BMP3pA5j+ZIDpfx7B9D/DMIleK60BU2kemHrYszomuy3uXiqymAZM9wIwjQdgOuQDmA4xwPSXRzD9ZRgm0Wv3asB0Lw9MPe1ZHZPdFleeiiyhAVN5AKYJAEyHfQDTYQaY/vYIpr8NwyR6rbwGTOV5YOplz+qY7La4GCqypAZMMQBMEwGYjvgApiMMMB31CKajhmESvRajAVMMD0y97Vkdk90WV4mKvEMDpkoATJMAmI75AKZjDDAd9wim44ZhEr1WSQOmSjww9bFndUx2W1w1KrK0BkzVAJgmAzCd8AFMJxhg+scjmP4xDJPotWoaMFXjgamvPatjstvinq4rNDhMTwMwTQFgOukDmE4ywHTKI5hOGYZJ9NrTGjA9zQNTP3tWx2S3xdWhIstqwFQHgGkqANNpH8B0mgGmfz2C6V/DMIleq6MBUx0emPrbszomuy2uARV5rwZMDQCYpgEwnfEBTGcYYDrrEUxnDcMkeq2BBkwNeGAaYM/qmOy2uEZU5P0aMDUCYJoOwHTOBzCdY4DpvEcwnTcMk+i1RhowNeKB6V17Vsdkt8U1pyLLacDUHIBpBgDTBR/AdIEBposewXTRMEyi15prwNScB6aB9qyOyW6La0NFlteAqQ0A00wApks+gOkSA0yXPYLpsmGYRK+10YCpDQ9M79mzOia7La4TFVlBA6ZOAEyzAJgCna9/mJAar07CclidvYHJ6mwWJtFrnTRg6sQD0yB7Vsdkt8W9QUU+ogHTGwBMswGYUvgAphQMMKX0CKaUhmESvfaGBkxv8MD0vj2rY7Lb4npQkTEaMPUAYJoDwJTKBzClYoAptUcwpTYMk+i1Hhow9eCBabA9q2Oy2+L6UZEVNWDqB8A0F4ApjQ9gSsMAU1qPYEprGCbRa/00YOrHA9MQe1bHZLfFDaIiYzVgGgTANA+AKZ0PYErHANNNHsF0k2GYRK8N0oBpEA9MQ+1ZHZPdFjeciqykAdNwAKb5AEzpfQBTegaYMngEUwbDMIleG64B03AemIbZszomuy1uNBVZRQOm0QBMCwCYMvoApowMMGXyCKZMhmESvTZaA6bRPDANt2d1THZb3CdUZFUNmD4BYFoIwJTZBzBlZoDpZo9gutkwTKLXPtGA6RMemEbYszomuy1uEhVZTQOmSQBMiwCYsvgApiwMMN3iEUy3GIZJ9NokDZgm8cBkbyd0cTOoyBoaMM0AYFoMwJTVBzBlZYApm0cwZTMMk+i1GRowzeCB6YMr/ysOasaA/KCWSPJDUwWiPb6xv6wkSzSt8+PuY6JonZ/mbUXRJvmw4iglJ/0s1sglSz5qMiaSVvJJehFLln1QWKSSpZ+DFKFk+ce8xEi18k+xkJcc4U36pSVHeg9yWckR32I5JulQxHeQlZQc+Q0yk5Yc5f3/kpQc7e3NYhz/jvbuTc6So745jaPk6O+9YS/Z5a0FYsL/4fKX07aS3f4wNLxk1797CyvZ/c96Yq78n/tfLVwtWeFF2VdKVnnNaWLJSi+piwlVo7L5hEpWe0FEQsmKz/f+V7Lq01kxFKq/rRclK/8ykkpW/11LlgBwKxkDXCnDFwLOR1BNVlB/rnWle62wH5Sd6s5BkZMiF0VuijwUeSnyUeSnKEBRkKKQWCNFYYoiFLdSFKW4jaIYRXGKEhS3U5SkKEVxB8WdFKUp7qIoQ3F351ARKUNfRRHpHGM5JGM5JWO5JGO5JWN5JGN5JWP5JGP5JWMFJGMFJWOFJGNByVhhyVgRyditkrGikrHbJGPFJGPFJWMlJGO3S8ZKSsZKScbukIzdKRkrLRm7SzJWRjJ2d2gs/JE+9DUY+prkarus7WrbKtI5sra4/crcujWytp7jKt4qGlFb23nFb90WSds9yd2BVSyCtnvSOwmruFy7UHLXYZWQamNldyjW7TJtTendjFUyyvF13vkUCFpahprZ7Zwn5BmcWFN+15paX6m/gJt2ydW1FnTRxocdl0LRtZXDj2Ewqvag7XgXlmgXy4+3VSqptkSEc2PdkUQ7LtJ5tO50astEPOdWaYd2b+T+sO6ya9tG6SWrjE1bPVrfWXcDPTqgs16Plg19DV4ZuXFDHPaIiaS9cUOc8LhxQ5zwuHFDnPC4cUMcqubGDfF1eUPs+vG0itqjly9bOZS1ASunqpbqzaWmHSquEXIraU/+dz2RR0W7N+HaI6+CtmLoOiUfcC6Aa2kLvaZJdIBgIHrdied6Hj0zUUvjGbR5wDNoS4Bn0MqqH0fPnkFDatTNcY9Hz6DdA64N7TfRa/M0nkGbx/MM2ih7Vsdkt8UtoSKf1oBpCQDTUgCme30A070MMN3nEUz3GYZJ9NoSDZiW8MD0oT2rY7Lb4lZQkc9qwLQCgGkZANP9PoDpfgaYHvAIpgcMwyR6bYUGTCt4YBptz+qY7La41VTk8xowrQZg+hyAqZwPYCrHANODHsH0oGGYRK+t1oBpNQ9MY+xZHZPdFreWiqyjAdNaAKblAEzlfQBTeQaYHvIIpocMwyR6ba0GTGt5YPrIntUx2W1xm6jIuhowbQJg+gKAqYIPYKrAANPDHsH0sGGYRK9t0oBpEw9MH9uzOia7LW4bFVlPA6ZtAEwrAJge8QFMjzDA9KhHMD1qGCbRa9s0YNrGA9NYe1bHZLfF7aIiG2jAtAuA6UsAphgfwBTDANNjHsH0mGGYRK/t0oBpFw9M4+xZHZPdFrePinxZA6Z9AExfATBV9AFMFRlgetwjmB43DJPotX0aMO3jgekT2z/Rxf1JRTbUgOlPAKavAZhifQBTLANMcR7BFGcYJtFrf2rA9CcPTJ/aszomu346LhXZSAOmIwBMKwGYKvkApkoMMFX2CKbKhmESvXZEA6YjPDB9Zs/qmOz6GYRUZBMNmE4CMK0CYKriA5iqMMD0hEcwPWEYJtFrJzVgOskD03h7Vsdk1096oiKbasB0DoBpNQBTVR/AVJUBpic9gulJwzCJXjunAdM5Hpgm2LM6Jrt+nsaLgUBzDZjEPDWtFfgGgKmaD2CqxgBTdY9gqm4YJtFronfQutT7Tf4IKqlSTnRktU92fddyKrKFBkxpAJi+BWCq4QOYajDAVNMjmGoahkn0WhoNmNLwwDTJntUx2fW9YanIVhowZQRg+g6AqZYPYKrFANNTHsH0lGGYRK9l1IApIw9Mk+1ZHZNd34GPimyjAVNWAKY1AExP+wCmpxlgesYjmJ4xDJPotawaMGXlgWmKPatjstviclOR7TRgyg3A9D0A07M+gOlZBpie8wim5wzDJHottwZMuXlgmmrP6pjstriCVGQHDZgKAjCtBWB63gcwPc8AU22PYKptGCbRawU1YCrIA9M0e1bHZLfFFaUiO2nAVBSAaR0AUx0fwFSHAaYXPILpBcMwiV4rqgFTUR6YptuzOia7La4kFRmvAVNJAKb1AEx1fQBTXQaYXvQIphcNwyR6raQGTCV5YJphz+qY7La4MlRkVw2YygAwbQBgqucDmOoxwFTfI5jqG4ZJ9FoZDZjK8MA0057VMdn1PReoyDc0YLofgGkjAFMDH8DUgAGmlzyC6SXDMIleu18Dpvt5YJplz+qY7PqXrVTkWxowVQBg+gGA6WUfwPQyA0yveATTK4ZhEr1WQQOmCjwwzbZndUx2/fshKrK7BkwVAZg2ATA19AFMDRlgetUjmF41DJPotYoaMFXkgWmOPatjsuurtKnIHhowVQFg+hGAqZEPYGrEAFNjj2BqbBgm0WtVNGCqwgPTXHtWx2TX18JRkb00YKoBwLQZgKmJD2BqwgDTax7B9JphmESv1dCAqQYPTPPsWR2TXV9xQEX20YDpWQCmLQBMTX0AU1MGmJp5BFMzwzCJXntWA6ZneWCab8/qmOz6vA4V2U8DproATFsBmJr7AKbmDDC97hFMrxuGSfRaXQ2Y6vLAtMCe1THZ9bdnVOQADZheBmD6CYCphQ9gasEAU0uPYGppGCbRay9rwPQyD0wL7Vkdk13vUajIgRowNQFg2gbA1MoHMLVigKm1RzC1NgyT6LUmGjA14YFpkT2rY7LrTkBFDtKAqQUA03YApjY+gKkNA0xtPYKprWGYRK+10ICpBQ9Mi+1ZHZNdXxJPRQ7WgKkdANMOAKZ2PoCpHQNM7T2Cqb1hmESvtdOAqR0PTEvsWR2TXV94SEUO1YApHoDpZwCmDj6AqQMDTB09gqmjYZhEr8VrwBTPA9NSe1bHZNeXd1CRwzVgeguAaScAUycfwNSJAabOHsHU2TBMotfe0oDpLR6YltmzOia7PolGRY7UgKkXANMvAEzxPoApngGmLh7B1MUwTKLXemnA1IsHps/tWR2TXX9VSUWO0oBpAADTLgCmrj6AqSsDTN08gqmbYZhErw3QgGkAD0zL7Vkdk11vCKnI0RowDQZg2g3A9IYPYHqDAaY3PYLpTcMwiV4brAHTYB6YvrBndUx23XapyI80YBoJwLQHgOktH8D0FgNMb3sE09uGYRK9NlIDppE8MK2wZ3VMdl0cFTlWA6aPAJh+BWDq7gOYujPA9I5HML1jGCbRax9pwPQRD0xfXvlfcVAzBuQHtUSSH5oqEO1xj/2gZommdX7cfUwUrfPTvK0o2iQfVhyl5KSfxRq5ZMlHTcZE0ko+SS9iybIPCotUsvRzkCKULP+YlxipVv4pFvKSI7xJv7TkSO9BLis54lssxyQdivgOspKSI79BZtKSo7z/X5KSo729WYzj39HevclZctQ3p3GUHP29N+wlu7y1QEz4P1z+ctpWstsfhoaX7Pp3b2Elu/9ZT8yV/3P/q4WrJSu8KPtKySqvOU0sWekldTEJX5ReMRQqWe0FEQklKz7f+1/Jqk9nxVCo/rZelKz8y0gqWf13LVkCwK1kDHClDF8IOB9BNVlB/bnWle61wn5QD6q7J0Uvit4UfSj6UvSj6E8xgOJdioEU71EMonifYjDFEIqhFMMohlOMoBhJ8QHFKIoPKUZTjKH4iOJjirEU4zqHikgZ+iqKSOcY6ykZ6yUZ6y0Z6yMZ6ysZ6ycZ6y8ZGyAZe1cyNlAy9p5kbJBk7H3J2GDJ2BDJ2FDJ2DDJ2HDJ2AjJ2EjJ2AeSsVGSsQ8lY6MlY2MkYx9Jxj6WjI2VjI0LjYU/0oe+BkNfk1xtl7VdbVuDO0fWFrdfmVtDImvrOa7iraERtbWdV/zWsEja7knuDqzhEbTdk95JWCPk2oWSuw5rpFQbK7tDsT6QaWtK72asUVGOr/PO54GgpWWomd3OeUKewYk1DXCtqfWV+t910y65utaBLtr4sOPyXnRt5fBjOCiq9qDteL8v0S6WH2/rw6TaEhHOjTU6iXZcpPNojXFqy0Q859ZHDu3eyP1hfWzXto3SS9ZYm7Z6tL6zxgE9OrmzXo+WDX0NXhm5cUMc9oiJpL1xQ5zwuHFDnPC4cUOc8LhxQ5zw5cYNceC6vCF2fW8URe3Ry5etnsragNVLVUv19lbTDhXXCH2UtCf/u57oq6Ldm3Dt0U9BWzF0ndIfOBfAtbSFXtMkOkAwEL3uxHP9GT0z8YnGM2ifAc+g7QWeQftE/Th69gwaUqNujk+BHNfyGbRPwbWh/SZ67TONZ9A+43kG7SvbP9HFTaEiP9OAaQoA028ATJ/5AKbPGGAa7xFM4w3DJHptigZMU3hg+tqe1THZbXGzqMgJGjDNAmDaB8A0wQcwTWCAaaJHME00DJPotVkaMM3igWmlPatjstviFlCRkzRgWgDA9DsA0yQfwDSJAabJHsE02TBMotcWaMC0gAemVfasjslui1tGRU7RgGkZANN+AKYpPoBpCgNMUz2CaaphmESvLdOAaRkPTKvtWR2T3Rb3FRU5TQOmrwCY/gBgmuYDmKYxwDTdI5imG4ZJ9NpXGjB9xQPTN/asjslui/uWipyhAdO3AEwHAJhm+ACmGQwwzfQIppmGYRK99q0GTN/ywPStPatjstvi1lORszRgWg/AdBCAaZYPYJrFANNsj2CabRgm0WvrNWBazwPTd/asjslui9tMRc7RgGkzANOfAExzfADTHAaY5noE01zDMIle26wB02YemNbYszomuy1uBxU5TwOmHQBM/wNgmucDmOYxwDTfI5jmG4ZJ9NoODZh28MD0vT2rY7Lb4vZQkQs0YNoDwHQIgGmBD2BawADTQo9gWmgYJtFrezRg2sMD01p7Vsdkt8XtpyIXacC0H4DpLwCmRT6AaREDTIs9gmmxYZhEr+3XgGk/D0zr7Fkdk90Wd4iKXKIB0yEApsMATEt8ANMSBpiWegTTUsMwiV47pAHTIR6Y1tuzOia7Le4YFblMA6ZjAEx/AzAt8wFMyxhg+twjmD43DJPotWMaMB3jgWmDPatjstviTlORyzVgOg3AdASAabkPYFrOANMXHsH0hWGYRK+d1oDpNA9MG+1ZHZPdFneBilyhAdMFAKajAEwrfADTCgaYvvQIpi8NwyR67YIGTBd4YPrBntUx2W1xKeoFAl9pwCTmqWmtwDEApq98ANNXDDB97RFMXxuGSfSa6B20LvV+kz+CSqqUm+xZHZPdFpeOilypAVM6AKbjAEwrfQDTSgaYVnkE0yrDMIleS6cBUzoemH60Z3VMdltcZipytQZMmQGYTgAwrfYBTKsZYPrGI5i+MQyT6LXMGjBl5oFpsz2rY7Lb4rJTkd9qwJQdgOkfAKZvfQDTtwwwfecRTN8Zhkn0WnYNmLLzwLTFntUx2W1xeanINRow5QVgOgnAtMYHMK1hgOl7j2D63jBMotfyasCUlwemrfasjsluiwtSkWs1YAoCMJ0CYFrrA5jWMsC0ziOY1hmGSfRaUAOmIA9MP9mzOia7La4YFbleA6ZiAEynAZjW+wCm9QwwbfAIpg2GYRK9VkwDpmI8MG2zZ3VMdlvcHVTkRg2Y7gBg+heAaaMPYNrIANMPHsH0g2GYRK/doQHTHTwwbbdndUx2W1xZKnKTBkxlAZjOADBt8gFMmxhg+tEjmH40DJPotbIaMJXlgWmHPatjstviylGRmzVgKgfAdBaAabMPYNrMANMWj2DaYhgm0WvlNGAqxwPTz/asjslui3uEityqAdMjAEznAJi2+gCmrQww/eQRTD8Zhkn02iMaMD3CA9NOe1bHZLfFxVKR2zRgigVgOg/AtM0HMG1jgGm7RzBtNwyT6LVYDZhieWD6xZ7VMdltcVWpyB0aMFUFYLoAwLTDBzDtYIDpZ49g+tkwTKLXqmrAVJUHpl32rI7JbourRUXu1ICpFgDTRQCmnT6AaScDTL94BNMvhmESvVZLA6ZaPDDttmd1THZb3PNU5C4NmJ4HYLoEwLTLBzDtYoBpt0cw7TYMk+i15zVgep4Hpj32rI7JbourR0Xu0YCpHgDTZQCmPT6AaQ8DTL96BNOvhmESvVZPA6Z6PDD9as/qmOy2uIZU5F4NmBoCMAWaqdez1wcw7WWA6TePYPrNMEyi1xpqwNSQB6a9tn+ii2tKRe7TgKkpAJMFwLTPBzDtY4Dpd49g+t0wTKLXmmrA1JQHpt/sWR2T3RbXiorcrwFTKwCmFABM+30A034GmP7wCKY/DMMkeq2VBkyteGDaZ8/qmOy2uA5U5AENmDoAMKUEYDrgA5gOMMB00COYDhqGSfRaBw2YOvDA9Ls9q2Oy2+K6UpF/asDUFYApFQDTnz6A6U8GmP7nEUz/MwyT6LWuGjB15YFpvz2rY7Lb4rpTkYc0YOoOwJQagOmQD2A6xADTXx7B9JdhmESvddeAqTsPTH/Yszomuy2uDxV5WAOmPgBMaQCYDvsApsMMMP3tEUx/G4ZJ9FofDZj68MB0wJ7VMdltcQOpyCMaMA0EYEoLwHTEBzAdYYDpqEcwHTUMk+i1gRowDeSB6eCV/xUHNWNAflBLJPmhqQLRHp/aD2qWaFrnx93HRNE6P83biqJN8mHFUUpO+lmskUuWfNRkTCSt5JP0IpYs+6CwSCVLPwcpQsnyj3mJkWrln2IhLznCm/RLS470HuSykiO+xXJM0qGI7yArKTnyG2QmLTnK+/8lKTna25vFOP4d7d2bnCVHfXMaR8nR33vDXrLLWwvEhP/D5S+nbSW7/WFoeMmuf/cWVrL7n/XEXPk/979auFqywouyr5Ss8prTxJKVXlIXk/BF6RVDoZLVXhCRULLi873/laz6dFYMhepv60XJyr+MpJLVf9eSJQDcSsYAV8rwhYDzEVSTFdSfa13pXivsBx2juo9TnKD4h+IkxSmK0xT/UpyhOEtxjuI8xQWKixSXKC5TBOLp51GkoEhJkYoiNUUairQU6ShuokhPkYEiI0Wm+FARKUNfRRHpHGPHJWMnJGP/SMZOSsZOScZOS8b+lYydkYydlYydk4ydl4xdkIxdlIxdkoxdloyJk+AcsyRjKSRjKSVjqSRjqSVjaSRjaSVj6SRjN0nG0kvGMkjGMkrGMoXGwh/pQ1+Doa9JrrbL2q62rUudI2uL26/MrcuRtfUcV/GWOD9ybW3nFb9lRdJ2T3J3YKWIoO2e9E7CSinXLpTcdVippNpY2R2KlVqmrSm9m7HSxEc5F447n6eClpahZnY75wl5BifWdKazm7b1lfrPummXXF3rORdtfNhxOR9dWzn8GF6Iqj1oO94XJdrF8uNtpU16bkpEODdWuiTacZHOo3WTU1sm4jm30ju0eyP3h5XBrm0bpZesjDZt9Wh9Z2UCenR1Z70eLRv6GrwycuOGOOwRE0l744Y44XHjhjjhceOGOOFx44Y44cuNG+LAdXlD7Po5eYrao5cvW8eVtQHrhKqW6v1HTTtUXCOcVNKe/O964pSKdm/CtcdpBW3F0HXKv8C5AK6lLfSaJtEBgoHodSee66H0zMQxjWfQhgLPoKUDnkHLHK9cg2fPoCE16ua4GchxLZ9BuxlcG9pvoteGajyDNpTnGbQ/7Vkdk90WN4qKPKEB0ygAppsAmLL4AKYsDDDd4hFMtxiGSfTaKA2YRvHA9D97Vsdkt8WNpSJPasA0FoApPQBTVh/AlJUBpmwewZTNMEyi18ZqwDSWB6ZD9qyOyW6Lm0BFntaAaQIAUwYApuw+gCk7A0w5PIIph2GYRK9N0IBpAg9Mf9mzOia7LW4aFXlGA6ZpAEwZAZhy+gCmnAww5fIIplyGYRK9Nk0Dpmk8MB22Z3VMdlvcHCrynAZMcwCYMgEw5fYBTLkZYMrjEUx5DMMkem2OBkxzeGD6257VMdltcYuoyAsaMC0CYMoMwJTXBzDlZYApn0cw5TMMk+i1RRowLeKB6Yg9q2Oy2+KWU5GXNGBaDsB0MwBTfh/AlJ8BpgIewVTAMEyi15ZrwLScB6aj9qyOya6f601FBhrjMK0EYMoCwFTQBzAVZICpkEcwFTIMk+i1lRowreSB6Zg9q2Oy66enUpEpNGBaA8B0CwBT0AcwBRlgKuwRTIUNwyR6bY0GTGt4YDpuz+qY7PoZdVRkKg2YNgIwZQVgKuIDmIowwHSrRzDdahgm0WsbNWDayAPTCXtWx2TXTwKiItNowLQVgCkbAFNRH8BUlAGm2zyC6TbDMIle26oB01YemP6xZ3VMdv28BSoynQZMOwGYsgMwFfMBTMUYYCruEUzFDcMkem2nBkw7eWA6ac/qmOz6rtZUZHoNmPYCMOUAYCrhA5hKMMB0u0cw3W4YJtFrezVg2ssD0yl7Vsdk1/cOpSIzasB0AIApJwBTSR/AVJIBplIewVTKMEyi1w5owHSAB6bT9qyOya7v0EZFZtaA6TAAUy4Apjt8ANMdDDDd6RFMdxqGSfTaYQ2YDvPA9K89q2Oy60viqcgsGjCdAGDKDcBU2gcwlWaA6S6PYLrLMEyi105owHSCB6Yz9qyOya4vPKQis2rAdAaAKQ8AUxkfwFSGAaa7PYLpbsMwiV47owHTGR6YztqzOia7vryDisyuAdMlAKa8AExlfQBTWQaY7vEIpnsMwyR67ZIGTJd4YDpnz+qY7PokWv1AIKcGTGKemtYK5ANgutcHMN3LANN9HsF0n2GYRK+J3kHrUu83+SOopEp53p7VMdn1V5VUZG4NmNIDMOUHYLrfBzDdzwDTAx7B9IBhmESvpdeAKT0PTBfsWR2TXW8Iqci8GjBlAWAqAMBUzgcwlWOA6UGPYHrQMEyi17JowJSFB6aL9qyOya7bLhWZXwOmnABMBQGYyvsApvIMMD3kEUwPGYZJ9FpODZhy8sB0yZ7VMdl1cVRkQQ2Y8gMwFQJgquADmCowwPSwRzA9bBgm0Wv5NWDKzwPTZemwlQr5IQHrqZbq2mcA7XOAtjagfQHQvgho6wPalwDtK4D2VUDbGNC+BmibAdrXAW1LQNsa0LYFtO0BbUdA2xnQdgG03QDtm4D2bUD7DqDtCWh7A9q+gLY/oH0X0L4HaN8HtEMA7TBAOwLQfgBoPwS0YwDtx4B2HKD9EtB+DWhXAdpvAO13gPZ7QLsO0G4AtD8A2h8B7RZA+xOg3Q5ofwa0vwDa3YD2V0D7G6D9HdD+AWgPAtr/Adq/AO3fgPYooD0OaP8BtKcA7b+A9iygPQ9oLwLay4DWaqWuTQloUwPatID2JkCbAdBmArR3Atq7AO3dgPYeQHsfoH0A0D4IaB8CtA8D2kcB7WOA9nFAGwdoKwPaJwDtk4C2OqCtCWifArTPANrnAG1tQPsCoH0R0NYHtC8B2lcA7auAtjGgfQ3QNgO0rwPaloC2NaBtC2jbA9qOgLYzoO0CaLsB2jGA9mNAOw7QfgpoxwPaiYB2MqCdCminA9qZgHY2oJ0LaOcD2oWAdjGgXQpoPwe0XwDaLwHt14B2FaD9BtB+B2i/B7TrAO0GQPsDoP0R0G4BtD8B2u2A9mdA+wug3Q1ofwW0vwHa3wHtH4D2IKD9H3IP2Rq4hwS0mQDtzYD2FkCbDdDmALS5AG0eQJsP0BYAtIUAbWFAeyugvQ3QFge0twPaUoD2TkB7F6C9G9DeA2jvA7QPANoHAe1DgPZhQPsooH0M0D4OaOMAbWVA+wSgfRLQVge0NQHtU4D2GUD7HKCtDWg7A9ougLYboH0T0L4NaN8BtD0BbW9A2xfQ9ge07wLa9wDt+4B2CKAdBmhHANoPAO2HgHYMoP0Y0I4DtJ8C2vGAdiKgnQxopwLa6YB2JqCdDWjnAtr5gHYhoF0MaJcC2s8B7ReA9ktA+zWgXQVovwG0fwDag4D2f4D2L0D7N6A9CmiPA9p/AO0pQPsvoD0LaM8D2ouA9jKgtdqoa1MC2tSANi2gvQnQZgC0mQDtzYD2FkCbDdDmALS5AG0eQJsP0BYAtIUAbWFAeyugvQ3QFge0twPaUoD2TkB7F6C9G9DeA2ifAbTPAdragPYFQPsioK0PaF8CtK8A2lcBbWNA+xqgbQZoXwe0LQFta0DbFtC2B7QdAW1nQNsF0HYDtG8C2rcB7TuAtieg7Q1o+wLa/oD2XUD7HqB9H9AOAbTDAO0IQPsBoP0Q0I4BtB8D2nGA9lNA+zWgXQVovwG03wHa7wHtOkC7AdD+AGh/BLRbAO1PgHY7oP0Z0P4CaHcD2l8B7W+A9ndA+wegPQho/wdo/wK0fwPao4D2OKD9B9CeArT/AtqzgPY8oL0IaC8DWqst8HsNQJsa0KYFtDcB2gyANhOgvRnQ3gVo7wa09wDa+wDtA4D2QUD7EKB9GNA+CmgfA7SPA9o4QFsZ0D4BaJ8EtNUBbU1A+xSgfQbQPgdoawPaFwDti4C2PqB9CdC+AmhfBbSNAe1rgLYZoH0d0LYEtK0BbVtA2x7QdgS0nQFtF0DbDdC+CWg/BrTjAO2ngHY8oJ0IaCcD2qmAdjqgnQloZwPauYB2PqBdCGgXA9qlgPZzQPsFoP0S0H4NaFcB2m8A7XeA9ntAuw7QbgC0PwDaHwHtFkD7E6DdDmh/BrS/ANrdgPZXQPsboP0d0P4BaA8C2v8B2r+Qe8h2wD0koL0Z0N4CaLMB2hyANhegzQNo8wHaAoC2EKAtDGhvBbS3AdrigPZ2QFsK0N4JaO8CtHcD2nsA7X2A9gFA+yCgfQjQPgxoHwW0jwHaxwFtHKCtDGifALRPAtrqgLYmoH0K0D4DaJ8DtLUB7QuAtgug7QZo3wS0bwPadwBtT0DbG9D2BbT9Ae27gPY9QPs+oB0CaIcB2hGA9gNA+yGgHQNoPwa04wDtp4B2PKCdCGgnA9qpgHY6oJ0JaGcD2rmAdj6gXQhoFwPapYD2c0D7BaD9EtB+DWhXAdpvAO13gPYgoP0foP0L0P4NaI8C2uOA9h9AewrQ/gtozwLa84D2IqC9DGit9uralIA2NaBNC2hvArQZAG0mQHszoL0F0GYDtDkAbS5AmwfQ5gO0BQBtIUBbGNDeCmhvA7TFAe3tgLYUoL0T0N4FaO8GtPcA2vsA7XOAtjagfQHQvgho6wPalwDtK4D2VUDbGNC+BmibAdrXAW1LQNsa0LYFtO0BbUdA2xnQdgG03QDtm4D2bUD7DqDtCWh7A9q+gLY/oH0X0L4HaN8HtEMA7TBAOwLQfgBoPwS0YwDtx4B2HKD9FNCOB7SrAO03gPY7QPs9oF0HaDcA2h8A7Y+Adgug/QnQbge0PwPaXwDtbkD7K6D9DdD+Dmj/ALQHAe3/AO1fgPZvQHsU0B4HtP8A2lOA9l9AexbQnge0FwHtZUBrdQB+rwFoUwPatID2JkCbAdBmArQ3A9pbAO3dgPYeQHsfoH0A0D4IaB8CtA8D2kcB7WOA9nFAGwdoKwPaJwDtk4C2OqCtCWifArTPANrnAG1tQPsCoH0R0NYHtC8B2lcA7auAtjGgfQ3QNgO0rwPaloC2NaBtC2jbA9qOgLYzoO0CaLsB2jcB7duAdhyg/RTQjge0EwHtZEA7FdBOB7QzAe1sQDsX0M4HtAsB7WJAuxTQfg5ovwC0XwLarwHtKkD7DaD9DtB+D2jXAdoNgPYHQPsjoN0CaH8CtNsB7c+A9hdAuxvQ/gpofwO0vwPaPwDtQUD7P0D7F6D9G7mH7AjcQwLaWwBtNkCbA9DmArR5AG0+QFsA0BYCtIUB7a2A9jZAWxzQ3g5oSwHaOwHtXYD2bkB7D6C9D9A+AGgfBLQPAdqHAe2jgPYxQPs4oI0DtJUB7ROA9klAWx3Q1gS0TwHaZwDtc4C2NqB9AdC+CGi7Ado3Ae3bgPYdQNsT0PYGtH0BbX9A+y6gfQ/Qvg9ohwDaYYB2BKD9ANB+CGjHANqPAe04QPspoB0PaCcC2smAdiqgnQ5oZwLa2YB2LqCdD2gXAtrFgHYpoP0c0H4BaL8EtF8D2lWA9htA+x2g/R7Q/g/Q/gVo/wa0RwHtcUD7D6A9BWj/BbRnAe15QHsR0F4GtFYndW1KQJsa0KYFtDcB2gyANhOgvRnQ3gJoswHaHIA2F6DNA2jzAdoCgLYQoC0MaG8FtLcB2uKA9nZAWwrQ3glo7wK0dwPaewDtfYD2AUBbG9C+AGhfBLT1Ae1LgPYVQPsqoG0MaF8DtM0A7euAtiWgbQ1o2wLa9oC2I6DtDGi7ANpugPZNQPs2oH0H0PYEtL0BbV9A2x/Qvgto3wO07wPaIYB2GKAdAWg/ALQfAtoxgPZjQDsO0H4KaMcD2omA9htA+x2g/R7QrgO0GwDtD4D2R0C7BdD+BGi3A9qfAe0vgHY3oP0V0P4GaH8HtH8A2oOA9n+A9i9A+zegPQpojwPafwDtKUD7L6A9C2jPA9qLgPYyoLU6A7/XALSpAW1aQHsToM0AaDMB2psB7S2ANhugvQfQ3gdoHwC0DwLahwDtw4D2UUD7GKB9HNDGAdrKgPYJQPskoK0OaGsC2qcA7TOA9jlAWxvQvgBoXwS09QHtS4D2FUD7KqBtDGhfA7TNAO3rgLYloG0NaNsC2vaAtiOg7QxouwDaboD2TUD7NqB9B9B+CmjHA9qJgHYyoJ0KaKcD2pmAdjagnQto5wPahYB2MaBdCmg/B7RfANovAe3XgHYVoP0G0H4HaL8HtOsA7QZA+wOg/RHQbgG0PwHa7YD2Z0D7C6DdDWh/BbS/AdrfAe0fgPYgoP0foP0L0P4NaI8i95DxwD0koM0GaHMA2lyANg+gzQdoCwDaQoC2MKC9FdDeBmiLA9rbAW0pQHsnoL0L0N4NaO8BtPcB2gcA7YOA9iFA+3CYtkyjGu1+u/uT25fUilv0zjt16pe4588qXZa2GfL4b6eGHaPvP6L+cwMWRcrQ18R5qSgyhsadj9yhr8ErI6kC0R4Or8oSTev0qpgoWqdXWVG0SbwqSslJvSpyyRKviomklXhVxJJlXhWpZKlXRShZ7lUxUq3cq+QlR/AqacmRvEpWckSvikk6FNGrJCVH9qqkJUfxqiQlR/OqGMe/o3mVs+SoXuUoObpX2Ut28aqY8H+4eJWt5IcB/5E9gmqygvpzrSsFW2E/6FGqO4biMYqKFI9TxFLEUVSiqExRheIJiqoUT1JUo6hOUYOiJkUtiqconqZ4huJZiuconqeoTVGH4gWKuhQvUtSLD9hNWBSRzjEWIxl7TDJWUTL2uGQsVjIWJxmrJBmrLBmrIhl7QjJWVTL2pGSsmmSsumSshmSspmSslmTsKcnY05KxZyRjz0rGnpOMPS8Zqy0ZqyMZe0EyVlcy9qJkrF5oLPyRPvQ1GPoquYioHHYRYT0Z9YLjYPgFh1Utmras7eLEqh5FW9x+IWPViKyt57josWpG1NZ2XiBZtSJpuye5mLKeiqDtnvTCy3parl0ouUizngEu6BoXsbQMNfI5j5XlsZ6V1VRTWpP1nES7WF6/9XxSbYkIa7VqJ9GOi3RcrDpObZmIx9B6waHdG/l4W3Xt2rZRzo31ok1bPdp5tOoB57yJ5jkv5jjnNy7QbY+YSNobF+gJjxsX6AmP/y8X6G4+9Kii9ujly1aMsjZgPaaqpdorqmmHCo99XEl78j8/jlXR7k3w7jgFbcWQz1dy1w5O3BMqu2pbX9k/qrhpl1zda55w0caH7UtVo/eOrY+AaxFLdw9LEfoaVJOnLFBfvZ/rq6/Vdk2dOE/gnD6sRqceqNtCapE9gmqyVOG1NohP+PqS88ZTfKOgY0yInAtNiSW3LdLFQC42AIzpJeDgISfNLW8DtbyW/PenqnPttb4cOmmvOE/aK5JinCcIWZCbu74MnKBXNA8UekJeBtwr/B9Bx1e3qZ+0VNRSlk8VtaKgz1qqN8V4JW3CMieoaENHZKKCNvHgTXLXXjnOk121V0/JFDdt2Nmb6qINP9HTWqpfGU2PqrVJAzOiae3SwMyW6leTsyJrndLA7IjaJNLAnJbqV+BzI2gl0sA8uVYmDcxvqX7XskCmlUsDCyXaCNLAopbqd3qLk2gjSgNLnNrI0sDSlup3x8vs2mjSwOc2bVRpYHm4Nro08IWq99FPKtVK3bsbal4BBR1fo1cUCGRupe7HN6tp/ztiWZS0CQf3FhVt6DxkVdAmnrJs7torZze7q/ZqI+Rw04b1TM5W6n6cq5W6H+dupe7HeVqp+3HeVup+nK+Vuh/nb6XuxwVaqftxwVbqflyolbofB1up+3HhVup+XKSVuh/f2krdj4u2Uvfj21qp+3GxVup+XLyVuh+XaKXux7e3Uvfjkop+Jn7SKGWtFfgQ8O5XGbxbHIY3AD9+E/DjtwA/fhvw4+6AH78D+HEPwI97An7cC/Dj3oAf9wH8uC/gx/0AP+4P+PEAwI/fBfx4IODH7wF+PAjw4/cBPx4M+PEQwI+HAn48DPDj4YAfjwD8eCTgxx8Afpy6tbofp1HVUn1pW6t7dyNN7058qUzQXfrfETsE+PFfgB8fBvz4b8CPjwB+fBTw42OAHx8H/PgE4Mf/AH58EvDjU4Afnwb8+F/Aj88AfnwW8ONzgB+fB/z4AuDHFwE/vgT48WXAjwOt1f3Yaq3uxylaq/txytbqfpxK0TfFj+kI+GbjMN+89WzqlZe7lEi9OFWGDatyZG9RZf3nOR9p16fzL29/1/pogUy9PluvVoPzoe6xCQehjspaQ8frBQVt4qGt6669chZedNVePWH13LRh57Z+a3XfbNBa3Tdfaq3umy+3VvfNV1qr+2bD1uq++Wprdd9s1FrdNxu3VvfNJq3VffO11uq+2bS1um82a63um81bq/vm663VfbNFa3XfbAn4ZivAN1sDvtkG8M22ytemAetXNe1/GX8HPLZJmMdmHtZ/+fPPFPuqXHyWGv9m31709L1zOuTdfzhDwWx3FLmYqWfFVaY9NnS8vgV88zvAN9cAvvk94JtrAd9cB/jmesA3NwC+uRHwzR8A39wE+OaPgG9uBnxzC+CbWwHf/AnwzW2Ab24HfHMH4Js/A765E/DNXwDf3AX45m7AN/cAvlmtjarWClRX0iYU91QbdY99LcxjUze4dc0HDw6bkfav2lmDRwcfL5BtZI0qt93VYsp9cW/u7vnY/P2aHps39DUYUKk+ELjXfa1XzsJ9rtqrJ+x+N23YuX2gjbpvlmuj7psPtlH3zfJt1H3zoTbqvlmhjbpvPtxG3TcfaaPum4+2UffNmDbqvvlYG3XfrNhG3Tcfb6Pum7Ft1H0zro26b1Zqo+6blduo+2aVNuq++UQbdd+s2kbdN58EPKtpmGdlK3VvmlHFinde+X67kt+8XunwzD8P1N16MP/qNYM+nf34Y/P2tyqo98pTRc+6sqrPAB8aD/jQBMCHJgI+NAnwocmAD00BfGgq4EPTAB+aDvjQDMCHZgI+NAvwodmAD80BfGgu4EPzAB+aD/jQAsCHFgI+tAjwocWADy1xv/a48pOKtVX3rGbhnvVptrjqwypX2/7t1NXPPHrz3xlfX1Rh7z8vxn/bbd0fQ+b9PuY9o5519QBkaavuQ7e0VfehrG3VfShbW3Ufyt5W3YdytFX3oZxt1X0oV1t1H8rdVt2H8rRV96G8bdV9KF9bdR/K31bdhwq0Vfehgm3VfahQW3UfCrZV96HCbdV9qEhbdR+6ta26DxVtq+5Dt7mxefVhDVPWWoHhgGc1D/OsEosXZj9Tc1fmsfUX/1E09UtDHtny3eKzX5Z+ttS+XBmL/D76wxmanpU79DUYiFr2lcdbgA+9DfhQd8CH3gF8qAfgQz0BH+oF+FBvwIf6AD7UF/ChfoAP9Qd8aADgQ+8CPjQQ8KH3AB8aBPjQ+4APDQZ8aAjgQ0MBv3g9/Bqnc9k37yr97vCh1evsfmzFiymy3DU+X682a0v9+tT6/c+MHnV70w3q2rUGvSV8+YcBv/gb8IsjgF8cBfziGOAXxwG/OAH4xT+AX5wE/OIU4BenAb/4F/CLM4BfnAX84hzgF+cBv7gA+MVFwC8uAX5xGbhuadlO3VtahHnLXQ891KzDN6tO7K6fc0DRH9efKHly0PhjB5+6FPdNhlfOjSoxuv8Gde2f5rzFdqTqtlP3ixfbqftFvXbqflG/nbpfNGin7hcvtVP3i5fbqfvFK+3U/aJhO3W/eLWdul80aqfuF43bqftFk3bqfvFaO3W/aNpO3S+atVP3i+bt1P3i9XbqftGinbpf7FTWWoFfAG9pGeYtt0/Pt3j52yWfyJXi8092Xrw8aOctC9u980/3cyse752zRIkP007boK5NU0jPW7KHvgYDkdcX/lgD+MX3gF+sBfxiHeAX6wG/2AD4xUbAL34A/GIT4Bc/An6xGfCLLYBfbAX84ifAL7YBfrEd8IsdgF/8DHDdKozr7H9WT3Gm18QKH3+5JOW87WPX9c6z9cE6RR8++PfzGVL/+WGaol06GWLVsZ7726vz90B7df7KtVfn78H26vyVb6/O30Pt1fmr0F6dv4fbq/P3SHt1/h5tr85fTHt1/h5rr85fxfbq/D3eXp2/2Pbq/MW1V+evUpT+dTysBe3VWW0dxmqBe6qP+frp5nPeK39z5bLpt7y5pU/ze7a9379HyX+61+6S5tahHxhi1bn0CQB/EwH+JgH8TQb4mwLwNxXgbxrA33SAvxkAfzMB/mYB/M0G+JsD8DcX4G8ewN98gL/CHdSvl4t0UGe1TRirOU83n7hzcO0OL3xTu+mtqZ77vnaZ+IefO792TYGhH3WddOuQJgs1Wc0a+hoMRCjYqe+gzl+2Dur8Ze+gzl+ODur85eygzl+uDur85e6gzl+eDur85e2gzl++Dur85e+gzl+BDur8Feygzl+hDur8BQFO2oZxkssaMqjQvq8+ndykw68b70ld866j7bO3Lzqswxs/vLZ0/pDGfbuE3Su6absWMsFU0oV3Bzh5B+CkB8BJT4CTXgAnvQFO+gCc9AU46Qdw0h/gZADAybsAJwMBTt5T3nsC1nmAqXZhTBUp0WVLuyf/Plql5+EBF/a9W/zIoap3j/n70S1LR0/6rnDjPn1HhHHiph1pginJMToCcHIU4OQYwMlxgJMTACf/AJycBDg5BXByGuDkX4CTMwAnZwFOzgGcNO2ofj3XrKM6U+3DmCp8Ytr0Uzc9deKvbn2mbvkwTauJa/dMen7XzBG/fpsv/8Q+farNDePETTtPk6nMoa/BgGxlSR/1OqpzUr+jOicNOqpz8lJHdU5e7qjOySsd1Tlp2FGdk1c7qnPSqKM6J407qnPSpKM6J68B/dwhrJ/z9/3x02FjT305pvFfD2QYMbHHrGEPTf0q5d7qNfM3uXdRnyer3935mveodCVrgb5bB/TdeqDvNgB9txHoux+AvtsE9N2PQN9tBvpuC9B3W5U9N2BV7KTeox3DevTODNMen/7bwdub7GuQb/4vy/Ok+vH9KnPL1bn7+UCttAeerNa85jXvUfmiy3VS77sHO6n3XflO6n33UCf1vqvQSb3vHu6k3nePdFLvu0c7qfddTCf1vnusk3rfzVbWWoE5QI92Cv/762bP7um9uuLHfb+olrZjtxPN2lZ/rlam4wOq7H94Sf1S1ZplbanZoxlDX4NJS5U+JgF9NxnouylA300F+m4a0HfTgb6bAfTdTKDvZgH90TmsPzK8N7z5//reclvqzs9Vvmngnd/XP1y3/8Y3dq/OOb5jTMZmtywoELSUtQOucS9FWnL2zur9kaOzen/k7KzeH7k6q/dH7s7q/ZGns3p/5O2s3h/5gI8n7t9ZvZfiw/8OeebS/nsePp994L3TBs558fNStS+U6d9t5vEunT7+fP2Dt8xf9UBYL7lpJ1/bXop4dHoA/dET6I9eQH/0BvqjD9AffYH+6Af0x2llrRX4F+ilLmG9ZJ2p89rOkjWnjKn4SvXSQze1rJSv1sXm91dpM/WxVPuOz1+576mwXnLTrgZ6SXzQRFqK1FdWQP9O6VxVwiMYUDsIwHtva+dYzpDjc4YcyxhyLGXIsYQhx2KGHIsYcixkyLGAIcd8hhzzGHLMZcgxhyHHbIYcsxhyzGTIMYMhx3SGHNMYckxlyDGFIcdkhhyTGHJMZMgxgSHHeIYcnzHk+JQhxycMOUq1Mp+jJEOO2xlylGDIUZwhRzGGHLcx5CjKkONWhhxFGHIUZsgRZMhRiCFHQYYcBRhy5GfIkY8hR16GHHkYcuRmyJGLIUdOhhw5GHJkZ8iRjSFHVoYctzDkyMKQ42aGHJkZcnzIkGMUQ44PGHKMZMgxgiHHcIYcwxhyDGXIMYQhx2CGHO8z5BjEkOM9hhwDGXK8y5BjAEOO/gw5+jHk6MuQow9Djt4MOXox5OjJkKMHQ453GHJ0Z8jxNkOOtxhyvMmQ4w2GHGlbm8+RhiFHaoYcqRhypGTIkYIhh8WQI8CQ4zIDg5cYclxkyHGBIcd5hhznGHKcZchxhiHHvww5TjPkOMWQ4yRDjn8YcpxgyHGcIccxhhxHGXIcYcjxN0OOwww5/mLIcYghR0eGa58ODDnaM+Rox5CjLUOONgw5WjPkaMWQoyVDjhYMOV5nyNGcIUczhhxNGXK8xpCjCUOOxgw5GjHkeJUhR0OGHK8w5HiZIcdLDDkaMOSoz5CjHkOOFxly1GXI8QJDjjoMOX5nyLGPIcdvDDn2MuT4lSHHHoYcuxly7GLI8QtDjp0MOX5myLGDIcd2hhzbGHL8xJBjK0OOLQw5NjPk+JEhxyaGHD8w5NjIkGMDQ471DDnWMeRYy5Dje4YcaxhyfMeQ41uGHE+1MZ+jFkOOmgw5ajDkqM6QoxpDjicZclRlyPEEQ44qDDkqM+SoxJAjjiFHLEOOxxlyVGTI8RhDjhiGHI8y5HiEIcfDDDkqMOR4iCFHeYYcDzLkKMeQ4wGGHPcz5LiPIce9DDm+ZMixgiHHFww5ljPk+JwhxzKGHEsZcixhyLGYIccihhwLGXIsYMgxnyHHPIYccxlyzGHIMZshxyyGHDMZcsxgyDGdIcc0hhxTGXJMYcgxmSHHJIYcExlyTGDIMZ4hx2cMOe5saz7HHQw5SjHkKMmQ43aGHCUYchRnyFGMIcdtDDmKMuS4lSFHEYYchRlyBBlyFGLIUZAhRwGGHPkZcuRjyJGXIUcehhy5GXLkYsiRkyFHDoYc2RlyZGPIkZUhxy0MObIw5BjDkGM0Q44PGXKMYsjxAUOOkQw5RjDkGM6QYxhDjqEMOYYw5BjMkON9hhyDGHK8x5BjIEOOdxlyDGDI0Z8hRz+GHH0ZcvRhyNGbIUcvhhw9GXL0YMjxDkOO7gw53mbI8RZDjpvamc+RjiFHWoYcaRhypGbIkYohR0qGHCkYclgMOQIMOS4zeMklhhwXGXJcYMhxniHHOYYcZxlynGHI8S9DjtMMOU4x5DjJkOMfhhwnGHIcZ8hxjCHHUYYcRxhy/M2Q4zBDjs4M1wydGHJ0ZMjRgSFHe4Yc7RhytGXI0YYhR2uGHK0YcrRkyNGCIcfrDDmaM+RoxpCjKUOO1xhyNGHI0ZghRyOGHK8y5GjIkOMVhhwvM+R4iSFHA4Yc9Rly1GPI8SJDjroMOf5gyLGfIcfvDDn2MeT4jSHHXoYcvzLk2MOQYzdDjl0MOX5hyLGTIcfPDDl2MOTYzpBjG0OOnxhybGXIsYUhx2aGHD8y5NjEkOMHhhwbGXJsYMixniHHOoYcaxlyfM+QYw1Djmfam8/xNEOOpxhy1GLIUZMhRw2GHNUZclRjyPEkQ46qDDmeYMhRhSFHZYYclRhyxDHkiGXI8ThDjooMOR5jyBHDkONRhhyPMOR4mCFHBYYcDzHkKM+Q40GGHOUYcjzAkON+hhxfM+T4iiHHlww5VjDk+IIhx3KGHJ8z5FjGkGMpQ44lDDkWM+RYxJBjIUOOBQw55jPkmMeQYy5DjjkMOWYz5JjFkGMmQ44ZDDmmM+SYxpBjKkOOKQw5JjPkmMSQYyJDjgkMOe7qYD5HaYYcdzLkuIMhRymGHCUZctzOkKMEQ47iDDmKMeS4jSFHUYYctzLkKMKQozBDjiBDjkIMOQoy5CjAkCM/Q458DDnyMuTIw5AjN0OOXAw5cjLkyMGQIztDjmwMObIy5PiYIcdHDDnGMOQYzZDjQ4YcoxhyfMCQYyRDjhEMOYYz5BjGkGMoQ44hDDkGM+R4nyHHIIYc7zHkGMiQ412GHAMYcvRnyNGPIUdfhhx9GHL0ZsjRiyFHT4YcPRhyvMOQoztDjgwdzedIz5DjJoYc6RhypGXIkYYhR2qGHKkYcqRkyJGCIYfFkCPAkOMygydeYshxkSHHBYYc5xlynGPIcZYhxxmGHP8y5DjNkOMUQ46TDDn+YchxgiHHcYYcxxhyHGXIcYQhRxeGvTaeIUdnhhydGHJ0ZMjRgSFHe4Yc7RhytGXI0YYhR2uGHK0YcrRkyNGCIcfrDDmaM+RoxpCjKUOO1xhyNGHI0ZghRyOGHK8y5GjIkOMVhhwvM+R4iSFHA4Yc9Rly1GPIcZAhxwGGHH8w5NjPkON3hhz7GHL8xpBjL0OOXxly7GHIsZshxy6GHL8w5NjJkONnhhw7GHJsZ8ixjSHHTww5tjLk2MKQYzNDjh8ZcmxiyPEDQ46NDDk2MORYz5BjHUOOtQw5nutkPsezDDmeYcjxNEOOpxhy1GLIUZMhRw2GHNUZclRjyPEkQ46qDDmeYMhRhSFHZYYclRhyxDHkiGXI8ThDjooMOR5jyBHDkONRhhyPMOR4mCFHBYYcDzHkKM+Q40GGHOUYcqxiyLGSIcfXDDm+YsjxJUOOFQw5vmDIsZwhx+cMOZYx5FjKkGMJQ47FDDkWMeRYyJBjAUOO+Qw55jHkmMuQYw5DjtkMOWYx5JjJkGMGQ47pDDmmMeSYypBjCkOOyQw5JjHkuLuz+RxlGHLcxZCjNEOOOxly3MGQoxRDjpIMOW5nyFGCIUdxhhzFGHLcxpCjKEOOWxlyFGHIUZghR5AhRyGGHAUZchRgyJGfIUc+hhx5GXLkYciRmyFHLoYcORly5GDIkZ0hxziGHGMZcnzMkOMjhhxjGHKMZsjxIUOOUQw5PmDIMZIhxwiGHMMZcgxjyDGUIccQhhyDGXK8z5BjEEOO9xhyDGTI8S5DjgEMOfoz5OjHkKMvQ44+DDl6M+ToxZCjJ0OOHgw5MsWbz5GRIUcGhhzpGXLcxJAjHUOOtAw50jDkSM2QIxVDjpQMOVIw5LAYcgQYclxm8PZLDDkuMuS4wJDjPEOOcww5zjLkOMOQ41+GHKcZcpxiyHGSIcc/DDlOMOQ4zpDjGEOOegx71IsMOeoy5HiBIUcdhhy1GXI8z5DjOYYczzLkeIYhx9MMOZ5iyFGLIUdNhhw1GHJUZ8hRjSHHkxo5AliOG/MMzwPmFhL9USh5P6OI5rzGmvNaas57RXNeM815LTTn6R7PwI15N+bdmHdj3o15Vx/o9U+DZFz/AHnSWmH/6BofSCg0ZehrV0kRKbAEVvjPKNOoRrvf7v7k9iW14ha9806d+iXu+bNKl6Vthjz+26lhx+j73eKxwhPrTJyXiiJ9WI3JqbvBta/bivSNYEBtbvi63ohP+Pqm86S9KSkmlXqi/5LpLj6KdihprTeAn/um5kF1kuaW5w31prOiNRhKeFcewguF1/pWqGnedjaNGEjtmIkS8zZwcrsDBz28zu6SOlOCdao60tHLl/e9BazpbeCE+r2R3gk1Ug9nI4lv5HeM9bgGzdUDOBE9NZurJ3NzvQOsqYfmSXYeZySPm7aXek2Fwo9zL4XtGnXxXuq7RVrZN4IBpbm2WnuHIOjjhEB8w3KM9ZEU6GwuZJFuW21v4ET2AQ+ezskR9YDQp0XW0BcAJPy89NVoRrcf31cT1gCWx+bI/ULN2D8+7JoILby35kHsJ3H9/tfATYF6rP5AswzQXOeAsDUhEAi3F2vpF4/D8/xmrJnQnVXU1Rc4dkLfP17j2UFwHeDPL6R7fN/V7IXweegxTzREVb3QvquxtoGaawufh57nt+KvboBIrXXB/kh8oJvoe2FrK3nbpkXj8y74/u23l4yctyvF+MVTs39WLr7cVyNO10117unhk4CetZD6w4/1e8k41uI4vxevx3yi1u14DdLsIdm8m6R1WhF/XpJXw0SWBpyvzokiDTheLRRNGrC/eimqNGB7NVV0aSD81V1u5+D9sGOZvWXt+g1eanLu5keGZ+q58uxn/Z84NKJj+vQXRt/9ZMlnVv52unERS1nbJEzr9hDndS5FntC/G1JNr1I0omhM0YTiNYqmFM0omlO8TtGCoiVFK4rWFG0o2lK0o2hP0YGiI0Unis4U8RRd4hPWLB4pQnmdj2AAe+j4mKJWO8dgMIeOPwgO0esu5NceQwAt4pFenfchDOd9KPirooyBq+cwOXkHa6wt/BFUkxXSn2tdWZMV9oOGUd3DKUZQjKT4gGIUxYcUoynGUHxE8THFWIpxFJ9QfErxGcV4igkUEykmUUymmEIxlWIaxXSKGRQzKWZRzKaYQzHXeWcvCknnGBsuGRshGRspGftAMjZKMvahZGy0ZGyMZOwjydjHkrGxkrFxkrFPJGOfSsY+k4yNl4xNkIxNlIxNkoxNloxNkYxNlYxNk4xNl4zNkIzNlIzNkozNlozNkYzNDY2FP4KOry4PG9xuRjxMUUs3rtZwZW3AGqGqpXpHqmn/+23WB0rak2Jt1igV7d7/joP1oYK2YsIxs0a7aweHjq81xlXbOvFcWB+5aZdcOW/Wxy7a+Kvn2BobXVs5rB+scVG1B8N7x/okmrasrc+sT6Noi9t70vossraeo3+t8RG1tZ29bk2IpO2ehAtrYgRt96QMWZPk2oUS3qzJUm2sjE1rikxbU8qxNVWiXSxn3pqWVFsigj9Y05Nox0XyEmuGU1smou9YMx3avZE9yppl17aN4mfWbJu2ejTvs+aEa1+N6pPWXI8u1JALRNkjqCa75hdq86ju+RQLKBZSLKJYTLGEYinFMorPKZZTfEGxguJLiq8ovqZYSbGKYjXFNxTfUnxHsYbie4q1FOso1lNsoNhI8QPFJueF2jzJJjtfMrZAMrZQMrZIMrZYMrZEMrZUMrZMMva5ZGy5ZOwLydgKydiXkrGvJGNfS8ZWSsZWScZWS8a+kYx9Kxn7TjK2RjL2vWRsrWRsnWRsvWRsg2Rso2TsB8nYpvjkX6gNdb+QuHKhNg+4UJsPXKgtAC7UFgIXaouAC7XFwIXaEuBCbSlwobYMuFD7HLhQWw5cqH0BXKitAC7UvgQu1L4CLtS+Bi7UVgIXaquAC7XVwIXaN8CF2rfAhdp3wIXaGuBC7XvgQm0tcKG2DrhQWw9cqG0ALtQ2AhdqPwAXapvAC7UMgasXZeEP9EINeV1OeL4f45ORUExG520GNh3dujbHXx0IBtQfzlwqL1LaHI/P2wKerMRNXzYPzb1VPXfj5OT5ST1Py+Tk2aae55Xk5NmunqdZcvLsUM/TQvTFgsDVu55HWyacX3HsxXERNYufJ8abBs1GpPW6PP7zgy0aDP0MMCSewlkgGQ8GsAe6NqRG3Rw7wQ3nWr3QUXHDsQLy/U11rq3WX0K+vst5l/1L/NVMiWO7JAWir9FQfBXqf3ccvwAb2y7w4OmcHFEP+noMZA27NTex8Hlos4v6dmuYxR4fmMUeBrP49fo3C1k6LbPYGzKL35xmsVdiFr8xm8VeALTfwIOnc3L24maRAlnDPk2z2JcMsxD17dMwi999YBa/M5jF/uvfLGRPcWiZxR8hszjgNIs/JGZxgNks/gBAOwAePJ2T8wduFimRNRzUNIuDyTALUd9BDbP40wdm8SeDWfzv+jeLVLJvBANKc221HgqZxV9OszgkMYu/mM3iEADaX+DB0zk5h3CzSIWs4bCmWRxOhlmI+g5rmMXfPjCLvxnM4sj1bxapZd8IBpTm2mo9GjKLY06zOCoxi2PMZnEUAO0YePB0Ts5R3CxSI2s4rmkWx5NhFqK+4xpmccIHZnGCwSz+uf7NIo3sG8GA0lxbrSdDZnHKaRYnJWZxitksTgKgnQIPns7JOYmbRRpkDac1zeJ0MsxC1Hdawyz+9YFZ/MtgFmeuf7O4Zm/7cDZkFuecZnFWYhbnmM3iLADaOfDg6Zycs7hZpEXWcF7TLM4nwyxEfec1zOKCD8ziAoNZXLz+zSKd7BvBgNJcW62XQmZx2WkWlyRmcZnZLC4BoF0GD57OybmEm0U6ZA2BLnpmET4Pbfb/GqALfjwsoFavzAKpUTdHCiCHR2Zxk+wbwYDSXFutKbskfE3VJWBvwJRdkppFqi68ZpGyi/rPTdUFO3g6J0fUA5rFTcgaUmuaRepkmIWoL7WGWaTxgVmkYTCLtNe/WaSXfSMYUJprqzVdyCxucppFOolZ3MRsFukA0G7qgh08nZOTDjeL9Mga0muaRfpkmIWoL72GWWTwgVlkYDCLjNe/WWSQfSMYUJprqzVTyCwyO80ik8QsMjObRSYAtMxdsIOnc3Iy4WaRAVnDzZpmcXMyzELUd7OGWWTxgVlkYTCLW65/s8go+0YwoDTXVmvWkFlkc5pFVolZZGM2i6wAaNm6YAdP5+Rkxc0iI7KG7JpmkT0ZZiHqy65hFjl8YBY5GMwi5/VvFplk3wgGlObaas0VMovcTrPIJTGL3MxmkQsALXcX7ODpnJxcuFlkQtaQR9Ms8iTDLER9eTTMIq8PzCIvg1nku/7NIrPsG8GA0lxbrflDZlHAaRb5JWZRgNks8gOgFeiCHTydk5MfN4vMyBoKappFwWSYhaivoIZZFPKBWRRiMIvg9W8WN8u+EQwozbXVWjhkFkWcZlFYYhZFmM2iMABakS7YwdM5OYVxs7gZWcOtmmZxazLMQtR3q4ZZFPWBWRRlMIvbrn+zyCL7RjCgNNdWa7GQWRR3mkUxiVkUZzaLYgBoxbtgB0/n5BTDzSILsoYSmmZRIhlmIeoroWEWt/vALG5nMIuS179Z3CL7RjCgNNdWa6mQWdzhNItSErO4g9ksSgGg3dEFO3g6J6cUbha3IGu4U9Ms7kyGWYj67tQwi9I+MIvSDGZx1/VvFlll3wgGlObaai0TMou7nWZRRmIWdzObRRkAtLu7YAdP5+SUwc0iK7KGsppmUTYZZiHqK6thFvf4wCzuYTCLe69/s8gm+0YwoDTXVut9IbO432kW90nM4n5ms7gPAO3+LtjB0zk59+FmkQ1ZwwOaZvFAMsxC1PeAhlmU84FZlGMwiwevf7PILvtGMKA011Zr+ZBZPOQ0i/ISs3iI2SzKA6A91AU7eDonpzxuFtmRNVTQNIsKyTALUV8FDbN42Adm8TCDWTxy/ZtFDtk3ggGlubZaHw2ZRYzTLB6VmEUMs1k8CoAW0wU7eDon51HcLHIga3hM0yweS4ZZiPoe0zCLij4wi4oMZvH49W8WOWXfCAaU5tpqjQ2ZRZzTLGIlZhHHbBaxAGhxXbCDp3NyYnGzyImsoZKmWVRKhlmI+ippmEVlH5hFZQazqHL9m0Uu2TeCAaW5tlqfCJlFVadZPCExi6rMZvEEAFrVLtjB0zk5T+BmkQtZw5OaZvFkMsxC1PekhllU84FZVGMwi+rXv1nkln0jGFCaa6u1RsgsajrNoobELGoym0UNALSaXbCDp3NyauBmkRtZQy1Ns6iVDLMQ9dXSMIunfGAWTzGYxdPXv1nkkX0jGFCaa6v1mZBZPOs0i2ckZvEss1k8A4D2bBfs4OmcnGdws8iDrOE5TbN4LhlmIep7TsMsnveBWTzPYBa1r3+zyCv7RjCgNNdWa52QWbzgNIs6ErN4gdks6gCgvdAFO3g6J6cObhZ5kTXU1TSLuskwC1FfXQ2zeNEHZvEig1nUu/7NIp/sG8GA0lxbrfVDZtHAaRb1JWbRgNks6gOgNeiCHTydk1MfN4t8yBpe0jSLl5JhFqK+lzTM4mUfmMXLDGbxyvVvFvll3wgGlObaam0YMotXnWbRUGIWrzKbRUMAtFe7YAdP5+Q0xM0iP7KGRppm0SgZZiHqa6RhFo19YBaNGcyiyfVvFgVk3wgGlObaan0tZBZNnWbxmsQsmjKbxWsAaE27YAdP5+S8hptFAWQNzTTNolkyzELU10zDLJr7wCyaM5jF69e/WRSUfSMYUJprq7VFyCxaOs2ihcQsWjKbRQsAtJZdsIOnc3Ja4GZREFlDK02zaJUMsxD1tdIwi9Y+MIvWDGbRJplmgebrTX04MP7qQFBh0uXLl8/KxoMB93ziP+H1tg0ZRjunYbSVGEa7ZDRm4kKdwLmZRlsAuHZd9A4gUNN/eZCa2qs3lHXlPwH8uKLAdwBhQusS6+6gYUQdfWBEHRmMqBOYA+3hudQzm9U/98QS2p3x8IZpzQU+DqOzxnEVD/SiBTi2VmeA9fhkMuX28wXrIkcqcN6meCN9Z8UDx6aL5rlF+60DUFNXYK3h+2DiPORuwe3nd9XcuwLqeZJs/t1Cm/8bzs2/m2Tzf0PhbsGtgK5qJ+e/jb8bcCLfAA8eCp6ouxt+t6C63v9yvOmDje/NLuZzvGV445tDZvgLYIhC+6vGxjcH2PjeZtr4gGNrvQ30bvdrZO5ueRBPeCeZF94qm3F3jc34h3gjLFjdgWPT4zrcjHuq15QifF/qaWAz7gnuJ85HMOCeQ/wnvNZeoc24t3Mz7iXZjHtfg824J7AZ9wJOZG/Dm7Gou5fGZtwTWEMfH2zGfbqYz9HX8GY8m8xwL2CIQrtfYzOeDWzG/Zg2Y+DYWv2A3u3PtBkjnjCAYTPur7EZb4w3woLVHzg2716Hm/FA9ZpShu9LAw1sxgPB/cT5CAbcc4j/hNf6XmgzHuTcjN+TbMaDrsFmPBDYjN8DTuQgw5uxqPs9jc14ILCG932wGb/fxXyOwYY341lkhn8Ahii0/9PYjGcBm/EQps0YOLbWEKB3hzJtxognDGPYjIdqbMYb4o2wYA0Fjs3w63AzHqFeU6rwfWmEgc14BLifOB/BgHsO8Z/wWkeGNuMPnJvxSMlm/ME12IxHAJvxSOBEfmB4MxZ1j9TYjEcAaxjlg814VBfzOT40vBnPJDM8BBii0B7R2IxnApvxaKbNGDi21migd8cwbcaIJ3zEsBmP0diM18cbYcEaAxybj6/DzXisek2pw/elsQY247HgfuJ8BAPuOcR/wmsdF9qMP3FuxuMkm/En12AzHgtsxuOAE/mJ4c1Y1D1OYzMeC6zhUx9sxp92MZ/jM8Ob8Qwyw6OAIQrtPxqb8QxgMx7PtBkDx9YaD/TuBKbNGPGEiQyb8QSNzXhdvBEWrAnAsZl0HW7Gk9VrShO+L002sBlPBvcT5yMYcM8h/hNe65TQZjzVuRlPkWzGU6/BZjwZ2IynACdyquHNWNQ9RWMzngysYZoPNuNpXcznmG54M55OZngSMEShPaOxGU8HNuMZTJsxcGytGUDvzmTajBFPmMWwGc/U2IzXxhthwZoJHJvZ1+FmPEe9prTh+9IcA5vxHHA/cT6CAfcc4j/htc4NbcbznJvxXMlmPO8abMZzgM14LnAi5xnejEXdczU24znAGub7YDOe38V8jgWGN+NpZIZnAUMU2osam/E0YDNeyLQZA8fWWgj07iKmzRjxhMUMm/Eijc34+3gjLFiLgGOz5DrcjJeq15QufF9aamAzXgruJ85HMOCeQ/wnvNZloc34c+dmvEyyGX9+DTbjpcBmvAw4kZ8b3oxF3cs0NuOlwBqW+2AzXt7FfI4vDG/GU8kMLwGGKLQpNM79VGAzXsG0GQPH1loB9O6XTJsx4glfMWzGX2psxmvijbBgfQkcm6+vw814pXpNN4XvSysNbMYrwf3E+QgG3HOI/4TXuiq0Ga92bsarJJvx6muwGa8ENuNVwIlcbXgzFnWv0jDklcAavvHBZvxNF/M5vjW8GU8hM0wJmJzQptU491OAzfg7ps0YOLbWd0DvrmHajBFP+J5hM16jsRl/F2+EBWsNcGzWXoeb8Tr1mtKH70vrDGzG68D9xPkIBtxziP+E17o+tBlvcG7G6yWb8YZrsBmvAzbj9cCJ3GB4MxZ1r9cw5HXAGjb6YDPe2MV8jh8Mb8aTyQzTASYntBl1Xi8AbMabmDZj4Nham4De/ZFpM0Y8YTPDZvyjxmb8bbwRFqwfgWOz5TrcjLeq15QhfF/aamAz3gruJ85HMOCeQ/wnvNafQpvxNudm/JNkM952DTbjrcBm/BNwIrcZ3oxF3T9pGPJWYA3bfbAZb+9iPscOw5vxJDLDTIDJCe0tGud+ErAZ/8y0GQPH1voZ6N2dTJsx4gm/MGzGOzU242/ijbBg7QSOza7rcDPerV5TxvB9abeBzXg3uJ84H8GAew7xn/Ba94Q241+dm/EeyWb86zXYjHcDm/Ee4ET+angzFnXv0TDk3cAa9vpgM97bxXyO3wxvxhPJDLMCJie0OTXO/URgM97HtBkDx9baB/Tu70ybMeIJ+xk24981NuPV8UZYsH4Hjs0f1+FmfEC9pkzh+9IBA5vxAXA/cT6CAfcc4j/htR4MbcZ/Ojfjg5LN+M9rsBkfADbjg8CJ/NPwZizqPqhhyAeANfzPB5vx/7qYz3HI8GY8gcwwF2ByQptP49xPADbjv5g2Y+DYWn8BvXuYaTNGPOFvhs34sMZmvCreCAvWYeDYHLkON+Oj6jVlDt+XjhrYjI+C+4nzEQy45xD/Ca/1WGgzPu7cjI9JNuPj12AzPgpsxseAE3nc8GYs6j6mYchHgTWc8MFmfKKL+Rz/GN6Mx5MZ5gdM7j+txrkfD2zGJ5k2Y+DYWieB3j3FtBkjnnCaYTM+pbEZr4w3woJ1Cjg2/16Hm/EZ9ZpuDt+XzhjYjM+A+4nzEQy45xD/Ca/1bGgzPufcjM9KNuNz12AzPgNsxmeBE3nO8GYs6j6rYchngDWc98FmfL6L+RwXDG/Gn5EZFgZMTmhv0zj3nwGb8UWmzRg4ttZFoHcvMW3GiCdcZtiML2lsxl/HG2HBugQcm0DX628zttRryhK+LyXOu5absWot13IzTtE14WvKrgH7xiu+4dyMU3ZN/mYcvki3zThFV/UTmRI8eCh4om5RD9qMFrCGVAAgXm3Gqbqaz5EazIEa+qdkhsUAkxPakhqb8afAZpxG0xzRzRg4tlYaoHfTXiNzd8uDeEI6YK1X/gPUIjZjsW50M/4q3ggLVlrg2Nx0HW7G6dVruiV8X0pvYDNO78FmnCG0GWd0bsYZJJtxxmuwGacHNuMMQHNlNLwZi7ozaGzG6YE1ZPLBZpypq/kcmQ1vxp+QGZYCNmOhvUtjM/4E2IxvZtqMgWNr3Qz0bhamzRjxhFsYNuMsGpvxl/FGWLCyAMcm63W4GWdTrylr+L6UzcBmnM2DzTh7aDPO4dyMs0s24xzXYDPOBmzG2YHmymF4MxZ1Z9fYjLMBa8jpg804Z1fzOXIZ3ozHkRmWATZjob1XYzMeB2zGuZk2Y+DYWrmB3s3DtBkjnpCXYTPOo7EZr4g3woKVBzg2+a7DzTi/ek3Zwvel/AY24/webMYFQptxQedmXECyGRe8BptxfmAzLgA0V0HDm7Gou4DGZpwfWEMhH2zGhbqazxE0vBmPJTO8D9iMhfZBjc14LLAZF2bajIFjaxUGercI02aMeMKtDJtxEY3N+It4IyxYRYBjU/Q63IxvU68pe/i+dJuBzfg2DzbjYqHNuLhzMy4m2YyLX4PN+DZgMy4GNFdxw5uxqLuYxmZ8G7CGEj7YjEt0NZ/jdsOb8cdkhuWBzVhoH9HYjD8GNuOSTJsxcGytkkDvlmLajBFPuINhMy6lsRkvjzfCglUKODZ3XoebcWn1mnKE70ulDWzGpT3YjO8KbcZlnJvxXZLNuMw12IxLA5vxXUBzlTG8GYu679LYjEsDa7jbB5vx3V3N5yhreDP+iMzwUWAzFtrHNTbjj4DN+B6mzRg4ttY9QO/ey7QZI55wH8NmfK/GZvx5vBEWrHuBY3P/dbgZP6BeU87wfekBA5vxAx5sxuVCm/GDzs24nGQzfvAabMYPAJtxOaC5HjS8GYu6y2lsxg8Aayjvg824fFfzOR4yvBmPITOMBTZjoa2isRmPATbjCkybMXBsrQpA7z7MtBkjnvAIw2b8sMZmvCzeCAvWw8CxefQ63Ixj1GvKFb4vxRjYjGM82IwfC23GFZ2b8WOSzbjiNdiMY4DN+DGguSoa3oxF3Y9pbMYxwBoe98Fm/HhX8zliDW/Go8kMnwA2Y6GtrrEZjwY24zimzRg4tlYc0LuVmDZjxBMqM2zGlTQ246XxRliwKgHHpsp1uBk/oV5T7vB96QkDm/ETHmzGVUOb8ZPOzbiqZDN+8hpsxk8Am3FVoLmeNLwZi7qramzGTwBrqOaDzbhaV/M5qhvejD8kM6wBbMZC+7TGZvwhsBnXYNqMgWNr1QB6tybTZox4Qi2Gzbimxma8JN4IC1ZN4Ng8dR1uxk+r15QnfF962sBm/LQHm/Ezoc34Wedm/IxkM372GmzGTwOb8TNAcz1reDMWdT+jsRk/DazhOR9sxs91NZ/jecOb8Sgyw2eAzVhoa2tsxqOAzbg202YMHFurNtC7dZg2Y8QTXmDYjOtobMaL442wYNUBjk3d63AzflG9przh+9KLBjbjFz3YjOuFNuP6zs24nmQzrn8NNuMXgc24HtBc9Q1vxqLuehqb8YvAGhr4YDNu0NV8jpcMb8YfCBMFNmOhrdcFP/cfAJvxy0ybMXBsrZeB3n2FaTNGPKEhw2b8isZmvCjeCAvWK8CxefU63IwbqdeUL3xfamRgM27kwWbcOLQZN3Fuxo0lm3GTa7AZNwI248ZAczUxvBmLuhtrbMaNgDW85oPN+LWu5nM0NbwZjyQzrN9FvR6hfUVjMx4JbMbNmDZj4NhazYDebc60GSOe8DrDZtxcYzNeGG+EBas5cGxaXIebcUv1mvKH70stDWzGLT3YjFuFNuPWzs24lWQzbn0NNuOWwGbcCmiu1oY3Y1F3K43NuCWwhjY+2IzbdDWfo63hzXgEmWFDYDMW2iYam/EIYDNux7QZA8fWagf0bnumzRjxhA4Mm3F7jc14QbwRFqz2wLHpeB1uxp3UayoQvi91MrAZd/JgM+4c2ozjnZtxZ8lmHH8NNuNOwGbcGWiueMObsai7s8Zm3AlYQxcfbMZduprP0dXwZjyczPA1YDMW2tc1NuPhwGbcjWkzBo6t1Q3o3TeYNmPEE95k2Izf0NiM58cbYcF6Azg2b12Hm/Hb6jUVDN+X3jawGb/twWbcPbQZv+PcjLtLNuN3rsFm/DawGXcHmusdw5uxqLu7xmb8NrCGHj7YjHt0NZ+jp+HNeBiZYQtgMxbaNhqb8TBgM+7FtBkDx9bqBfRub6bNGPGEPgybcW+NzXhevBEWrN7Asemreb6Cjq9XDlqER2cbZ9HFb9uZjCru5+A3mniIk/Uo4tFJfCGyeHxSD4koniHxm0jihTJviiBeIfUxufg7uedJxZsi+KNM/HMkL5WI90X03aTivyJ7dBJxtM+Dd4qjflytQxz90/TsYpcP+7GJ3T6LIFzs+lbJYWL3d3K8KlZ4o6krYpX3wUgUK/2Zbkis9ldECWLFFzn/J1Z9DZYQKz9FbCG/wbaQG2xor+0Heneh0Nfg1dKiPtoTH10A336HtD0A7x5A2ncB/x5G2uGAh39E2o8BH59I2kmAl88i7WzAzxeTdgng6V+R9mvA178n7VrA2zeTdgvg77+Qdhfg8ftJ+wfg83+T9gjg9adJ+y/g9+KjtKN+ZLRjgvi0z5sA3xcfSJYV8H7xmSn5AP8Xb+teFNgDxDvP3gnsA+LN8e4H9gLx/j2PAvuBeIuBKsCeIP4K8ilgXxB/qFEX2BvEa0lfBfYH8XKXFsAeIZ6R6wjsE+KXhsAvxyxxXxN+/a46T/2+w1L/haGl/kyfOJaKL9H57zypvbY2oQeU/igm1F8qf82a2LsKb0NxhQv394+6ypzrGz+G8ez2js3hXuHyUQs2H4r+GUl2j4v64YYO/4z2qcQOaeDreHXfXxmvvqesilffr1bHq++F38Sr77Pfxqvv4d/Fq18frIlXv/b4Pl79umZtvPo107p49eux9fHq13ob4tWvIzfGq1+j/hCvfv27Cfi9Xf9k/q7S5WGJ3zH1Q34PF59QE/p7tcHA76TQNSc+0JqGelCTW563gN4YAOzpoiUTn2eRzUPr7ArU+a56nanD63z3GtT5LtDbA9XrTCFqXEiRNvQL8i9a0j5K8TnFMoqlFEsoFlMsolhIsYBiPsU8irkUcyhmU8yimEkxg2I6xTSKqRRTKCZTTKKYSDGBYjzFZxSfUnxCUaoV/U6G4naKEhTFKYpR3EZRlOJWiiIUhSmCFIUoClIUoMhPkY8iL0UeitwUuShyUuSgyE6RjSIrxS0UWShupshM8SHFKIoPKEZSjKAYTjGMYijFEIrBFO9TDKJ4j2IgxbsUAyj6U/Sj6EvRh6I3RS+KnhQ9KN6h6E7xNsVbFG9SvEGRtjX9zowiNUUqipQUKSgsigDFZdJcorhIcYHiPMU5irMUZyj+pThNcYriJMU/FCcojlMcozhKcYTib4rDFH9RHKLoSD+7A0V7inYUbSnaULSmaEXRkqIFxesUzSmaUTSleI2iCUVjikYUr1I0pHiF4mWKlygaUNSnqEfxIkVdihco6lD8TrGP4jeKvRS/Uuyh2E2xi+IXip0UP1PsoNhOsY3iJ4qtFFsoNlP8SLGJ4geKjRQbKNZTrKNYS/E9xRqK7yi+pXiqDd0nUdSkqEFRnaIaxZMUVSmeoKhCUZmiEkUcRSzF4xQVKR6jiKF4lOIRiocpKlA8RFGe4kGKchQPUNxPcR/FvRRfUqyg+IJiOcXnFMsollIsoVhMsYhiIcUCivkU8yjmUsyhmE0xi2ImxQyK6RTTKKZSTKGYTDGJYiLFBIrxFJ9R3NmW7mspSlGUpLidogRFcYpiFLdRFKW4laIIRWGKIEUhioIUBSjyU+SjyEuRhyI3RS6KnBQ5KLJTZKPISnELRRaKMRSjKT6kGEXxAcVIihEUwymGUQylGEIxmOJ9ikEU71EMpHiXYgBFf4p+FH0p+lD0puhF0ZOiB8U7FN0p3qZ4i+KmdvR7CIq0FGkoUlOkokhJkYLCoghQXCbtJYqLFBcozlOcozhLcYbiX4rTFKcoTlL8Q3GC4jjFMYqjFEco/qY4TNGZfmYnio4UHSjaU7SjaEvRhqI1RSuKlhQtKF6naE7RjKIpxWsUTSgaUzSieJWiIcUrFC9TvETRgKI+RT2KFynqUvxBsZ/id4p9FL9R7KX4lWIPxW6KXRS/UOyk+JliB8V2im0UP1FspdhCsZniR4pNFD9QbKTYQLGeYh3FWorvKdZQPNM+EHia4imKWhQ1KWpQVKeoRvEkRVWKJyiqUFSmqEQRRxFL8ThFRYrHKGIoHqV4hOJhigoUD1GUp3iQohzFAxT3U3xN8RXFlxQrKL6gWE7xOcUyiqUUSygWUyyiWEixgGI+xTyKuRRzKGZTzKKYSTGDYjrFNIqpFFMoJlNMophIMYHirg6BQGmKOynuoChFUZLidooSFMUpilHcRlGU4laKIhSFKYIUhSgKUhSgyE+RjyIvRR6K3BS5KHJS5KDITpGNIivFxxQfUYyhGE3xIcUoig8oRlKMoBhOMYxiKMUQisEU71MMoniPYiDFuxQDKPpT9KPoS9GHojdFL4qeFD0o3qHoTpGhYyCQnuIminQUaSnSUKSmSEWRkiIFhUURoLhMcy5RXKS4QHGe4hzFWYozFP9SnKY4RXGS4h+KExTHKY5RHKU4QtGFflY8RWeKThQdKTpQtKdoR9GWog1Fa4pWFC0pWlC8TtGcohlFU4rXKJpQNKZoRPEqRUOKVyhepniJogFFfYp6FAcpDlD8QbGf4neKfRS/Ueyl+JViD8Vuil0Uv1DspPiZYgfFdoptFD9RbKXYQrGZ4keKTRQ/UGyk2ECxnmIdxVqK5zoFAs9SPEPxNMVTFLUoalLUoKhOUY3iSYqqFE9QVKGoTFGJIo4iluJxiooUj1HEUDxK8QjFwxQVKB6iKE/xIEU5ilUUKym+pviK4kuKFRRfUCyn+JxiGcVSiiUUiykWUSykWEAxn2IexVyKORSzKWZRzKSYQTGdYhrFVIopFJMpJlHc3ZmuVynuoihNcSfFHRSlKEpS3E5RgqI4RTGK2yiKUtxKUYSiMEWQohBFQYoCFPkp8lHkpchDkZsiF0VOihwU2SnGUYyl+JjiI4oxFKMpPqQYRfEBxUiKERTDKYZRDKUYQjGY4n2KQRTvUQykeJdiAEV/in4UfSn6UPSm6EXRk6IHRSa6n8hIkYEiPcVNFOko0lKkoUhNkYoiJUUKCosiQHGZ5l6iuEhxgeI8xTmKsxRnKP6lOE1xiuIkxT8UJyiOUxyjqEc/40WKuhQviPd6oKhN8TzFcxTPijdjonia4imKWuId7sS7JVJUp6hG8SRF02DkSLxvWSi5kQgGsIeFzbMGdjWf4z3Ne+Pk5Il2L3f08uXvwiei94wDgXvGQZr34IOuwWsdC8SpawcBa3ofOJ/ha3r/GtyvI3UO1jz2g69Bne8DdQ4Bfq+QnJoGAzUNBbReeddQBu8axuRdw9S969fwiWgPDAHO63Af9MBwhh4YwdQDI4AeEK/5zBCQP5WA5gX2CVu+kV2TkXBkV3zeB0BD6tb1QderA8GA+sOZS2Vz+qCrWRMfBb6g3wuARzEA/KHhJ8l2xyacy0S965vGkfZDjSfJRJ6gYk3ImpG/InKrUdFMrECEp0GDAaW5tlpHh5gd4/wrotGSvyIao3BljSzS7a+IRgONMaYrdvB0TEfUg95JIKaDrPcjzSv08HnoMRD1faRhvB8B6/rYB8b7MYPxjjVsvHtisX4T2rEaxrsn1syaPTJeWTot4x0XMt5PnMY7TmK8nzAb7zigMT7pih08HeMdZ9B46ZbgMrLeT4FfOYSfw0+TYbyivk81jPdTYF2f+cB4P2Mw3vGGjffX2ITzmahXOffjNYz311gza/bIeFPKvhEMKM211TohZLwTncY7QWK8E5mNdwLQGBO7YgdPx3gnmDXeS8h6J6k3acrwczgpGcYr6pukYbyTgHVN9oHxTmYw3imGjXdvbML5TNSrnPspGsa7N9bMmj0y3lSybwQDSnNttU4NGe80p/FOlRjvNGbjnQo0xrSu2MHTMd6pZo33IrLe6epNmir8HE5PhvGK+qZrGO90YF0zfGC8MxiMd6Zh4/0tNuF8JupVzv1MDeP9LdbMmj0y3tSybwQDSnNttc4KGe9sp/HOkhjvbGbjnQU0xuyu2MHTMd5ZZo33ArLeOepNavvrjjnJMF5R3xwN450DrGuuD4x3LoPxzjNsvPtiE85nol7l3M/TMN59sWbW7JHxppF9IxhQmmurdX7IeBc4jXe+xHgXMBvvfKAxFnTFDp6O8c43a7znkfUuVG/SNOHncGEyjFfUt1DDeBcC61rkA+NdxGC8iw0b7++xCeczUa9y7hdrGO/vsWbW7JHxppV9IxhQmmurdUnIeJc6jXeJxHiXMhvvEqAxlnbFDp6O8S4xa7znkPUuU2/StOHncFkyjFfUt0zDeJcB6/rcB8b7OYPxLjdsvPtjE85nol7l3C/XMN79sWbW7JHxppN9IxhQmmur9YuQ8a5wGu8XEuNdwWy8XwCNsaIrdvB0jPcLs8Z7Flnvl+pNmi78HH6ZDOMV9X2pYbxfAuv6ygfG+xWD8X5t2Hj/iE04n4l6lXP/tYbx/hFrZs0eGe9Nsm8EA0pzbbWuDBnvKqfxrpQY7ypm410JNMaqrtjB0zHelWaN9wyy3tXqTXpT+DlcnQzjFfWt1jDe1cC6vvGB8X7DYLzfGjbeA7EJ5zNRr3Luv9Uw3gOxZtbskfGml30jGFCaa6v1u5DxrnEa73cS413DbLzfAY2xpit28HSM9zuzxvsvst7v1Zs0ffg5/D4Zxivq+17DeL8H1rXWB8a7lsF41xk23oOxCeczUa9y7tdpGO/BWDNr9sh4M8i+EQwozbXVuj5kvBucxrteYrwbmI13PdAYG7piB0/HeNebNd7TyHo3qjdphvBzuDEZxivq26hhvBuBdf3gA+P9gcF4Nxk23j9jE85nol7l3G/SMN4/Y82s2SPjzSj7RjCgNNdW648h493sNN4fJca7mdl4fwQaY3NX7ODpGO+PZo33FLLeLepNmjH8HG5JhvGK+rZoGO8WYF1bfWC8WxmM9yfDxvu/2ITzmahXOfc/aRjv/2LNrNkj480k+0YwoDTXVuu2kPFudxrvNonxbmc23m1AY2zvih08HePdZtZ4TyLr3aHepJnCz+GOZBivqG+HhvHuANb1sw+M92cG491p2HgPxSacz0S9yrnfqWG8h2LNrNkj480s+0YwoDTXVusvIePd5TTeXyTGu4vZeH8BGmNXV+zg6RjvL2aN9x9kvbvVmzRz+DncnQzjFfXt1jDe3cC69vjAePcwGO+vho33r9iE85moVzn3v2oY71+xZtbskfHeLPtGMKA011br3pDx/uY03r0S4/2N2Xj3Ao3xW1fs4OkY716zxnsCWe8+9Sa9Ofwc7kuG8Yr69mkY7z5gXb/7wHh/ZzDe/YaN93BswvlM1Kuc+/0axns41syaPTLeLLJvBANKc221/hEy3gNO4/1DYrwHmI33D6AxDnTFDp6O8f5h1niPI+s9qN6kWcLP4cFkGK+o76CG8R4E1vWnD4z3Twbj/Z9h4/07NuF8JupVzv3/NIz371gza/bIeG+RfSMYUJprq/VQyHj/chrvIYnx/sVsvIeAxvirK3bwdIz3kFnjPYas97B6k94Sfg4PJ8N4RX2HNYz3MLCuv31gvH8zGO8Rw8Z7JDbhfCbqVc79EQ3jPRJrZs0eGW9W2TeCAaW5tlqPhoz3mNN4j0qM9xiz8R4FGuNYV+zg6RjvUbPGexRZ73H1Js0afg6PJ8N4RX3HNYz3OLCuEz4w3hMMxvuPYeM9GptwPhP1Kuf+Hw3jPRprZs0eGW822TeCAaW5tlpPhoz3lNN4T0qM9xSz8Z4EGuNUV+zg6RjvSbPGewRZ72n1Js0Wfg5PJ8N4RX2nNYz3NLCuf31gvP8yGO8Zw8Z7LDbhfCbqVc79GQ3jPRZrZs0eGW922TeCAaW5tlrPhoz3nNN4z0qM9xyz8Z4FGuNcV+zg6RjvWbPG+zey3vPqTZo9/ByeT4bxivrOaxjveWBdF3xgvBcYjPeiYeM9HptwPhP1Kuf+oobxHo81s2aPjDeH7BvBgNJcW62XQsZ72Wm8lyTGe5nZeC8BjXG5K3bwdIz3klnjPYysN9BNuYYc4ecwfB56DP5rlm445OE53XJY6uvyzHiRGnVzpABzoOfkRGzC+UzUq5z7FN1w4z0Ra2bNHhlvTtk3ggGlubZaU3ZL+JqqW8BusuIbTuNN1Y3XeFMCwKbqhh08HeMV9Rg03r+Q9aZWb9Kc4ecwdTKMV9SXWsN4UwPrSuMD403DYLxpDRvvP7EJ5zNRr3Lu02oY7z+xZtbskfHmkn0jGFCaa6s1Xch4b3IabzqJ8d7EbLzpgMa4qRt28HSMN51Z4z2ErDe9epPmCj+H6ZNhvKK+9BrGmx5YVwYfGG8GBuPNaNh4T8YmnM9Evcq5z6hhvCdjzazZI+PNLftGMKA011ZrppDxZnYabyaJ8WZmNt5MQGNk7oYdPB3jzWTWeP+HrPdm9SbNHX4Ob06G8Yr6btYw3puBdWXxgfFmYTDeWwwb76nYhPOZqFc597doGO+pWDNr9sh488i+EQwozbXVmjVkvNmcxptVYrzZmI03K9AY2bphB0/HeLOaNd4/kfVmV2/SPOHnMHsyjFfUl13DeLMD68rhA+PNwWC8OQ0b7+nYhPOZqFc59zk1jPd0rJk1e2S8eWXfCAaU5tpqzRUy3txO480lMd7czMabC2iM3N2wg6djvLnMGu9BZL151Js0b/g5zJMM4xX15dEw3jzAuvL6wHjzMhhvPsPG+29swvlM1Kuc+3waxvtvrJk1e2S8+WTfCAaU5tpqzR8y3gJO480vMd4CzMabH2iMAt2wg6djvPnNGu8BZL0F1Zs0X/g5LJgM4xX1FdQw3oLAugr5wHgLMRhv0LDxnolNOJ+JepVzH9Qw3jOxZtbskfHml30jGFCaa6u1cMh4iziNt7DEeIswG29hoDGKdMMOno7xFjZrvH8g671VvUnzh5/DW5NhvKK+WzWM91ZgXUV9YLxFGYz3NsPGezY24Xwm6lXO/W0axns21syaPTLeArJvBANKc221FgsZb3Gn8RaTGG9xZuMtBjRG8W7YwdMx3mJmjXc/st4S6k1aIPwclkiG8Yr6SmgYbwlgXbf7wHhvZzDekoaN91xswvlM1Kuc+5Iaxnsu1syaPTLegrJvBANKc221lgoZ7x1O4y0lMd47mI23FNAYd3TDDp6O8ZYya7y/I+u9U71JC4afwzuTYbyivjs1jPdOYF2lfWC8pRmM9y7Dxns+NuF8JupVzv1dGsZ7PtbMmj0y3kKybwQDSnNttZYJGe/dTuMtIzHeu5mNtwzQGHd3ww6ejvGWMWu8+5D1llVv0kLh57BsMoxX1FdWw3jLAuu6xwfGew+D8d5r2HgvxCacz0S9yrm/V8N4L8SaWbNHxiuVBQNKc2213hcy3vudxnufxHjvZzbe+4DGuL8bdvB0jPc+s8b7G7LeB9SbNBh+Dh9IhvGK+h7QMN4HgHWV84HxlmMw3gcNG+/F2ITzmahXOfcPahjvxVgza/bIeAvLvhEMKM211Vo+ZLwPOY23vMR4H2I23vJAYzzUDTt4OsZb3qzx7kXWW0G9SQuHn8MKyTBeUV8FDeOtAKzrYR8Y78MMxvuIYeO9FJtwPhP1Kuf+EQ3jvRRrZs0eGW8R2TeCAaW5tlofDRlvjNN4H5UYbwyz8T4KNEZMN+zg6Rjvo2aN91dkvY+pN2mR8HP4WDKMV9T3mIbxPgasq6IPjLcig/E+bth4L8cmnM9Evcq5f1zDeC/HmlmzR8Z7q+wbwYDSXFutsSHjjXMab6zEeOOYjTcWaIy4btjB0zHeWLPGuwdZbyX1Jr01/BxWSobxivoqaRhvJWBdlX1gvJUZjLeKYeMNxCWcz0S9yrmvomG8gTgza/bIeIvKvhEMKM211fpEyHirOo33CYnxVmU23ieAxqjaDTt4Osb7hFnj3Y2s90n1Ji0afg6fTIbxivqe1DDeJ4F1VfOB8VZjMN7qho3Xiks4n4l6lXNfXcN4rTgza/bIeG+TfSMYUJprq7VGyHhrOo23hsR4azIbbw2gMWp2ww6ejvHWMGu8u5D11lJv0tvCz2GtZBivqK+WhvHWAtb1lA+M9ykG433asPGmiEs4n4l6lXP/tIbxpogzs2aPjLeY7BvBgNJcW63PhIz3WafxPiMx3meZjfcZoDGe7YYdPB3jfcas8f6CrPc59SYtFn4On0uG8Yr6ntMw3ueAdT3vA+N9nsF4axs23pRxCeczUa9y7mtrGG/KODNr9sh4i8u+EQwozbXVWidkvC84jbeOxHhfYDbeOkBjvNANO3g6xlvHrPHuRNZbV71Ji4efw7rJMF5RX10N460LrOtFHxjviwzGW8+w8aaKSzifiXqVc19Pw3hTxZlZs0fGW0L2jWBAaa6t1voh423gNN76EuNtwGy89YHGaNANO3g6xlvfrPH+jKz3JfUmLRF+Dl9KhvGK+l7SMN6XgHW97APjfZnBeF8xbLyp4xLOZ6Je5dy/omG8qePMrNkj471d9o1gQGmurdaGIeN91Wm8DSXG+yqz8TYEGuPVbtjB0zHehmaNdwey3kbqTXp7+DlslAzjFfU10jDeRsC6GvvAeBszGG8Tw8abJi7hfCbqVc59Ew3jTRNnZs0eGW9J2TeCAaW5tlpfCxlvU6fxviYx3qbMxvsa0BhNu2EHT8d4XzNrvNuR9TZTb9KS4eewWTKMV9TXTMN4mwHrau4D423OYLyvGzbetHEJ5zNRr3LuX9cw3rRxZtbskfGWkn0jGFCaa6u1Rch4WzqNt4XEeFsyG28LoDFadsMOno7xtjBrvNuQ9bZSb9JS4eewVTKMV9TXSsN4WwHrau0D423NYLxtDBtvuriE85moVzn3bTSMN12cmTV7ZLx3yL4RDCjNtdXaNmS87ZzG21ZivO2Yjbct0BjtumEHT8d425o13p+Q9bZXb9I7ws9h+2QYr6ivvYbxtgfW1cEHxtuBwXg7Gjbem+ISzmeiXuXcd9Qw3pvizKzZI+O9U/aNYEBprq3WTiHj7ew03k4S4+3MbLydgMbo3A07eDrG28ms8W5F1huv3qR3hp/D+GQYr6gvXsN444F1dfGB8XZhMN6uho03fVzC+UzUq5z7rhrGmz7OzJo9Mt7Ssm8EA0pzbbV2CxnvG07j7SYx3jeYjbcb0BhvdMMOno7xdjNrvFuQ9b6p3qSlw8/hm8kwXlHfmxrG+yawrrd8YLxvMRjv24aNN0NcwvlM1Kuc+7c1jDdDnJk1e2S8d8m+EQwozbXV2j1kvO84jbe7xHjfYTbe7kBjvNMNO3g6xtvdrPFuRtbbQ71J7wo/hz2SYbyivh4axtsDWFdPHxhvTwbj7WXYeDPGJZzPRL3Kue+lYbwZ48ys2SPjLSP7RjCgNNdWa++Q8fZxGm9vifH2YTbe3kBj9OmGHTwd4+1t1nh/RNbbV71Jy4Sfw77JMF5RX18N4+0LrKufD4y3H4Px9jdsvJniEs5nol7l3PfXMN5McWbW7JHx3i37RjCgNNdW64CQ8b7rNN4BEuN9l9l4BwCN8W437ODpGO8As8a7CVnvQPUmvTv8HA5MhvGK+gZqGO9AYF3v+cB432Mw3kGGjTdzXML5TNSrnPtBGsabOc7Mmj0y3rKybwQDSnNttb4fMt7BTuN9X2K8g5mN932gMQZ3ww6ejvG+b9Z4f0DWO0S9ScuGn8MhyTBeUd8QDeMdAqxrqA+MdyiD8Q4zbLw3xyWcz0S9yrkfpmG8N8eZWbNHxnuP7BvBgNJcW63DQ8Y7wmm8wyXGO4LZeIcDjTGiG3bwdIx3uFnj3Yisd6R6k94Tfg5HJsN4RX0jNYx3JLCuD3xgvB8wGO8ow8abJS7hfCbqVc79KA3jzRJnZs0eGe+9sm8EA0pzbbV+GDLe0U7j/VBivKOZjfdDoDFGd8MOno7xfmjWeDcg6x2j3qT3hp/DMckwXlHfGA3jHQOs6yMfGO9HDMb7sWHjvSUu4Xwm6lXO/ccaxntLnJk1e2S898m+EQwozbXVOjZkvOOcxjtWYrzjmI13LNAY47phB0/HeMeaNd71yHo/UW/S+8LP4SfJMF5R3ycaxvsJsK5PfWC8nzIY72eGjTdrXML5TNSrnPvPNIw3a5yZNXtkvPfLvhEMKM211To+ZLwTnMY7XmK8E5iNdzzQGBO6YQdPx3jHmzXedch6J6o36f3h53BiMoxX1DdRw3gnAuua5APjncRgvJMNG2+2uITzmahXOfeTNYw3W5yZNXtkvA/IvhEMKM211TolZLxTncY7RWK8U5mNdwrQGFO7YQdPx3inmDXetch6p6k36QPh53BaMoxX1DdNw3inAeua7gPjnc5gvDMMG2/2uITzmahXOfczNIw3e5yZNXtkvOVk3wgGlObaap0ZMt5ZTuOdKTHeWczGOxNojFndsIOnY7wzzRrv98h6Z6s3abnwczg7GcYr6putYbyzgXXN8YHxzmEw3rmGjTdHXML5TNSrnPu5GsabI87Mmj0y3gdl3wgGlObaap0XMt75TuOdJzHe+czGOw9ojPndsIOnY7zzzBrvGmS9C9Sb9MHwc7ggGcYr6lugYbwLgHUt9IHxLmQw3kWGjTdnXML5TNSrnPtFGsabM87Mmj0y3vKybwQDSnNttS4OGe8Sp/EulhjvEmbjXQw0xpJu2MHTMd7FZo33O2S9S9WbtHz4OVyaDOMV9S3VMN6lwLqW+cB4lzEY7+eGjTdXXML5TNSrnPvPNYw3V5yZNXtkvA/JvhEMKM211bo8ZLxfOI13ucR4v2A23uVAY3zRDTt4Osa73Kzxfousd4V6kz4Ufg5XJMN4RX0rNIx3BbCuL31gvF8yGO9Xho03d1zC+UzUq5z7rzSMN3ecmTV7ZLwVZN8IBpTm2mr9OmS8K53G+7XEeFcyG+/XQGOs7IYdPB3j/dqs8X6DrHeVepNWCD+Hq5JhvKK+VRrGuwpY12ofGO9qBuP9xrDx5olLOJ+JepVz/42G8eaJM7Nmj4z3Ydk3ggGlubZavw0Z73dO4/1WYrzfMRvvt0BjfNcNO3g6xvutWeNdjax3jXqTPhx+Dtckw3hFfWs0jHcNsK7vfWC83zMY71rDxps3LuF8JupVzv1aDePNG2dmzR4Z7yOybwQDSnNtta4LGe96p/GukxjvembjXQc0xvpu2MHTMd51Zo13FbLeDepN+kj4OdyQDOMV9W3QMN4NwLo2+sB4NzIY7w+GjTdfXML5TNSrnPsfNIw3X5yZNXtkvI/KvhEMKM211bopZLw/Oo13k8R4f2Q23k1AY/zYDTt4Osa7yazxrkTWu1m9SR8NP4ebk2G8or7NGsa7GVjXFh8Y7xYG491q2HjzxyWcz0S9yrnfqmG8+ePMrNmrcz+kq/kcP4EbUIawHNcqr4tX/RSeb1u3ZCTcBjaVSL5N/QBZ24Em113D9m6YmYo1bL/+T3Kv8Hw7knOSd+AnudcO4CT/zHCSf8ZPcq+fQRdHd+TtobpQ999u8NgmPtCdokkq9ZoKxGHHVbemxkBN+ZlqagTUlI+ppleBmvIy1dQQqCkPU02vADXlZqrpZaCmXEw1vQTUlJOppgZATf/H3lkAx80s7doOMzM6zMzMzMzMzGzQ2mFm+sLMzMzMzMzMDHf0R+sry/a76tZsHFcd1elSap9ZTbdmpnveyeY7sf+ST40IPsX6Sz41JPgU8y/51IDgU4y/5FN9gk/R/5JP9Qg+RftLPtUl+BT1L/lUh+BTlL/kU22CT5H/kk+1CD5F+ks+1ST4FPEv+VSD4FOEv+RTdYJP4f+ST9UIPoX7Sz5VJfgU9i/5VIXgU5i/5FNlgk+h/5JPlQg+hfpLPlUk+BTyL/lUgeBTiL/kU3mCT65/yadyBJ9c/pJPZQk+/S75d3wqQ/Dp11/yqTTBp59/yadSBJ9+/CWfShJ8+v6XfCpB8OnbX/KpOMGnr3/Jp2IEn778JZ+KEnz6/Jd8KkLw6dNf8qkwwaePf8mnQgSfPvwlnwoSfHr/l3wqQPDp3V/yKT/Bp7d/yad8BJ/e/CWf8hJ8ev2XfMpD8OnVX/IpN8Gnl3/Jp1wEn178JZ9yEnx6/pd8ykHw6dlf8ik7waenf8mnbASfnvwln7ISfHr8l3zKQvDp0V/yKTPBp4d/yadMBJ8e/CWfMhJ8uv+XfMpA8OneX/IpPcGnu3/Jp3QEn+78JZ/SEny6/Zd8Sk3w6eZf8ikNwadbBJ/UHw+Gc5Hz40HCe/PzzwyuaT8evD7A0Ij6c3q9A45e6LXAf7jW0NDW9XoQ/RrzOvDx8+lpF6cOOdNmxLjVNzt7Ll6g7+8G99eYaoc3HP8a01/nNwi/GLzp5F9jqjHcdPxrTH8x3BzgnFVjjNEtpHeSGMWKfjndY2G3xp6LF6J+jd/Vr5pb2iDfNv7jHBUohs9ua5/pL0f/OAc56mjgbhFW123CC1BffHgXv+nDeLkF8rmxXz2jTrJbhMmi7+iOcbDuDPA/i6j/ago442+C3iEM4t0Bpl+mn5juMiab8Xm3CX5SYrpHmGz6mO5pMQW08qm/r1YX0jWCz2r76wOslQ9Hl35B3dcyywPjZL0fQGZ5oBts6ou4pqVqe3tHL8Ke2qn7guuEPu4TMtcDYsn4FzLXfWbmemicDA8lZK77hMz1kDCIj5iZ65GEzPWA4CclpsfMzPVYl7kCm4DOLH9W+uFO1ifGyfokgMkaiujMLWYWAX76Omv2uU8JbfXxPw1gYlPjp5RkyiKgxP+MOCHs8T8D5VvfnvI+0jDl7nOtvL4YYGhELWtpCHL3OaGsvQgiufuCKXdfcuWu2uFLhtx9SZC7r5wsd9UYXjHk7qsgkruvmHL3tTbIb4yp/XUAm9I3EuQuZeBeE1bXm2Aod18z6/Bb42C9lbBpfE2orW8Jg/iOuWl8J2HT+IbgJyWm98xN43uJclddSM8JPqvtXwywVj4cXfoF9UHLLB+Nk/VDAJnlowW5+1xL1fb2jl6EPbVT9wUvCH18IGSuj8FQ7n5gZq5PxsnwSULm+kDIXJ8Ig/iZmbk+S8hcHwl+UmL6wsxcX5wgdynlz0o/3Mn61ThZv0qQu6+ZWQT46eus2ed+Y8rdbxLkLqUkUxYBJf7vTLn73QlyNy1T7v7QyuvPAYZG1LKWliB3fxDK2s8gkrs/mXL3F1fuqh3+YsjdXwS5+9vJcleN4TdD7v4OIrn7myl3Xdy1/txd/C5tFSiGz1zdrctd0sC5m19dru7BT+66uPPqcAjjYKkfWN00Amf8TdAQ7uafG9Ld9Mv0E1NId+ubRleCn5SYQhEmmz6mUO7y5K66kH4QFpPa/ucAa+XD0aVfUKG1zBLGOFlDB5BZwrjz5e4PLVXb2zt6EfbUTt0X/CT0EZqQucIQssC/krlCMzNXWONkCCshc4UmZK6whFUejpm5wknIXGEIflJiCs/MXOHd5ctdSvnz+0VaP9zJGsE4WSO4W5e7Lu7OmdgRCM+NSGirjz+iu3W5SynJlEVAiT8ScULY44/kLl/upmPK3chaeY3ibmhELWvpCHI3MqGsRSGWNVlyN4o7T+5GdbfQofplqtyNav4FuUYjzG5uDNHc6XI3GnGQZcndaIQypl810bVBjmFM7dED2JTGkCB3KQMXnbC6YgRDuRudWYdjGgcrpoRNY3RCbY1JGMRYzE1jLAmbxhgEPykxxWZuGmNLlLvqQopM8FltH8XdWvlwdOkXVBwts8Q1TtY4AWSWuBbkbmQtVdvbO3oR9tRO3RdEIfQRh5C54gZDuRuHmbniGSdDPAmZKw4hc8UjDGJ8ZuaKLyFzxSX4SYkpATNzJXCC3KWUPyv9cCdrQuNkTShB7kZnZhHgp6+zZp+biCl3E0mQu5SSTFkElPgTM+VuYifI3fRMuZtEK69J3Q2NqGUtPUHuJiGUtaRBJHeTMuWuG1fu/l+HDLnrRpC7yZwsd9UYkjHkbrIgkrvJmHI3uTbIKYypPXkAm9IUEuQuZeCSE1ZXimAod5Mz63BK42CllLBpTE6orSkJg5iKuWlMJWHTmILgJyWm1MxNY2qJclddSEkIPqvtk7pbKx+OLv2CSqNllrTGyZomgMyS1oLcTaKlant7Ry/Cntqp+4KkhD7SEDJX2mAod9MwM1c642RIJyFzpSFkrnSEQUzPzFzpJWSutAQ/KTFlYGauDE6Qu5TyZ6Uf7mTNaJysGSXI3eTMLAL89HXW7HMzMeVuJglyl1KSKYuAEn9mptzN7AS5m4Epd7No5TWru6ERtaxlIMjdLISyljWI5G5WptzNxpW7aofZGHI3G0HuZney3FVjyM6Qu9mDSO5mZ8rdHNog5zSm9hwBbEpzSpC7lIHLQVhdOYOh3M3BrMO5jIOVS8KmMQehtuYiDGJu5qYxt4RNY06Cn5SY8jA3jXkkyl11IWUh+Ky2z+purXw4uvQLKq+WWfIZJ2veADJLPgtyN4uWqu3tHb0Ie2qn7guyEvrIS8hc+YKh3M3LzFz5jZMhv4TMlZeQufITBrEAM3MVkJC58hH8pMRUkJm5CjpB7lLKn5V+uJO1kHGyFpIgd3Mwswjw09dZs88tzJS7hSXIXUpJpiwCSvxFmHK3iBPkbkam3C2qlddi7oZG1LKWkSB3ixLKWrEgkrvFmHK3OFfuqh0WZ8jd4gS5W8LJcleNoQRD7pYIIrlbgil3S2qDXMqY2ksGsCktJUHuUgauJGF1lQqGcrcksw6XNg5WaQmbxpKE2lqaMIhlmJvGMhI2jaUIflJiKsvcNJaVKHfVhVSU4LPavpi7tfLh6NIvqHJaZilvnKzlAsgs5S3I3aJaqra3d/Qi7Kmdui8oRuijHCFzlQ+GcrccM3NVME6GChIyVzlC5qpAGMSKzMxVUULmKk/wkxJTJWbmquQEuUspf1b64U7WysbJWlmC3C3JzCLAT19nzT63ClPuVpEgdyklmbIIKPFXZcrdqk6Qu5mYcreaVl6ruxsaUctaJoLcrUYoa9WDSO5WZ8rdGly5q3ZYgyF3axDkbk0ny101hpoMuVsziORuTabcraUNcm1jaq8VwKa0tgS5Sxm4WoTVVTsYyt1azDpcxzhYdSRsGmsRamsdwiDWZW4a60rYNNYm+EmJqR5z01hPotxVF1I1gs9q++ru1sqHo0u/oOprmaWBcbLWDyCzNLAgd6tpqdre3tGLsKd26r6gOqGP+oTM1SAYyt36zMzV0DgZGkrIXPUJmashYRAbMTNXIwmZqwHBT0pMjZmZq7ET5C6l/FnphztZmxgnaxMJcrcWM4sAP32dNfvcpky521SC3KWUZMoioMTfjCl3mzlB7mZmyt3mWnlt4W5oRC1rmQlytzmhrLUIIrnbgil3W3LlrtphS4bcbUmQu62cLHfVGFox5G6rIJK7rZhyt7U2yG2Mqb11AJvSNhLkLmXgWhNWV5tgKHdbM+twW+NgtZWwaWxNqK1tCYPYjrlpbCdh09iG4CclpvbMTWN7iXJXXUjNCT6r7Vu4Wysfji79guqgZZaOxsnaIYDM0tGC3G2upWp7e0cvwp7aqfuCFoQ+OhAyV8dgKHc7MDNXJ+Nk6CQhc3UgZK5OhEHszMxcnSVkro4EPykxdWFmri5OkLuU8melH+5k7WqcrF0lyN3WzCwC/PR11uxzuzHlbjcJcpdSkimLgBJ/d6bc7e4EuZuFKXd7aOW1p7uhEbWsZSHI3R6EstYziORuT6bc7cWVu2qHvRhytxdB7vZ2stxVY+jNkLu9g0ju9mbK3T7aIPc1pvY+AWxK+0qQu5SB60NYXX2Dodztw6zD/YyD1U/CprEPobb2Iwxif+amsb+ETWNfgp+UmAYwN40DJMpddSH1IPistu/pbq18OLr0C8pdyywexsnqHkBm8bAgd3toqdre3tGLsKd26r6gJ6EPd0Lm8giGctedmbk8jZPBU0LmcidkLk/CIHoxM5eXhMzlQfCTEpPCzFyKE+QupfxZ6Yc7WW3GyWqTIHf7MLMI8NPXWbPP9WbKXW8JcpdSkimLgBK/D1Pu+jhB7mZlyt2BWnkd5G5oRP5PUhDk7kBCWRsURHJ3EFPuDubKXbXDwQy5O5ggd4c4We6qMQxhyN0hQSR3hzDl7lBtkIcZU/vQADalwyTIXcrADSWsrmHBUO4OZdbh4cbBGi5h0ziUUFuHEwZxBHPTOELCpnEYwU9KTCOZm8aREuWuupAGEnxW2w9yt1Y+HF36BTVKyyyjjZN1VACZZbQFuTtQS9X29o5ehD21U/cFgwh9jCJkrtHBUO6OYmauMcbJMEZC5hpFyFxjCIM4lpm5xkrIXKMJflJiGsfMXOOcIHcp5c9KP9zJOt44WcdLkLtDmVkE+OnrrNnnTmDK3QkS5C6lJFMWASX+iUy5O9EJcjcbU+5O0srrZHdDI2pZy0aQu5MIZW1yEMndyUy5O4Urd9UOpzDk7hSC3J3qZLmrxjCVIXenBpHcncqUu9O0QZ5uTO3TAtiUTpcgdykDN42wuqYHQ7k7jVmH/zMO1n8SNo3TCLX1P8IgzmBuGmdI2DROJ/hJiWkmc9M4U6LcVRfSJILPavvJ7tbKh6NLv6BmaZlltnGyzgogs8y2IHcnaana3t7Ri7Cnduq+YDKhj1mEzDU7GMrdWczMNcc4GeZIyFyzCJlrDmEQ5zIz11wJmWs2wU9KTPOYmWueE+QupfxZ6Yc7WecbJ+t8CXJ3GjOLAD99nTX73AVMubtAgtyllGTKIqDEv5Apdxc6Qe5mZ8rdRVp5XexuaEQta9kJcncRoawtDiK5u5gpd5dw5a7a4RKG3F1CkLtLnSx31RiWMuTu0iCSu0uZcneZNsjLjal9WQCb0uUS5C5l4JYRVtfyYCh3lzHr8ArjYK2QsGlcRqitKwiDuJK5aVwpYdO4nOAnJaZVzE3jKolyV11Iiwg+q+0Xu1srH44u/YJarWWWNcbJujqAzLLGgtxdpKVqe3tHL8Ke2qn7gsWEPlYTMteaYCh3VzMz11rjZFgrIXOtJmSutYRBXMfMXOskZK41BD8pMa1nZq71TpC7lPJnpR/uZN1gnKwbJMjdZcwsAvz0ddbsczcy5e5GCXKXUpIpi4AS/yam3N3kBLmbgyl3N2vldYu7oRG1rOUgyN3NhLK2JYjk7ham3N3Klbtqh1sZcncrQe5uc7LcVWPYxpC724JI7m5jyt3t2iDvMKb27QFsSndIkLuUgdtOWF07gqHc3c6swzuNg7VTwqZxO6G27iQM4i7mpnGXhE3jDoKflJh2MzeNuyXKXXUhbSb4rLbf4m6tfDi69Atqj5ZZ9hon654AMsteC3J3s5aq7e0dvQh7aqfuC7YQ+thDyFx7g6Hc3cPMXPuMk2GfhMy1h5C59hEGcT8zc+2XkLn2EvykxHSAmbkOOEHuUsqflX64k/WgcbIelCB3tzOzCPDT11mzzz3ElLuHJMhdSkmmLAJK/IeZcvewE+RuTqbcPaKV16PuhkbUspaTIHePEMra0SCSu0eZcvcYV+6qHR5jyN1jBLl73MlyV43hOEPuHg8iuXucKXdPaIN80pjaTwSwKT0pQe5SBu4EYXWdDIZy9wSzDp8yDtYpCZvGE4TaeoowiKeZm8bTEjaNJwl+UmI6w9w0npEod9WFdITgs9r+qLu18uHo0i+os1pmOWecrGcDyCznLMjdI1qqtrd39CLsqZ26LzhK6OMsIXOdC4Zy9ywzc503TobzEjLXWULmOk8YxAvMzHVBQuY6R/CTEtNFZua66AS5Syl/VvrhTtZLxsl6SYLcPcHMIsBPX2fNPvcyU+5eliB3KSWZsggo8V9hyt0rTpC7uZhy96pWXq+5GxpRy1ougty9Sihr14JI7l5jyt3rXLmrdnidIXevE+TuDSfLXTWGGwy5eyOI5O4Npty9qQ3yLWNqvxnApvSWBLlLGbibhNV1KxjK3ZvMOnzbOFi3JWwabxJq623CIN5hbhrvSNg03iL4SYnpLnPTeFei3FUX0lWCz2r7a+7WyoejS7+g7mmZ5b5xst4LILPctyB3r2qp2t7e0Yuwp3bqvuAaoY97hMx1PxjK3XvMzPXAOBkeSMhc9wiZ6wFhEB8yM9dDCZnrPsFPSkyPmJnrkRPkLqX8WemHO1kfGyfrYwly9yYziwA/fZ01+9wnTLn7RILcpZRkyiKgxP+UKXefOkHu5mbK3WdaeX3ubmhELWu5CXL3GaGsPQ8iufucKXdfcOWu2uELhtx9QZC7L50sd9UYXjLk7ssgkrsvmXL3lTbIr42p/VUAm9LXEuQuZeBeEVbX62Aod18x6/Ab42C9kbBpfEWorW8Ig/iWuWl8K2HT+JrgJyWmd8xN4zuJclddSM8IPqvtn7tbKx+OLv2Ceq9llg/Gyfo+gMzywYLcfaalant7Ry/Cntqp+4LnhD7eEzLXh2Aod98zM9dH42T4KCFzvSdkro+EQfzEzFyfJGSuDwQ/KTF9Zmauz06Qu5TyZ6Uf7mT9YpysXyTI3VfMLAL89HXW7HO/MuXuVwlyl1KSKYuAEv83ptz95gS5m4cpd79r5fWHu6ERtazlIcjd74Sy9iOI5O4Pptz9yZW7aoc/GXL3J0Hu/nKy3FVj+MWQu7+CSO7+Ysrd3/ZB9nDxu7R/B7ApVRsphodT5S5l4H4TVpfqm5uLuRfwr2wafzPrsKtxsNQPrG4afxNqq6uH+eeG8DD9Mv3EFMLD+qbRheAnJaaQhMmmjymkhzy5qy6k74TFpLb/4W6tfDi69AsqlMefe2jjZA3l4T+zhPbgy93vWqq2t3f0Iuypnbov+EHoI5SH+cwV2oNWMv6FzBWK4LO+ozDGyRBGQuYCzvjLXGEIqzwsM3OFlZC5QhP8pMQUjpm5wnnIl7uU8melH+5kDW+crOE9rMvd38wsAvz0ddbscyNQyqIu/gge1uUupSRTFgEl/ojECWGPP6KHfLmblyl3I2nlNbKHoRG1rOUlyN1IhLIWmVjWZMndyB48uRvFw0KH6pepcjeK+RfkGpUwu7kxRPWgy92oxEGWJXejEsqYftVE0wY5ujG1RwtgUxpdgtylDFw0wuqKHgzlbjRmHY5hHKwYEjaN0Qi1NQZhEGMyN40xJWwaoxP8pMQUi7lpjCVR7qoLKRLBZ7V9ZA9r5cPRpV9QsbXMEsc4WWMHkFniWJC7kbRUbW/v6EXYUzt1XxCZ0EdsQuaKEwzlbmxm5oprnAxxJWSu2ITMFZcwiPGYmSuehMwVh+AnJab4zMwV3wlyl1L+rPTDnawJjJM1gQS5G42ZRYCfvs6afW5CptxNKEHuUkoyZRFQ4k/ElLuJnCB38zHlbmKtvCbxMDSilrV8BLmbmFDWkgSR3E3ClLtJuXJX7TApQ+4mJchdNyfL3f97aQy56xZEcteNKXeTaYOc3JjakwWwKU0uQe5SBi4ZYXUlD4ZyNxmzDqcwDlYKCZvGZITamoIwiCmZm8aUEjaNyQl+UmJKxdw0ppIod9WFlJjgs9o+iYe18uHo0i+o1FpmSWOcrKkDyCxpLMjdxFqqtrd39CLsqZ26L0hC6CM1IXOlCYZyNzUzc6U1Toa0EjJXakLmSksYxHTMzJVOQuZKQ/CTElN6ZuZK7wS5Syl/VvrhTtYMxsmaQYLcTcbMIsBPX2fNPjcjU+5mlCB3KSWZsggo8Wdiyt1MTpC7+ZlyN7NWXrN4GBpRy1p+gtzNTChrWYJI7mZhyt2sXLmrdpiVIXezEuRuNifLXTWGbAy5my2I5G42ptzNrg1yDmNqzx7ApjSHBLlLGbjshNWVIxjK3ezMOpzTOFg5JWwasxNqa07CIOZibhpzSdg05iD4SYkpN3PTmFui3FUXUmaCz2r7LAy5Sylb+gWVR8sseY2TNU8AmSWvBbmbWUvV9vaOXoQ9tVP3BVkIfeQhZK68wVDu5mFmrnzGyZBPQubKQ8hc+QiDmJ+ZufJLyFx5CX5SYirAzFwFnCB3KeXPSj/cyVrQOFkLSpC72ZlZBPjp66zZ5xZiyt1CEuQupSRTFgEl/sJMuVvYCXK3AFPuFtHKa1EPQyNqWStAkLtFCGWtaBDJ3aJMuVuMK3fVDosx5G4xgtwt7mS5q8ZQnCF3iweR3C3OlLsltEEuaUztJQLYlJaUIHcpA1eCsLpKBkO5W4JZh0sZB6uUhE1jCUJtLUUYxNLMTWNpCZvGkgQ/KTGVYW4ay0iUu+pCKkLwWW1f1MNa+XB06RdUWS2zlDNO1rIBZJZyFuRuES1V29s7ehH21E7dFxQl9FGWkLnKBUO5W5aZucobJ0N5CZmrLCFzlScMYgVm5qogIXOVI/hJiakiM3NVdILcpZQ/K/1wJ2sl42StJEHulmBmEeCnr7Nmn1uZKXcrS5C7lJJMWQSU+Ksw5W4VJ8jdgky5W1Urr9U8DI2oZa0gQe5WJZS1akEkd6sx5W51rtxVO6zOkLvVCXK3hpPlrhpDDYbcrRFEcrcGU+7W1Aa5ljG11wxgU1pLgtylDFxNwuqqFQzlbk1mHa5tHKzaEjaNNQm1tTZhEOswN411JGwaaxH8pMRUl7lprCtR7qoLqSrBZ7V9NQ9r5cPRpV9Q9bTMUt84WesFkFnqW5C7VbVUbW/v6EXYUzt1X1CN0Ec9QuaqHwzlbj1m5mpgnAwNJGSueoTM1YAwiA2ZmauhhMxVn+AnJaZGzMzVyAlyl1L+rPTDnayNjZO1sQS5W5OZRYCfvs6afW4TptxtIkHuUkoyZRFQ4m/KlLtNnSB3CzHlbjOtvDb3MDSilrVCBLnbjFDWmgeR3G3OlLstuHJX7bAFQ+62IMjdlk6Wu2oMLRlyt2UQyd2WTLnbShvk1sbU3iqATWlrCXKXMnCtCKurdTCUu62YdbiNcbDaSNg0tiLU1jaEQWzL3DS2lbBpbE3wkxJTO+amsZ1EuasupGYEn9X2zT2slQ9Hl35BtdcySwfjZG0fQGbpYEHuNtNStb29oxdhT+3UfUFzQh/tCZmrQzCUu+2ZmaujcTJ0lJC52hMyV0fCIHZiZq5OEjJXB4KflJg6MzNXZyfIXUr5s9IPd7J2MU7WLhLkbitmFgF++jpr9rldmXK3qwS5SynJlEVAib8bU+52c4LcLcyUu9218trDw9CIWtYKE+Rud0JZ6xFEcrcHU+725MpdtcOeDLnbkyB3ezlZ7qox9GLI3V5BJHd7MeVub22Q+xhTe+8ANqV9JMhdysD1JqyuPsFQ7vZm1uG+xsHqK2HT2JtQW/sSBrEfc9PYT8KmsQ/BT0pM/Zmbxv4S5a66kLoTfFbb9/CwVj4cXfoFNUDLLO7GyToggMzibkHudtdStb29oxdhT+3UfUEPQh8DCJnLPRjK3QHMzOVhnAweEjLXAELm8iAMoiczc3lKyFzuBD8pMXkxM5eXE+QupfxZ6Yc7WRXjZFUkyN3ezCwC/PR11uxzbUy5a5MgdyklmbIIKPF7M+WutxPkbhGm3PXRyutAD0MjalkrQpC7PoSyNjCI5O5AptwdxJW7aoeDGHJ3EEHuDnay3FVjGMyQu4ODSO4OZsrdIdogDzWm9iEBbEqHSpC7lIEbQlhdQ4Oh3B3CrMPDjIM1TMKmcQihtg4jDOJw5qZxuIRN41CCn5SYRjA3jSMkyl11IfkQfFbbD/SwVj4cXfoFNVLLLKOMk3VkAJlllAW566Olant7Ry/Cntqp+4KBhD5GEjLXqGAod0cyM9do42QYLSFzjSRkrtGEQRzDzFxjJGSuUQQ/KTGNZWausU6Qu5TyZ6Uf7mQdZ5ys4yTI3SHMLAL89HXW7HPHM+XueAlyl1KSKYuAEv8Eptyd4AS5W5Qpdydq5XWSh6ER+T9JQZC7EwllbVIQyd1JTLk7mSt31Q4nM+TuZILcneJkuavGMIUhd6cEkdydwpS7U7VBnmZM7VMD2JROkyB3KQM3lbC6pgVDuTuVWYenGwdruoRN41RCbZ1OGMT/mJvG/yRsGqcR/KTENIO5aZwhUe6qC2kiwWe1/SQPa+XD0aVfUDO1zDLLOFlnBpBZZlmQuxO1VG1v7+hF2FM7dV8widDHTELmmhUM5e5MZuaabZwMsyVkrpmEzDWbMIhzmJlrjoTMNYvgJyWmuczMNdcJcpdS/qz0w52s84yTdZ4EuTuVmUWAn77Omn3ufKbcnS9B7lJKMmURUOJfwJS7C5wgd4sx5e5Crbwu8jA0opa1YgS5u5BQ1hYFkdxdxJS7i7lyV+1wMUPuLibI3SVOlrtqDEsYcndJEMndJUy5u1Qb5GXG1L40gE3pMglylzJwSwmra1kwlLtLmXV4uXGwlkvYNC4l1NblhEFcwdw0rpCwaVxG8JMS00rmpnGlRLmrLqSFBJ/V9os8rJUPR5d+Qa3SMstq42RdFUBmWW1B7i7UUrW9vaMXYU/t1H3BIkIfqwiZa3UwlLurmJlrjXEyrJGQuVYRMtcawiCuZWautRIy12qCn5SY1jEz1zonyF1K+bPSD3eyrjdO1vUS5O5SZhYBfvo6a/a5G5hyd4MEuUspyZRFQIl/I1PubnSC3C3OlLubtPK62cPQiFrWihPk7iZCWdscRHJ3M1PubuHKXbXDLQy5u4Ugd7c6We6qMWxlyN2tQSR3tzLl7jZtkLcbU/u2ADal2yXIXcrAbSOsru3BUO5uY9bhHcbB2iFh07iNUFt3EAZxJ3PTuFPCpnE7wU9KTLuYm8ZdEuWuupA2EXxW22/2sFY+HF36BbVbyyx7jJN1dwCZZY8FubtJS9X29o5ehD21U/cFmwl97CZkrj3BUO7uZmauvcbJsFdC5tpNyFx7CYO4j5m59knIXHsIflJi2s/MXPudIHcp5c9KP9zJesA4WQ9IkLvbmFkE+OnrrNnnHmTK3YMS5C6lJFMWASX+Q0y5e8gJcrcEU+4e1srrEQ9DI2pZK0GQu4cJZe1IEMndI0y5e5Qrd9UOjzLk7lGC3D3mZLmrxnCMIXePBZHcPcaUu8e1QT5hTO3HA9iUnpAgdykDd5ywuk4EQ7l7nFmHTxoH66SETeNxQm09SRjEU8xN4ykJm8YTBD8pMZ1mbhpPS5S76kI6TPBZbX/Ew1r5cHTpF9QZLbOcNU7WMwFklrMW5O5hLVXb2zt6EfbUTt0XHCH0cYaQuc4GQ7l7hpm5zhknwzkJmesMIXOdIwzieWbmOi8hc50l+EmJ6QIzc11wgtyllD8r/XAn60XjZL0oQe4eZ2YR4Kevs2afe4kpdy9JkLuUkkxZBJT4LzPl7mUnyN2STLl7RSuvVz0MjahlrSRB7l4hlLWrQSR3rzLl7jWu3FU7vMaQu9cIcve6k+WuGsN1hty9HkRy9zpT7t7QBvmmMbXfCGBTelOC3KUM3A3C6roZDOXuDWYdvmUcrFsSNo03CLX1FmEQbzM3jbclbBpvEvykxHSHuWm8I1HuqgvpCsFntf1VD2vlw9GlX1B3tcxyzzhZ7waQWe5ZkLtXtFRtb+/oRdhTO3VfcJXQx11C5roXDOXuXWbmum+cDPclZK67hMx1nzCID5iZ64GEzHWP4CclpofMzPXQCXKXUv6s9MOdrI+Mk/WRBLl7g5lFgJ++zpp97mOm3H0sQe5SSjJlEVDif8KUu0+cIHdLMeXuU628PvMwNKKWtVIEufuUUNaeBZHcfcaUu8+5clft8DlD7j4nyN0XTpa7agwvGHL3RRDJ3RdMuftSG+RXxtT+MoBN6SsJcpcycC8Jq+tVMJS7L5l1+LVxsF5L2DS+JNTW14RBfMPcNL6RsGl8RfCTEtNb5qbxrUS5qy6kpwSf1fbPPKyVD0eXfkG90zLLe+NkfRdAZnlvQe4+1VK1vb2jF2FP7dR9wTNCH+8Imet9MJS775iZ64NxMnyQkLneETLXB8IgfmRmro8SMtd7gp+UmD4xM9cnJ8hdSvmz0g93sn42TtbPEuTuS2YWAX76Omv2uV+YcveLBLlLKcmURUCJ/ytT7n51gtwtzZS737Ty+t3D0Iha1koT5O43Qln7HkRy9ztT7v7gyl21wx8MufuDIHd/OlnuqjH8ZMjdn0Ekd38y5e4vbZB/G1P7rwA2pb8lyF3KwP0irK7fwVDu/mLWYRdPF78Do35gddP4i1Bb1f7MPtfV0/TL9BOT+j3FYky/KVmCEFMIT96mMYSnPLmrLqRvhPjU9t89rJUPR5d+QYX0/HMPZZysIT39Z5ZQnny5+01L1fb2jl6EPbVT9wXfCX2E9DSfuUJ5Bj+5G5Lgs76j0MbJEFpC5gLO+MtcoQmrPAwzc4WRkLlCEfykxBSWmbnCesqXu5TyZ6Uf7mQNZ5ys4Tyty91fzCwC/PR11uxzw1PKty7+8J7W5S6lJFMWASX+CMQJYY8/gqd8uVuGKXcjauU1kqehEbWslSHI3YiEshaJWNZkyd1Injy5G9nTQofql6lyN7L5F+QahTC7uTFE8aTL3SjEQZYld6MQyph+1UTVBjmaMbVHDWBTGs3TutylDFxUwuqKRngB/8qmMSqzDkc3DlZ0CZvGqITaGp0wiDGYm8YYEjaN0Qh+UmKKydw0xpQod9WFFJHgs9o+kqe18uHo0i+oWFpmiW2crLECyCyxLcjdiFqqtrd39CLsqZ26L4hE6CMWIXPFDoZyNxYzc8UxToY4EjJXLELmikMYxLjMzBVXQuaKTfCTElM8ZuaK5wS5Syl/VvrhTtb4xskaX4LcjcrMIsBPX2fNPjcBU+4mkCB3KSWZsggo8Sdkyt2ETpC7ZZlyN5FWXhN7GhpRy1pZgtxNRChriYNI7iZmyt0kXLmrdpiEIXeTEORuUifLXTWGpAy5mzSI5G5Sptx10wY5mTG1uwWwKU0mQe5SBs6NsLqSBUO568asw8mNg5VcwqbRjVBbkxMGMQVz05hCwqYxGcFPSkwpmZvGlBLlrrqQEhF8Vtsn9rRWPhxd+gWVSsssqY2TNVUAmSW1BbmbSEvV9vaOXoQ9tVP3BYkJfaQiZK7UwVDupmJmrjTGyZBGQuZKRchcaQiDmJaZudJKyFypCX5SYkrHzFzpnCB3KeXPSj/cyZreOFnTS5C7bswsAvz0ddbsczMw5W4GCXKXUpIpi4ASf0am3M3oBLlbjil3M2nlNbOnoRG1rJUjyN1MhLKWOYjkbmam3M3Clbtqh1kYcjcLQe5mdbLcVWPIypC7WYNI7mZlyt1s2iBnN6b2bAFsSrNLkLuUgctGWF3Zg6HczcaswzmMg5VDwqYxG6G25iAMYk7mpjGnhE1jdoKflJhyMTeNuSTKXXUhZSL4rLbP7GmtfDi69Asqt5ZZ8hgna+4AMkseC3I3k5aq7e0dvQh7aqfuCzIT+shNyFx5gqHczc3MXHmNkyGvhMyVm5C58hIGMR8zc+WTkLnyEPykxJSfmbnyO0HuUsqflX64k7WAcbIWkCB3szGzCPDT11mzzy3IlLsFJchdSkmmLAJK/IWYcreQE+RueabcLayV1yKehkbUslaeIHcLE8pakSCSu0WYcrcoV+6qHRZlyN2iBLlbzMlyV42hGEPuFgsiuVuMKXeLa4NcwpjaiwewKS0hQe5SBq44YXWVCIZytzizDpc0DlZJCZvG4oTaWpIwiKWYm8ZSEjaNJQh+UmIqzdw0lpYod9WFVJjgs9q+iKe18uHo0i+oMlpmKWucrGUCyCxlLcjdwlqqtrd39CLsqZ26LyhC6KMMIXOVDYZytwwzc5UzToZyEjJXGULmKkcYxPLMzFVeQuYqS/CTElMFZuaq4AS5Syl/VvrhTtaKxslaUYLcLc7MIsBPX2fNPrcSU+5WkiB3KSWZsggo8Vdmyt3KTpC7FZhyt4pWXqt6GhpRy1oFgtytQihrVYNI7lZlyt1qXLmrdliNIXerEeRudSfLXTWG6gy5Wz2I5G51ptytoQ1yTWNqrxHAprSmBLlLGbgahNVVMxjK3RrMOlzLOFi1JGwaaxBqay3CINZmbhprS9g01iT4SYmpDnPTWEei3FUXUhWCz2r7qp7WyoejS7+g6mqZpZ5xstYNILPUsyB3q2ip2t7e0Yuwp3bqvqAqoY+6hMxVLxjK3brMzFXfOBnqS8hcdQmZqz5hEBswM1cDCZmrHsFPSkwNmZmroRPkLqX8WemHO1kbGSdrIwlytwYziwA/fZ01+9zGTLnbWILcpZRkyiKgxN+EKXebOEHuVmTK3aZaeW3maWhELWsVCXK3KaGsNQsiuduMKXebc+Wu2mFzhtxtTpC7LZwsd9UYWjDkbosgkrstmHK3pTbIrYypvWUAm9JWEuQuZeBaElZXq2Aod1sy63Br42C1lrBpbEmora0Jg9iGuWlsI2HT2IrgJyWmtsxNY1uJclddSE0JPqvtm3laKx+OLv2CaqdllvbGydougMzS3oLcbaqlant7Ry/Cntqp+4JmhD7aETJX+2Aod9sxM1cH42ToICFztSNkrg6EQezIzFwdJWSu9gQ/KTF1YmauTk6Qu5TyZ6Uf7mTtbJysnSXI3ZbMLAL89HXW7HO7MOVuFwlyl1KSKYuAEn9Xptzt6gS5W4kpd7tp5bW7p6ERtaxVIsjdboSy1j2I5G53ptztwZW7aoc9GHK3B0Hu9nSy3FVj6MmQuz2DSO72ZMrdXtog9zam9l4BbEp7S5C7lIHrRVhdvYOh3O3FrMN9jIPVR8KmsRehtvYhDGJf5qaxr4RNY2+Cn5SY+jE3jf0kyl11IXUj+Ky27+5prXw4uvQLqr+WWQYYJ2v/ADLLAAtyt5uWqu3tHb0Ie2qn7gu6E/roT8hcA4Kh3O3PzFzuxsngLiFz9SdkLnfCIHowM5eHhMw1gOAnJSZPZubydILcpZQ/K/1wJ6uXcbJ6SZC7vZhZBPjp66zZ5ypMuatIkLuUkkxZBJT4bUy5a3OC3K3MlLveWnn18TQ0opa1ygS5600oaz5BJHd9mHJ3IFfuqh0OZMjdgQS5O8jJcleNYRBD7g4KIrk7iCl3B2uDPMSY2gcHsCkdIkHuUgZuMGF1DQmGcncwsw4PNQ7WUAmbxsGE2jqUMIjDmJvGYRI2jUMIflJiGs7cNA6XKHfVheRN8Flt7+NprXw4uvQLaoSWWUYaJ+uIADLLSAty11tL1fb2jl6EPbVT9wU+hD5GEDLXyGAod0cwM9co42QYJSFzjSBkrlGEQRzNzFyjJWSukQQ/KTGNYWauMU6Qu5TyZ6Uf7mQda5ysYyXI3cHMLAL89HXW7HPHMeXuOAlyl1KSKYuAEv94ptwd7wS5W4Updydo5XWip6ERtaxVIcjdCYSyNjGI5O5EptydxJW7aoeTGHJ3EkHuTnay3FVjmMyQu5ODSO5OZsrdKdogTzWm9ikBbEqnSpC7lIGbQlhdU4Oh3J3CrMPTjIM1TcKmcQqhtk4jDOJ05qZxuoRN41SCn5SY/mNuGv+TKHfVhTSB4LPafqKntfLh6NIvqBlaZplpnKwzAsgsMy3I3Qlaqra3d/Qi7Kmdui+YSOhjBiFzzQyGcncGM3PNMk6GWRIy1wxC5ppFGMTZzMw1W0LmmknwkxLTHGbmmuMEuUspf1b64U7WucbJOleC3J3CzCLAT19nzT53HlPuzpMgdyklmbIIKPHPZ8rd+U6Qu1WZcneBVl4Xehoakf+TFAS5u4BQ1hYGkdxdyJS7i7hyV+1wEUPuLiLI3cVOlrtqDIsZcndxEMndxUy5u0Qb5KXG1L4kgE3pUglylzJwSwira2kwlLtLmHV4mXGwlknYNC4h1NZlhEFcztw0LpewaVxK8JMS0wrmpnGFRLmrLqQFBJ/V9gs9rZUPR5d+Qa3UMssq42RdGUBmWWVB7i7QUrW9vaMXYU/t1H3BQkIfKwmZa1UwlLsrmZlrtXEyrJaQuVYSMtdqwiCuYWauNRIy1yqCn5SY1jIz11onyF1K+bPSD3eyrjNO1nUS5O4SZhYBfvo6a/a565lyd70EuUspyZRFQIl/A1PubnCC3K3GlLsbtfK6ydPQiFrWqhHk7kZCWdsURHJ3E1PububKXbXDzQy5u5kgd7c4We6qMWxhyN0tQSR3tzDl7lZtkLcZU/vWADal2yTIXcrAbSWsrm3BUO5uZdbh7cbB2i5h07iVUFu3EwZxB3PTuEPCpnEbwU9KTDuZm8adEuWuupA2EnxW22/ytFY+HF36BbVLyyy7jZN1VwCZZbcFubtRS9X29o5ehD21U/cFmwh97CJkrt3BUO7uYmauPcbJsEdC5tpFyFx7CIO4l5m59krIXLsJflJi2sfMXPucIHcp5c9KP9zJut84WfdLkLtbmVkE+OnrrNnnHmDK3QMS5C6lJFMWASX+g0y5e9AJcrc6U+4e0srrYU9DI2pZq06Qu4cIZe1wEMndw0y5e4Qrd9UOjzDk7hGC3D3qZLmrxnCUIXePBpHcPcqUu8e0QT5uTO3HAtiUHpcgdykDd4ywuo4HQ7l7jFmHTxgH64SETeMxQm09QRjEk8xN40kJm8bjBD8pMZ1ibhpPSZS76kI6RPBZbX/Y01r5cHTpF9RpLbOcMU7W0wFkljMW5O4hLVXb2zt6EfbUTt0XHCb0cZqQuc4EQ7l7mpm5zhonw1kJmes0IXOdJQziOWbmOichc50h+EmJ6Twzc513gtyllD8r/XAn6wXjZL0gQe4eY2YR4Kevs2afe5Epdy9KkLuUkkxZBJT4LzHl7iUnyN0aTLl7WSuvVzwNjahlrQZB7l4mlLUrQSR3rzDl7lWu3FU7vMqQu1cJcveak+WuGsM1hty9FkRy9xpT7l7XBvmGMbVfD2BTekOC3KUM3HXC6roRDOXudWYdvmkcrJsSNo3XCbX1JmEQbzE3jbckbBpvEPykxHSbuWm8LVHuqgvpMsFntf0VT2vlw9GlX1B3tMxy1zhZ7wSQWe5akLuXtVRtb+/oRdhTO3VfcIXQxx1C5robDOXuHWbmumecDPckZK47hMx1jzCI95mZ676EzHWX4CclpgfMzPXACXKXUv6s9MOdrA+Nk/WhBLl7nZlFgJ++zpp97iOm3H0kQe5SSjJlEVDif8yUu4+dIHdrMuXuE628PvU0NKKWtZoEufuEUNaeBpHcfcqUu8+4clft8BlD7j4jyN3nTpa7agzPGXL3eRDJ3edMuftCG+SXxtT+IoBN6UsJcpcycC8Iq+tlMJS7L5h1+JVxsF5J2DS+INTWV4RBfM3cNL6WsGl8SfCTEtMb5qbxjUS5qy6kJwSf1fZPPa2VD0eXfkG91TLLO+NkfRtAZnlnQe4+0VK1vb2jF2FP7dR9wVNCH28JmetdMJS7b5mZ671xMryXkLneEjLXe8IgfmBmrg8SMtc7gp+UmD4yM9dHJ8hdSvmz0g93sn4yTtZPEuTuC2YWAX76Omv2uZ+ZcvezBLlLKcmURUCJ/wtT7n5xgtytxZS7X7Xy+s3T0Iha1moR5O5XQln7FkRy9xtT7n7nyl21w+8MufudIHd/OFnuqjH8YMjdH0Ekd38w5e5PbZB/GVP7zwA2pb8kyF3KwP0krK5fwVDu/mTW4d/GwfotYdP4k1Bbf1NWn5fpl+knJvV7isWYfhH8pMTk6sXbNLp6yZO76kL6SvBZbf/N01r5cHTpF1QIrz/3kOpd/xJCePnPLCG9+HL3q5aq7e0dvQh7aqfuC74R+gjhZT5zhfQKfnI3BMFnfUehjJNB/cBq5gLO+MtcobzMPzc0M3OFlpC5QhL8pMQUhpm5wnjJl7uU8melH+5kDWucrGG9rMvdn8wsAvz0ddbsc8MR2urjD+dlXe5SSjJlEVDiD0+cEPb4w3vJl7u1mXI3glZeI3oZGlHLWm2C3I1AKGsRiWVNltyN6MWTu5G8LHSofpkqdyOZf0GukQmzmxtDZC+63I1MHGRZcjcyoYzpV00UbZCjGlN7lAA2pVG9rMtdysBFIayuqIQX8K9sGqMw63A042BFk7BpjEKordEIgxiduWmMLmHTGJXgJyWmGMxNYwyJclddSBEIPqvtI3pZKx+OLv2CiqlllljGyRozgMwSy4LcjaClant7Ry/Cntqp+4KIhD5iEjJXrGAod2MyM1ds42SILSFzxSRkrtiEQYzDzFxxJGSuWAQ/KTHFZWauuE6Qu5TyZ6Uf7mSNZ5ys8STI3SjMLAL89HXW7HPjM+VufAlyl1KSKYuAEn8CptxN4AS5W4cpdxNq5TWRl6ERtazVIcjdhISyliiI5G4iptxNzJW7aoeJGXI3MUHuJnGy3FVjSMKQu0mCSO4mYcrdpNoguxlTe9IANqVuEuQuZeCSElaXWzCUu0mZdTiZcbCSSdg0JiXU1mSEQUzO3DQml7BpdCP4SYkpBXPTmEKi3FUXUkKCz2r7RF7WyoejS7+gUmqZJZVxsqYMILOksiB3E2qp2t7e0Yuwp3bqviARoY+UhMyVKhjK3ZTMzJXaOBlSS8hcKQmZKzVhENMwM1caCZkrFcFPSkxpmZkrrRPkLqX8WemHO1nTGSdrOglyNykziwA/fZ01+9z0TLmbXoLcpZRkyiKgxJ+BKXczOEHu1mXK3Yxaec3kZWhELWt1CXI3I6GsZQoiuZuJKXczc+Wu2mFmhtzNTJC7WZwsd9UYsjDkbpYgkrtZmHI3qzbI2YypPWsAm9JsEuQuZeCyElZXtmAod7My63B242Bll7BpzEqordkJg5iDuWnMIWHTmI3gJyWmnMxNY06JclddSBkJPqvtM3lZKx+OLv2CyqVlltzGyZorgMyS24Lczailant7Ry/Cntqp+4JMhD5yETJX7mAod3MxM1ce42TIIyFz5SJkrjyEQczLzFx5JWSu3AQ/KTHlY2aufE6Qu5TyZ6Uf7mTNb5ys+SXI3azMLAL89HXW7HMLMOVuAQlyl1KSKYuAEn9Bptwt6AS5W48pdwtp5bWwl6ERtazVI8jdQoSyVjiI5G5hptwtwpW7aodFGHK3CEHuFnWy3FVjKMqQu0WDSO4WZcrdYtogFzem9mIBbEqLS5C7lIErRlhdxYOh3C3GrMMljINVQsKmsRihtpYgDGJJ5qaxpIRNY3GCn5SYSjE3jaUkyl11IRUi+Ky2L+xlrXw4uvQLqrSWWcoYJ2vpADJLGQtyt5CWqu3tHb0Ie2qn7gsKE/ooTchcZYKh3C3NzFxljZOhrITMVZqQucoSBrEcM3OVk5C5yhD8pMRUnpm5yjtB7lLKn5V+uJO1gnGyVpAgd4sxswjw09dZs8+tyJS7FSXIXUpJpiwCSvyVmHK3khPkbn2m3K2sldcqXoZG1LJWnyB3KxPKWpUgkrtVmHK3Klfuqh1WZcjdqgS5W83JcleNoRpD7lYLIrlbjSl3q2uDXMOY2qsHsCmtIUHuUgauOmF11QiGcrc6sw7XNA5WTQmbxuqE2lqTMIi1mJvGWhI2jTUIflJiqs3cNNaWKHfVhVSZ4LPavoqXtfLh6NIvqDpaZqlrnKx1AsgsdS3I3cpaqra3d/Qi7Kmdui+oQuijDiFz1Q2GcrcOM3PVM06GehIyVx1C5qpHGMT6zMxVX0LmqkvwkxJTA2bmauAEuUspf1b64U7WhsbJ2lCC3K3OzCLAT19nzT63EVPuNpIgdyklmbIIKPE3Zsrdxk6Quw2YcreJVl6behkaUctaA4LcbUIoa02DSO42ZcrdZly5q3bYjCF3mxHkbnMny101huYMuds8iORuc6bcbaENcktjam8RwKa0pQS5Sxm4FoTV1TIYyt0WzDrcyjhYrSRsGlsQamsrwiC2Zm4aW0vYNLYk+EmJqQ1z09hGotxVF1ITgs9q+6Ze1sqHo0u/oNpqmaWdcbK2DSCztLMgd5toqdre3tGLsKd26r6gKaGPtoTM1S4Yyt22zMzV3jgZ2kvIXG0Jmas9YRA7MDNXBwmZqx3BT0pMHZmZq6MT5C6l/FnphztZOxknaycJcrcFM4sAP32dNfvczky521mC3KWUZMoioMTfhSl3uzhB7jZkyt2uWnnt5mVoRC1rDQlytyuhrHULIrnbjSl3u3Plrtphd4bc7U6Quz2cLHfVGHow5G6PIJK7PZhyt6c2yL2Mqb1nAJvSXhLkLmXgehJWV69gKHd7Mutwb+Ng9ZawaexJqK29CYPYh7lp7CNh09iL4Cclpr7MTWNfiXJXXUhdCT6r7bt5WSsfji79guqnZZb+xsnaL4DM0t+C3O2qpWp7e0cvwp7aqfuCboQ++hEyV/9gKHf7MTPXAONkGCAhc/UjZK4BhEF0Z2YudwmZqz/BT0pMHszM5eEEuUspf1b64U5WT+Nk9ZQgd3syswjw09dZs8/1YspdLwlyl1KSKYuAEr/ClLuKE+RuI6bctWnl1dvL0Iha1hoR5K6NUNa8g0juejPlrg9X7qod+jDkrg9B7g50stxVYxjIkLsDg0juDmTK3UHaIA82pvZBAWxKB0uQu5SBG0RYXYODodwdxKzDQ4yDNUTCpnEQobYOIQziUOamcaiETeNggp+UmIYxN43DJMpddSHZCD6r7b29rJUPR5d+QQ3XMssI42QdHkBmGWFB7tq0VG1v7+hF2FM7dV/gTehjOCFzjQiGcnc4M3ONNE6GkRIy13BC5hpJGMRRzMw1SkLmGkHwkxLTaGbmGu0EuUspf1b64U7WMcbJOkaC3B3EzCLAT19nzT53LFPujpUgdyklmbIIKPGPY8rdcU6Qu42Zcne8Vl4neBkaUctaY4LcHU8oaxOCSO5OYMrdiVy5q3Y4kSF3JxLk7iQny101hkkMuTspiOTuJKbcnawN8hRjap8cwKZ0igS5Sxm4yYTVNSUYyt3JzDo81ThYUyVsGicTautUwiBOY24ap0nYNE4h+EmJaTpz0zhdotxVF9J4gs9q+wle1sqHo0u/oP7TMssM42T9L4DMMsOC3B2vpWp7e0cvwp7aqfuCCYQ+/iNkrhnBUO7+x8xcM42TYaaEzPUfIXPNJAziLGbmmiUhc80g+EmJaTYzc812gtyllD8r/XAn6xzjZJ0jQe5OZmYR4Kevs2afO5cpd+dKkLuUkkxZBJT45zHl7jwnyN0mTLk7XyuvC7wMjahlrQlB7s4nlLUFQSR3FzDl7kKu3FU7XMiQuwsJcneRk+WuGsMihtxdFERydxFT7i7WBnmJMbUvDmBTukSC3KUM3GLC6loSDOXuYmYdXmocrKUSNo2LCbV1KWEQlzE3jcskbBqXEPykxLScuWlcLlHuqgtpPsFntf0CL2vlw9GlX1ArtMyy0jhZVwSQWVZakLvztVRtb+/oRdhTO3VfsIDQxwpC5loZDOXuCmbmWmWcDKskZK4VhMy1ijCIq5mZa7WEzLWS4CclpjXMzLXGCXKXUv6s9MOdrGuNk3WtBLm7mJlFgJ++zpp97jqm3F0nQe5SSjJlEVDiX8+Uu+udIHebMuXuBq28bvQyNCL/JykIcncDoaxtDCK5u5Epdzdx5a7a4SaG3N1EkLubnSx31Rg2M+Tu5iCSu5uZcneLNshbjal9SwCb0q0S5C5l4LYQVtfWYCh3tzDr8DbjYG2TsGncQqit2wiDuJ25adwuYdO4leAnJaYdzE3jDolyV11IGwg+q+03elkrH44u/YLaqWWWXcbJujOAzLLLgtzdoKVqe3tHL8Ke2qn7go2EPnYSMteuYCh3dzIz127jZNgtIXPtJGSu3YRB3MPMXHskZK5dBD8pMe1lZq69TpC7lPJnpR/uZN1nnKz7JMjdLcwsAvz0ddbsc/cz5e5+CXKXUpIpi4AS/wGm3D3gBLnbjCl3D2rl9ZCXoRG1rDUjyN2DhLJ2KIjk7iGm3D3Mlbtqh4cZcvcwQe4ecbLcVWM4wpC7R4JI7h5hyt2j2iAfM6b2owFsSo9JkLuUgTtKWF3HgqHcPcqsw8eNg3VcwqbxKKG2HicM4gnmpvGEhE3jMYKflJhOMjeNJyXKXXUhHST4rLY/5GWtfDi69AvqlJZZThsn66kAMstpC3L3oJaq7e0dvQh7aqfuCw4R+jhFyFyng6HcPcXMXGeMk+GMhMx1ipC5zhAG8Swzc52VkLlOE/ykxHSOmbnOOUHuUsqflX64k/W8cbKelyB3jzKzCPDT11mzz73AlLsXJMhdSkmmLAJK/BeZcveiE+Ruc6bcvaSV18tehkbUstacIHcvEcra5SCSu5eZcvcKV+6qHV5hyN0rBLl71clyV43hKkPuXg0iuXuVKXevaYN83ZjarwWwKb0uQe5SBu4aYXVdD4Zy9xqzDt8wDtYNCZvGa4TaeoMwiDeZm8abEjaN1wl+UmK6xdw03pIod9WFdIngs9r+spe18uHo0i+o21pmuWOcrLcDyCx3LMjdS1qqtrd39CLsqZ26L7hM6OM2IXPdCYZy9zYzc901Toa7EjLXbULmuksYxHvMzHVPQua6Q/CTEtN9Zua67wS5Syl/VvrhTtYHxsn6QILcvcbMIsBPX2fNPvchU+4+lCB3KSWZsggo8T9iyt1HTpC7LZhy97FWXp94GRpRy1oLgtx9TChrT4JI7j5hyt2nXLmrdviUIXefEuTuMyfLXTWGZwy5+yyI5O4zptx9rg3yC2Nqfx7ApvSFBLlLGbjnhNX1IhjK3efMOvzSOFgvJWwanxNq60vCIL5ibhpfSdg0viD4SYnpNXPT+Fqi3FUX0mOCz2r7J17WyoejS7+g3miZ5a1xsr4JILO8tSB3H2up2t7e0Yuwp3bqvuAJoY83hMz1NhjK3TfMzPXOOBneSchcbwiZ6x1hEN8zM9d7CZnrLcFPSkwfmJnrgxPkLqX8WemHO1k/GifrRwly9zkziwA/fZ01+9xPTLn7SYLcpZRkyiKgxP+ZKXc/O0HutmTK3S9aef3qZWhELWstCXL3C6GsfQ0iufuVKXe/ceWu2uE3htz9RpC7350sd9UYvjPk7vcgkrvfmXL3hzbIP42p/UcAm9KfEuQuZeB+EFbXz2Aod38w6/Av42D9krBp/EGorb8Ig/ibuWn8LWHT+JPgJyUm1TG3QGJCm0b1e+J/UuSuupC+EHxW23/1slY+HF36BeWqaJ+pd/1LUIHxsxAKX+5+0VK1vb2jF2FP7dR9wVfKJlExn7lCKMFP7urjc9hY9+eQiovfgVc/sJq5gDP+MldIxfxzQym8zKV+T7EYUwiCn5SYQiu8zBVakS93KeXPSj/cyRpGcfE7sOoHxhlFlXs/mFkE+OnrrNnnhiW01cevfk9xsRY/pSRTFgEl/nAKbULY4w+nyJe7rZhyN7zy5x5BMTSilrVWBLmrdhpIW39lLYISNHI3gsKTuxEVCx2qX6bK3YiK+T4iKYTNKTMGtQ+q3NX75eiSKXdRv0juRlb+3KMoLn6XtgqMn0VRrMtdysBFVsyvrihK8JO7+vgcNtb9Oari4ndg1A+sbhqBM/4maFTF/HOjKaZfpp+Y1O8pFmOKQvCTElN0hbdpjK7Ik7vqQgpP8Fltr2Y1K+XD0aVfUDGUP/eY6l3/ElRg/Cymwpe76kugZBV7aqfuCyIQ+oihmM9cMRVayfgXMpc+PoeNdX+Opbj4HXj1A6uZCzjjL3PFUsw/N7bCy1zq9xSLMcUk+EmJKY7Cy1xxFPlyl1L+rPTDnaxxFRe/A6t+YJxRVLkH9jSWJnZcwnPjEdrq41e/p7hYi59SkimLgBJ/fIU2Iezxx1f+f+VSy/d+XTs37R6ucL/oV3KF753uTZhe2X7EPvaz35L/Xh3PN7ZIuzoZW3QpX1/fNoFX428rvbI1TLU03vtIRy7nKHJief/LR6PGumXbcTDt1wmN9G3NXPa2ocsvad/j+PCc1Rs32HXpQYG58UcPjtokX9XUY7rdLjVu54MQ+rZuM0/vzvi9ztdPobqUvJzg0Lcv3WuuPlzUPdTz5gmaDzm2N7W+LcWHRCXfLXRzt+0b7pNsoa3hk7XZoqXc/jJmvPjbr32ct3JJmbL6tiGXvcr9qHj6xK7jWqQ/VG/60+cLV2SMu+So27KCq0cMO/hlib4txYfUV9bGidQ22fxIrT4dLxOj/C/XfbNL5P1QqXyMoz9OJ//eZZ2fd3Y4UoEZkVMt2Otyf96A9yfyNBn+5eTVcqMPhJvuXahny2O/9W0pPri9nNE+cZo0iUpO3X0qdN+LM9eu3LVsSM7P306EH/DftCqnO+vbpjvpkSd83vV1D2Us7/I5f+Royxc/XDanTKg53YoMS7Jra4pu+rYUH0KkXLL80JEtF0P2uFTx3NzlsdvszpOhQNIBgxN7uabqWv28j75tirrN/xv77Hu6ma2rzo/+eFqsNckar1k81hYx9bX63m1SX46ub0vxIWq0Lp1K7xhbvvrYminHrnuXt0+T9wdKrfvyOdSB1q2alI6Q3s97WD7wQve354sU/xX+wIAxfaK9ie92KXb1qjHaZHsweMiA02n0bUnvYeq7B8nLvak2Y/jwneNqe+5y7Vw2arL/RsYvnbh9vYb7c0/Wtw3Z4EWFQW4LXtwbcHHZt133b9/NF7lnvgPxlxysf2pd2GVHCujbUnzIODltmZkP4iVZ7DkgfMwTHxKn7xm7QeIZ3s/mue2L1zdpFz/PTTNm8Jafk6pHbDSvwKsEjXNVOnhjzfESlzZ3bj7q+u+1rpd769tSfIh4d1yXvJlzZV9WY3HrXz3XLvXpW3HZ1hBjVy3e3azD/m7fi+nbRm1Vs2roJ5PfFi83qUXJb19X3uydoVePBUM2jlHq5048PoKbvi3Fh3S/B+ZZ1eDFsKmxiq3LmnteBq+Lu56+fvOkYOSLWwZ8b3Apir5t0nNlcmXoc69Nh+TXU5x2v+BdpkrNwjmVjfNnFP+Sb36YXdH0bSk+ZClw4emYkQPrnqw7dEi5Nx8fei/I1ap3j6l3Rld9WuG/+Auu+vGhRrkwZ5eNqLC4/NX7X+rf/5KucbVnq882aBS9revWFk3dGujbUnxI02vs1A+pNrcss+9gmrR12oacu6LR/QHbhtQ/4H7jd43pW7Pp20ZY4PmoUowrtU9vSVivYeKmp15smvDm56qWZUr/zlE436fEm/VtKT64NlxyaXCcn086jgt3/3qoj0PvvA/3KHJuz8kFPEpHfbqocUd924xf47nMvDYx/dGL00KezBRi4pUeYyaMiDkxbuRh6UN4RM05QN+W4kPkuD4X19XuXSv2+6NTR319u82zS5M1KUcO6/b9YMjfF+P1iaVvm3l7iSofBnntb560wP5DW1wyxD2TaYZb5V5v/xsTcdqztkUz6ttSfMga1W1i5jzL105y+5rt8273DtuOFi7ZbHHfyX2+Dr5f8uzHh/q20bsv2tTzUIc1eaLN3l5pwoVjSs3tM6+F85nebNjzOoOiR++kb0vxIeai9bZFLZYN7+VxfvD8JRM9SrXtOb/2xyzD386/UmFuGM9l+rbJy9Z0ibr0cJQhRdaWv7znTOLTnT6+D9EsR6EOLQ4P91g430+NpfiQIc+Nxhv2fzm+KIvLoBcxo9V49ihegsI9lmT26Ne7fIgcE0/o26Y5EndvnuZp5y/9uKLjqot968zftlCZs3dzhLif67fffC+Pu74txYfUqxIdqHFt/bvTZaOdKLLlc4w6eXPkWFYl/6nRm2aMWPCt0Vx927S7dys1E97K8/R69Px3n4ea8bbF78pLW1Vq9iH9pB2ZI8bdqW9L8SFKuubtN+3qWcwj3LqRY0bvDvGza5K0Zy8MiN/scZzHue5kiqFvG312rUu7v3fYZusza/XU99EOtk48KN+A8FW+39xe7HvqCuHYuTp0w2s1Htvev7rZO+K8AyM75T43p1nNioVyPG7msrNiqydT/Ixx2nxJhs1sGfZBiInfFj6snWBD9weFF16sGDtngelljvdXXobXt6X44FawaIp2T9btyJg3zQ7veX3PZ6x2Y/rWxrVOxW79ZFOqzTse69tmeFcr1YVFWWJUz1Wr3s1yHdpuq9R5UZMKrf9bf63HgZS13szXt6X4kLJtjxkvn+1aMHNH6X25Olw8nTPBgjrFu2+rsSCyUu7hq4mz9W2jjOixY0WHjKe/zXsY9dS0TGsTRCx94/rwC1uy15jwNeS8mvn1bUk+ZBp+ptGhe0sW/WzRpeyrI7Y7jZ+cWzg6dY24RcrVfDG4d0192wi/IvdfOHT+jc/j3iY9+bFi4rCnj4Q+uCpiiGhJl33berzWG31big+h9/c9U6/916/zyiR8mKH/meiZyr7O1TCP29Dnkbd0Lj7U00+eTDj37cpNndvsGLp3/bNfk9aFsKUNuWRzokWZnr4Mc2Tr+9Pv9W0pPoR6uC/mq92/T27I0DFPkupvLk5t2fHNsfS5ClSYNnRsz4Pzdvh5D49KZjhcIGqGTKW8Z1/5lj3Bpo2vTp6fOjzfm4ODQpe8VdVb35biQ8bJvWtX3ele4JVr9Apjp6zJfS9ywz7lf2VYfPFS+NnlxpT5qW8brt/RE409n015+zV+4aRnRowKOTa765Rb96atTrLJa/zBMOw5mSzm1FChbg+N8Plc/TSr9nZudrhrs2kxSjRoNizWNa+5S3wG6dtGa5smXr6JV67FDtm3Ws8RofOldqvWvM9uF5cv60dP+Xi9qZ/9L8WHmBsOvm14aPqXbluTDM60ZU2osjkPPrlWP61H2Ik5M2z1+rFI3zbuxKQxc+bNtbH73VF5lued8iVKqGZfN6fflHhR/DQ/pkbocE7fluJDuIZR262dFXpqW58bRy/myLm9zbTJg4dOaDRh5PMLG0o1GTdE3zZlhuH11/Q8Myt18QEJW+dYPN17W7FLFSu1UuK+j9epXeruCfVtKT4kXBv92upuj7IvOJqyfO4MN++2b/yjsbvHteLromYfu69PJz97ggylwuzumTDTwdndPodsE+fYngpdlBEV55aete7ngBO/63rv0bel+JCg97aRi7bcO1QvdvWEcRstteW5fezNxm+/o8V/3//HY/dpz/Rt4008cnhWu4fpyzX49Kt0/wUfd+5q2nLsJaXQ+1Rzeh1cE3a6vi3FhyzPii7dva76Ns/4GR4VWxA6pm1qmvibPWq7r7rXyiv3Ztfl+rZJlIvP+m2M0D1zq1NpKoyYNzfHrYmb67zutqF6vMJP6x5yu6tvS/EhmXu0KB0vVWj7NOm9zmNfzsm8rGrdem4xauxsXCtKxC1v3vmJLcbCAz8mpqjxtfmOBlPed5ievVOj7R2rVm99bk6cYo1GzdnVSt+W9B6q/khXuFS6aIMmZf+v8wDXaHuu186XZmedue2exBtYo3bTr/q2IWt6NZs9I+viZpNz2H5le5PtxcX1E86ljVVrUWfX1W+Gtcirb0vxIcydt8vWVKwR5erTuhXcwxwveun62V4pYq7dPXDqiuPeaR6X0LfNUOZJkZCPci3dF2XNpWLpat3aW2d4fHePap/K1gqTYkWDAqv0bSk+JH7l3qVRrzTnOi0M82rfyP2bE5yePrpdqTY9Zx58tKZHz8HZ9W1T1Ku1NPr9nmXr7b2eb/KypFFbFq/SZt/rRGNOjOzd/2PPsW31bSk+JKm/2GXSkrpnD8TOPe5povhvEgwtUjzzj/gvenccvKNYx+d+cl/UJGGOuIXxGBXhbcUvvXPs3dk7casdDfIOmztglUfXc2tns8/EslQa0zRnyRK5oibvEv/AmiTJpn7a0GtNusTn7uyfmiTPlIV39G0TLNuacXW7jE22zOq8fGqR1M/vhC9dMPGtUxFahQ43reKW8uyaFebO8gWhytdKUeLzthDvcl77VfHE4p+1UhRfUq7gw5K9Rr3xs59Mmb1dmsLuno8Xhhj6zvt4+27tXqRfEfLc7wFFS+fOu7JO8ov6thQfErx497pG6uRp7qafMW/647cV7mTbk3Po4qblQ5483C32u2a59W3D1ogX0aNkw2SNal3/2Xn32kPLdraLcDTL5Y7PqpV8XXD6iCL6thQf3DyqXvY5nGZpv6wFjnwMnXdlr4dfaseLXKXQvsOv4rWLc+qLn7axq9c4Ga7/1Agrs7dqmTLSsVKLMw4d3S5f40pjGs4/t7VzBH1big/Jrodfv2/ftLdrdvUfkzXbz7QFL759fSxC6RGeS+e87fok6WE/bTdGtYXNlf9H/zi1Q0WaOvRVvtzhikceum+OV850RTaFn8fWeiHiu8T5cKLkhEbRIh7efO1Bx2f1kqdOMnVY9IxHYn/72bCUH53lenvZ6TmRr4/LESrT1Bxn3aJ3/zS9VJdIE33ObBzdxHVjNz/7HYoPoR716nE7UuxxL6qd+xSx59vJ5Xe9LuwWbWDx+rVOdvt9Z4OfsUgaYtC6l4+m/54cP753jxirV4atsTfGsTWux9P+7pgxzbs+h/RtKT6ET1m15qh4M39VHpSi694eJVa9Hr8i/5idz8fcTFllyPnVIU/q26a4f7DQ+FaXbu2+XnTq8LGjW7YpkGXI2l/pw23s2L7I6YEfz+rbUnxIl2tX3tF3czf4tPREl3ONYoYJ69Nod7/UB4/9ujR2a9iM5+Po24aedXtH1aXtZqXb2mvejwK/+taa5tl15JMs86OcnXE0XtVPfsaN4kOyE8Pixvw+qGvsZOWWfl+XM9rlA5le3Gu9o+mEVlFKR09QuqG+bcoxZZuFfhX+Q5nHd35Xz9Dk7fUmLatnybB93ej+Yes1/F24n74txYdYXmG+xTi+5ezRMTPCXOw77V7kydW2j5obamW1tkd3RbtQzI/OStP6U5/4XTZFt1Vp1P9d+iW1GhZstbF77Ni918a53WB26EEe+rYUH1xL7Hq9+M2W791Tpy9YKHaI+Z1GVFzf4PX2PNfnL476K1U3P2szXrht7YZu31K3QZ/edZp+T//j5K9ypbu6lVjQYVTpRB7JErLPqxPs3/ty7cubM6pG/zKk3bcDoSMs8Y5890uVk4sfuHzpmnabHw0ZOtL2Sks8TxaJNPBSqsy97/6Xu+/WWodCvq+/89T9rUMXei3Qt6X4EHpx+IxtKo0pufJCn5efc888vGPrtUoJxxa5OOrKzkpxOj0u7Oc9pCp1asSib33jpWhTqOqP5ofPbm+SK/a1zg0z3L6ccky2JOx9tWvNuZl2Fzm/alidX7Gr5BmcdW+KMM9rFW80JfudVRlqHwsZRt82Vpihv9fcynG0eePs+WM+vd1lvfvAhDkPrB3hGf9i3PHnJ7DXRZaTHx5sSJa204eBP88MSfX7YZ60vSaF+1wl8pBHDa5mX532gr5tqo/dYxYrMju8d52C5VsXfX0/Q7OMHcdEDNEzVepIpdOdH5FM35big1vhq4t/J3kXP5pL4Vajdn/pXzjatT7et1xWd5vWMEWuIZMT69tG6v+gZNV4Dy9Uezvl8tCECSd9b12nYurf7drMd0+yvMnY/uH0bSk+xEyw88ilQ9mmv3r8ZO3gFff3eMSKsiHkgGRpGyRvenLA+2if9W1TdHuwb3PBO6tdC2R9NbtEqYE9M970HPf2SvG9i5Y2OJtpHHsfFaNousFFB6Uu3K/kmFuvx73KvHDBpNR5WnYI8Tb73hXjPK9f07dNdzZR8xM/Fl7JPrpat9LN8jw6fXZm7Z37tx9okT/Cy5xLo7TTt6X4kPhl6R9fO27ruiLShmN1c44cGyphqu7ZH/RecS73hurdihXZpW+b+kzF1k2XT57Qs8DHgz/eZi0zOPKvl4Wuhnz0u8vTuD9v9/iub0vxIUO2DSN6xPy0cP/bj7OfrixUYZjLlR6h279tlzhW9nDPGw4Zq2+b5tSR3mF+NZnUfP6Ztb++Rp7/5GyfZIfa7i++yVZ6eNXEr9nnMMnDRQxfpEDBqV9XH8yg1Kt0utriWI/di+6fMyjmMI8ei8P5WZuJdqx4+WHqs+dnCjTNWC7c3lYHI84dmCKSe/WUFac3ijKl3nN9W4oPoZuuH9T/Y4HDqVN6Zws94X6cmrmqvapTrJdPnIQ/np5NX6movm3GcWsHL+0ZucLsckeGTu2bN16OEw2a3JvV2Wf1t3Rx7rkMG6pvS/Eh45swOQfkjdg5yubWz28mTnkjycvpJfaFeVX3aakeIS+G3+9nvYU8G2foxzKpS7eYdvPUoBSxBtY4mbDjyoIXYr3qnP5T+w7tb+rbUnzI3NCz0vSm7YZlWBEj1thfT2a+3Zf3cI+Rs/NvnHZpw4ksH8bp20YtmPrjrelXpl5YsHbOqCRDfjb8kDvLlMnfh8Q+FLlE/BAn/ZwjUnyInW549WGNtxzNNyn8jaRRPg0fu3rf2IHn55w6NKnjQDfbf372D5n2nLgSNeH227mrNBiXfnLM7Fc/Xq/ZO0+pTZUjD7pfZPUQPzWW4kOmL1uLPhwWpXLMPndq9Pj2aHriXlXa5Xq0WNnUemLPbO9O+tnLZT459Gy9NjtqbBk0LnPkOIOb1Vyxadm+818apznm+Xrd3rF+/l7a0eWt3V2FXRvw535duz/X7i+0+w/t/lO7R3bXft+s3ZNo96TaPYt2z6rdi2r3Ytq9mnavrt2ba/cW2r2Hdu+p3Qdq90HafZJ2n6zdF2n3xdp9s3bfot2PaPej2v2qdr+m3Z9p9+fa/bt2/6HdI3locWv3xNo9iXbPrN2zaPci2r2odq+q3atp92bavbl2767de2h3H+0+ULtP1O6TtPtC7b5Iu2/S7pu1+2HtfkS7X9HuV7X7U+3+TLt/0+7ftXtETy1u7Z5IuyfW7pm0e2btXli7F9HuVbR7Ve3eVLs30+7dtHt37e6t3X20+wTtPlG7L9DuC7X7Ru2+Sbsf0u6Htftl7X5Fuz/R7k+1+1ft/k27R9D+VWtE7Z5QuyfS7hm1eybtXki7F9bulbV7Fe3eRLs31e5dtXs37W7T7t7afbx2n6Dd52v3Bdp9g3a3/z/nHtTu9v9roUva3f7fXn6s3e3/caov2t3+r3fVXwD/X9zirl5uLqauooS2lOe6JlDEOxeWSJH7T6PGM/9pVGLlzz2JYmhE/Qn0eMI/jVI7DaStv59AJ1HMBybzn0YlAT6ifxqVVLHQofpl6j+NSqqY78NNMT9I3BjUPlyJMej9cnTJ/KdRqF/0T6OSKX/uyRWtU/vPQFVg/Cy5Yv2fRlEGLplifnUlV8y/gH/lHxjo43PYWPfnFIqL34FRPzDOIuqP8YEz/iZoCsX8c1Mqpl+mn5jU7ykWY0pO8JMSUyrF/GTTx5RKkfdPo9SFlJjgs9pezWpWyoejS7+gUit/7mnUu/4lqMD4WRqF/0+j/u8lKOZfhD21U/cFSQh9pFbMZ640Cq1k/AuZSx+fw8Z6HxQXvwOvfmA1cwFn/GWutIr556ZTeJlL/Z5iMaY0BD8pMaVXeJkrvSL/n0ZRyp+VfriTNYPi4ndg1Q+MM4r6T4PAnsbSxM5AeG5GQlt9/Or3FBdr8VNKMmURUOLPpNAmhD3+TIrffxoVRtfOTbv/C/80KqiOJ+1zQX0/alVW73Y57uZi6nIltCU9N7MijvqEZVXkHleoxyAm2/pJmtmUP/fsiqERdVuid8DRxM+mmN+WZFdoAy/ruCK7Yl5t6/vLoVjoUP0y9bgih2K+j5yK+UHixqD24UqMQe+Xo0vmcQXqFx1X5FL+3HMrLn5TswqMn+VWrB9XUAYul2J+deVWzL+Af2XTr4/PYWPdn/MoLn4HRv3A6qYfOONvguZRzD83r2L6ZfqJSf2eYjGm3AQ/KTHlU3ib/nyKvOMKdSFlI/istlezmpXy4ejSL6j8yp97AfWufwkqMH5WQOEfV6gvgZJV7Kmdui/ITugjv2I+cxVQaCXjX8hc+vgcNtb9uaDi4nfg1Q+sZi7gjL/MVVAx/9xCCi9zqd9TLMZUgOAnJabCCi9zFVbkH1dQyp+VfriTtYji4ndg1Q+MM4oq18GextLELkJ4blFCW3386vcUF2vxU0oyZRFQ4i+m0CaEPf5iivz/cGlmgi/6RVdc+XMvoRgaUcua3gFHL664Yr6slVCCRu6WUHhyt6RioUP1y1S5W1Ix30cpxfwgcWNQ+6DKXb1fji6Zchf1i+RuaeXPvYzi4ndpq8D4WRnFutylDFxpxfzqKqMEP7mrj89hY92fyyoufgdG/cDqphE442+CllXMP7ecYvpl+olJ/Z5iMaYyBD8pMZVXeJvG8oo8uasupOIEn9X2alazUj4cXfoFVUH5c6+o3vUvQQXGzyoqfLmrvgRKVrGnduq+oAShjwqK+cxVUQl+clcfn8PGuj9XUlz8Drz6gdXMBZzxl7kqKeafW1nhZS71e4rFmCoS/KTEVEXhZa4qiny5Syl/VvrhTtaqiovfgVU/MM4oqtwDexpLE7sq4bnVCG318avfU1ysxU8pyZRFQIm/ukKbEPb4qyt+/3Y+vK6dm3b/33+49M8VVL8QsP9iQh0j9SBcvdtP+Ytrd/sRgZuLqSsEoS3lua41FBeXmsJqKXKPUNTnmmzrJ5HXVv7c6yiGRtStkt4BR4uxtmJ+q1RHoW2VZB2h1FHMnwDo+6urWOhQ/TL1CKWuYr6Peor5QeLGoPbhSoxB75ejS+YRCuoXHaHUV/7cGygufsuFCoyfNVCsH6FQBq6+Yn51NVDMv4B/RYjo43PYWPfnhoqL34FRP7AqRIAz/iZoQ8X8cxsppl+mn5jU7ykWY2pA8JMSU2OFJ0QaK/KOUNSFVJvgs9pezWpWyoejS7+gmih/7k3Vu/4lqMD4WVOFf4SivgRKVrGnduq+oA6hjyaK+czVVKGVjH8hc+njc9hY9+dmiovfgVc/sJq5gDP+Mlczxfxzmyu8zKV+T7EYU1OCn5SYWii8zNVCkX+EQil/VvrhTtaWiovfgVU/MM4o6hEC2NNYmtgtCc9tRWirj1/9nuJiLX5KSaYsAkr8rRXahLDH31qR/4uBtsx/z99G+XNvqxgaUctaW8K/51c7DaStv7LWVgkaudtW4cnddoqFDtUvU+VuO8V8H+0V84PEjUHtgyp39X45umTKXdQvkrsdlD/3joqL36WtAuNnHRXrcpcycB0U86uroxL85K4+PoeNdX/upLj4HRj1A6ubRuCMvwnaSTH/3M6K6ZfpJyb1e4rFmDoS/KTE1EXhbRq7KPLkrrqQ2hB8VturWc1K+XB06RdUV+XPvZt6178EFRg/66bw5a76EihZxZ7ayfsCxXwfXRXzmaubEvzkrj4+h411f+6uuPgdePUDq5kLOOMvc3VXzD+3h8LLXOr3FIsxdSP4SYmpp8LLXOr3xP+kyl1K+bPSD3ey9lJc/A6s+oFxRlHlHtjTWJrYvQjP7U1oq49f/Z7iYi1+SkmmLAJK/H0U2oSwx99HkS932zDlbl/lz72fYmhELWttCHJX7TSQtv7KWj8laORuP4Und/srFjpUv0yVu/0V830MUMwPEjcGtQ+q3NX75eiSKXdRv0juuit/7h6Ki9+lrQLjZx6KdblLGTh3xfzq8lCCn9zVx+ewse7PnoqL34FRP7C6aQTO+Jugnor553oppl+mn5jU7ykWY/Ig+EmJSVF4m0ZFkSd31YXUl+Cz2l7NalbKh6NLv6Bsyp+7t3rXvwQVGD/zVvhyV30JlKxiT+3UfUE/Qh82xXzm8laCn9zVx+ewse7PPoqL34FXP7CauYAz/jKXj2L+uQMVXuZSv6dYjMmb4CclpkEKL3MNUuTLXUr5s9IPd7IOVlz8Dqz6gXFGUeUe2NNYmtiDCc8dQmirj1/9nuJiLX5KSaYsAkr8QxXahLDHP1Tx+wP5SLp2btr9fz+Q/3MlKvluoZu7bd9wn2QLbQ2frM0WLeX2lzHjxd9+7eO8lUvK+Pl/pA657FXuR8XTJ3Yd1yL9oXrTnz5fuCJj3CVH3ZYVXD1i2MEvS/RtKT4E1Y/0w2l3dZ6ovz1T7/Yf1rXR7va/eeir3e3HFm4upq6QhLaU57oOU1xchgsbocg9hfAgnKro+xupWOhQ/bKDUwh/navfcTPZxyjF/HO5Mah9uBJj0Pvl6JKhRdT+2oWi+TdMob8P9Tsm2/rZoYxW/tzHKPYnETtuxxyIqRdoq5T6fPWFcPyaRvTLfoU29OMoHP2AOfJptGJeM41RzPtAGANXynuRmR318VDOaMcqFjpUv0w9ox2rmO9jnOLc7KjGoPbhSoxB75ejS+YZLeoXndGOV/7cJygufvejKjB+NkGxfkZLGbjxivlVO0Ex/wL+lZMOfXwOG+v+PFFx8Tsw6gfGWUQ9FQDO+JugExXzz52kmH6ZfmJSv6dYjGkCwU9KTJMV85NNH9NkRd4ZrbqQRhN8VturWc1K+XB06RfUFOXPfap6178EFRg/m6rwz2jVl0DJKvbUTj2jHUPoY4piPnNNVWgl41/IXPr4HDbW/Xma4uJ34NUPrGYu4Iy/zDVNMf/c6Qovc6nfUyzGNJXgJyWm/xRe5vpPkX9GSyl/VvrhTtYZiovfgVU/MM4o6hkl2NNYmtgzCM+dSWirj1/9nuJiLX5KSaYsAkr8sxTahLDHP0sxX77NHFPojzUcucE91iD04WdRz1b+3OcohkZUmU45u1E7DaStv7I5RyFMpAuEbBpEMh3EA2X6XMVCh+qXqTJ9rmK+j3mK+RfPjUHtgyrT9X45umTKdNQvkunzlT/3BYqL35SkAuNnCxTrMp0ycPMV86t2gWL+Bfwrm119fA4b6/68UHHxOzDqB1Y3u8AZfxN0oWL+uYsU0y/TT0zq9xSLMS0g+EmJabHC2+wuVuTJdHUhzSb4rLZXs5qV8uHo0i+oJcqf+1L1rn8JKjB+tlThy3T1JVCyij21U2U6ZV+wRDGfuZYqtJLxL2QufXwOG+v+vExx8Tvw6gdWMxdwxl/mWqaYf+5yhZe51O8pFmNaSvCTEtMKhZe5VijyZTql/FnphztZVyoufgdW/cA4o6gyFexpLE3slYTnriK01cevfk9xsRb/AsU5i4AS/2qFNiHs8a9W/vffGjXrw7/w3xpVD/DVu/1vJ2Zrd/vRg5uLqctp/63RNYqLy1ph6xS5it+T+bOl9YqFDtUvU8+q1O+4mexjg2L+udwY1D5ciTHo/XJ0ydj3q/21D0Xzb41Cfx/qd0y29bMb2Kj8uW9S7E8idtyeORDznPyzJfWFcPya/5d+tqQfMEc+bVTM65NNCkGUEn62ND+IzkP18VDOQzcrFjpUv0w9D92smO9ji+Lc7KjGoPbhSoxB75ejS+Z5KOoXnYduVf7ctykufvd+KjB+tk2xfh5KGbitivlVu00x/wL+lVMFfXwOG+v+vF1x8Tsw6gfGWURV4MAZfxN0u2L+uTsU0y/TT0zq9xSLMW0j+EmJaadifrLpY9qpyDsPVRfSRoLPans1q1kpH44u/YLapfy571bv+pegAuNnuxX+eaj6EihZxZ7aqeehmwh97FLMZ67dCq1k/AuZSx+fw8a6P+9RXPwOvPqB1cwFnPGXufYo5p+7V+FlLvV7isWYdhP8pMS0T+Flrn2K/PNQSvmz0g93su5XXPwOrPqBcUZRzwPBnsbSxN5PeO4BQlt9/Or3FBdr8VNKMmURUOI/qNAmhD3+g4q8ny0ZjzUcucE91iD04WdRH1L+3A8rhkZUmU45u1E7DaStv7J5WDH/3HmEny0FlUwH8UCZfkSx0KH6ZapMP6KY7+OoYv7Fc2NQ+6DKdL1fji6ZMh31i2T6MeXP/bji4jclqcD42XHFukynDNwxxfyqPa6YfwH/ymZXH5/Dxro/n1Bc/A6M+oHVzS5wxt8EPaGYf+5JxfTL9BOT+j3FYkzHCX5SYjql8Da7pxR5Ml1dSIcIPqvt1axmpXw4uvQL6rTy535GvetfggqMn51R+DJdfQmUrGJP7VSZTtkXnFbMZ64zCq1k/AuZSx+fw8a6P59VXPwOvPqB1cwFnPGXuc4q5p97TuFlLvV7isWYzhD8pMR0XuFlrvOKfJlOKX9W+uFO1guKi9+BVT8wziiqTAV7GksT+wLhuRcJbfXxq99TXKzFTynJlEVAif+SQpsQ9vgvKf/72ZJZH/6Fny2pB/jq3f63E4e0u/3owc3F1OW0ny1dVlxcrgi7qshV/F7Mny1dUyx0qH6ZelalfsfNZB/XFfPP5cag9uFIeRv70vvl6JKx71f76xCK5t9lhf4+1O+YbOtnN3BD+XO/qdifROy4A3MgVjj5Z0vqC+H4tfIv/WxJP2COfLqhmNcnNxXzPhDGwHVlEJ2H6uOhnIfeUix0qH6Zeh56SzHfx23FudlRjUHtw5UYg94vR5fM81DULzoPvaP8ud9VXPzu/VRg/OyuYv08lDJwdxTzq/auYv4F/CunCvr4HDbW/fme4uJ3YNQPjLOIqsCBM/4m6D3F/HPvK6Zfpp+Y1O8pFmO6S/CTEtMDxfxk08f0QJF3HqoupBsEn9X2alazUj4cXfoF9VD5c3+k3vUvQQXGzx4p/PNQ9SVQsoo9tVPPQ28S+niomM9cjxRayfgXMpc+PoeNdX9+rLj4HXj1A6uZCzjjL3M9Vsw/94nCy1zq9xSLMT0i+EmJ6anCy1xPFfnnoZTyZ6Uf7mR9prj4HVj1A+OMop4Hgj2NpYn9jPDc54S2+vjV7yku1uKnlGTKIqDE/0KhTQh7/C8UeT9bMh5rOHKDe6xB6MPPon6p/Lm/UgyNqDKdcnajdhpIW39l85Vi/rkrCD9bCiqZDuKBMv21YqFD9ctUmf5aMd/HG8X8i+fGoPbhSoxB75ejS6ZMR/0imf5W+XN/p7j4TUkqMH72TrEu0ykD91Yxv2rfKeZfwL+y2dXH57Cx7s/vFRe/A6N+YHWzC5zxN0HfK+af+0Ex/TL9xKR+T7EY0zuCn5SYPiq8ze5HRZ5MVxfSS4LPans1q1kpH44u/YL6pPy5f1bv+pegAuNnnxW+TFdfAiWr2FM7VaZT9gWfFPOZ67NCKxn/QubSx+ewse7PXxQXvwOvfmA1cwFn/GWuL4r5535VeJlL/Z5iMabPBD8pMX1TeJnrmyJfplPKn5V+uJP1u+Lid2DVD4wziipTwZ7G0sT+TnjuD0Jbffzq9xQXa/FTSjJlEVDi/6nQJoQ9/p/K/362ZNaHf+FnS+oBvnq3/+3ES+1uP3pwczF1Oe1nS78UF5ffwlxschW/wvzZkqvNQofql6lnVep33Ez2EcJm/rncGNQ+XIkxhDAfg5R9v9pfx1A0/9SJRn0f6ndMtvWzGwipTaJQ3MnUkTkQm5z8syX1hXD82vyXfrakHzBHPoW0mdcnoQiLlDAGrpuD6Dw0FIgdnYeG5k5otcPQNvp5aGjCiw/j5OyoxhDG8eT3F0MYi9nR1wHcr79jRtQvOg8Nqw1yOJuL372fChTDZ+Fs1s9DKQMXlrBqwxFewL9yqhCWMFn0HYU3DlZ4m/VTBeCMvwkanjCIEWymX6afmCLYrJ8qhCP4SYkpImGy6WOKaJN3HqoupJAEn9X2oWzWyoejS7+gImmZJbJxskYKILNEtvHPQ0Nqqdre3tGLsKd26nloKEIfkQiZKzKxZPwLmSsSM3NFMU6GKBIyVyRC5opCGMSozMwVVULmikzwkxJTNGbmimaTfx5KKX9W+uFO1ujGyRrdZv08NCwziwA/fZ01+9wYhLb6+GPYrJ+HUkoyZRFQ4o9JnBD2+GMSyreZY4qO5n9S5Mo91iD04WdRx7L9uce2GRpRZTrl7CYWoWzGJgz4JsLPloJKpoN4oEyPY7PQofplqkyPY371uMYlDBI3hrg2ukyPa6MNsiyZHpdQfvWrMZ42yPGNJSmezf9mOr7NukynDFw8wqqNT3gB/8pmNx6xXNivBMbBSmCzvtmNR9gTJCAMYkKb6ZfpJ6aENuub3fgEPykxJSJMNn1MiQh13sH1fxkwFsFntX1sm7Xy4ejSL6jEWmZJYpysiQPILElsfJkeS0vV9vaOXoQ9tVNlOmVfkJiQuZIQS8a/kLkSMzNXUuNkSCohcyUmZK6khEF0Y2YuNwmZKwnBT0pMyZiZK5lNvkynlD8r/XAna3LjZE1usy7T4zGzCPDT11mzz01BaKuPP4XNukynlGTKIqDEn5I4Iezxp7T972dLZn34F362FFJbr6G0eyztbj96cHMxdTntZ0uphB+phaWxyVX8NubPltLaLHSofpl6VpXW/EJ0TUdY4NwY0tkcK29jX+kIyUTGvl/tr1Momn+pbPT3kYoQl343kF6bRBm4k6kTcyD2OPlnS+oL4fi19y/9bCkVYYGkt5nXJxkIi5QwBq57g+g8NAOIHZ2HZuROaLXDjDb6eWhGwovP5OTsqMaQyfHk9xdDJovZ0dcB3K+/Y0bULzoPzawNchabi9+9X2ab/1OLLDbr56GUgctMWLVZCC/gXzlVyEyYLPqOshoHK6vN+qkCcMbfBM1KGMRsNtMv009M2WzWTxWyEPykxJSdMNn0MWW3yTsPVRdSeoLPavsMNmvlw9GlX1A5tMyS0zhZcwSQWXLa+Oeh6bVUbW/v6EXYUzv1PDQDoY8chMyVk1gy/oXMlYOZuXIZJ0MuCZkrByFz5SIMYm5m5sotIXPlJPhJiSkPM3Plsck/D6WUPyv9cCdrXuNkzWuzfh6amZlFgJ++zpp9bj5CW338+WzWz0MpJZmyCCjx5ydOCHv8+Qnl28wxRSfzPyly5R5rEPrws6gL2P7cC9oMjagynXJ2U4BQNgsSBnwP4WdLQSXTQTxQpheyWehQ/TJVphcyv3pcCxMGiRtDYRtdphe20QZZlkwvTCi/+tVYRBvkosaSVMTmfzNd1GZdplMGrghh1RYlvIB/ZbNbhFgu7Fcx42AVs1nf7BYh7AmKEQaxuM30y/QTU3Gb9c1uUYKflJhKECabPqYShDrv4Pq/DFiA4LPavqDNWvlwdOkXVEkts5QyTtaSAWSWUja+TC+gpWp7e0cvwp7aqTKdsi8oSchcpYgl41/IXCWZmau0cTKUlpC5ShIyV2nCIJZhZq4yEjJXKYKflJjKMjNXWZt8mU4pf1b64U7WcsbJWs5mXaYXYWYR4Kevs2afW57QVh9/eZt1mU4pyZRFQIm/AnFC2OOvYPvfz5bM+vAv/GwpvbZe7X87UUC7248e3FxMXU772VJF4UclYZVtchW/N/NnS1VsFjpUv0w9q6pifiG6ViUscG4MVW2Olbexr6qEZCJj36/21zkUzb+KNvr7qEiIS78bqKZNourcydSZORDHnPyzJfWFcPw6/pd+tlSRsECq2czrk+qERUoYA9fjQXQeWh3Ejs5Da3AntNphDRv9PLQG4cXXdHJ2VGOo6Xjy+4uhpsXs6OsA7tffMSPqF52H1tIGubbNxe/er5bN/6lFbZv181DKwNUirNrahBfwr5wq1CJMFn1HdYyDVcdm/VQBOONvgtYhDGJdm+mX6Semujbrpwq1CX5SYqpHmGz6mOrZ5J2HqgupGsFntX11m7Xy4ejSL6j6WmZpYJys9QPILA1s/PPQalqqtrd39CLsqZ16Hlqd0Ed9QuZqQCwZ/0Lmqs/MXA2Nk6GhhMxVn5C5GhIGsREzczWSkLkaEPykxNSYmbka2+Sfh1LKn5V+uJO1iXGyNrFZPw+txcwiwE9fZ80+tymhrT7+pjbr56GUkkxZBJT4mxEnhD3+ZoTybeaYorP5nxS5co81CH34WdTNbX/uLWyGRlSZTjm7aU4omy0IA36M8LOloJLpIB4o01vaLHSofpkq01uaXz2urQiDxI2hlY0u01vZaIMsS6a3IpRf/WpsrQ1yG2NJam3zv5luY7Mu0ykD15qwatsQXsC/stltTSwX9qutcbDa2qxvdlsT9gRtCYPYzmb6ZfqJqZ3N+ma3DcFPSkztCZNNH1N7Qp13cP1fBmxO8Flt38JmrXw4uvQLqoOWWToaJ2uHADJLRxtfpjfXUrW9vaMXYU/tVJlO2Rd0IGSujsSS8S9krg7MzNXJOBk6SchcHQiZqxNhEDszM1dnCZmrI8FPSkxdmJmri02+TKeUPyv9cCdrV+Nk7WqzLtNbM7MI8NPXWbPP7UZoq4+/m826TKeUZMoioMTfnTgh7PF3t/3vZ0tmffgXfrZUTVuv9r+daK7d7UcPbi6mLqf9bKmH8KOnsF42uYrfh/mzpd42Cx2qX6aeVfU2vxBd+xAWODeGPjbHytvYVx9CMpGx71f76xKK5l8PG/199CDEpd8N9NUmUT/uZOrCHIgLTv7ZkvpCOH5d/Es/W+pBWCB9beb1ST/CIiWMgevFIDoP7QdiR+eh/bkTWu2wv41+Htqf8OIHODk7qjEMcDz5/cUwwGJ29HUA9+vvmBH1i85D3bVB9rC5+N37udv8n1p42Kyfh1IGzp2waj0IL+BfOVVwJ0wWfUeexsHytFk/VQDO+JugnoRB9LKZfpl+YvKyWT9V8CD4SYlJIUw2fUyKTd55qLqQ+hJ8Vtv3s1krH44u/YKyaZnF2zhZbQFkFm8b/zy0r5aq7e0dvQh7aqeeh/Yj9GEjZC5vYsn4FzKXjZm5fIyTwUdC5rIRMpcPYRAHMjPXQAmZy5vgJyWmQczMNcgm/zyUUv6s9MOdrIONk3Wwzfp5qDsziwA/fZ01+9whhLb6+IfYrJ+HUkoyZRFQ4h9KnBD2+IcSyreZY4ou5n9S5Mo91iD04WdRD7P9uQ+3GRpRZTrl7GYYoWwOJwz4BcLPloJKpoN4oEwfYbPQofplqkwfYX71uI4kDBI3hpE2ukwfaaMNsiyZPpJQfvWrcZQ2yKONJWmUzf9merTNukynDNwowqodTXgB/8pmdxSxXNivMcbBGmOzvtkdRdgTjCEM4lib6ZfpJ6axNuub3dEEPykxjSNMNn1M4wh13sH1fxlwGMFntf1wm7Xy4ejSL6jxWmaZYJys4wPILBNsfJk+TEvV9vaOXoQ9tVNlOmVfMJ6QuSYQS8a/kLnGMzPXRONkmCghc40nZK6JhEGcxMxckyRkrgkEPykxTWZmrsk2+TKdUv6s9MOdrFOMk3WKzbpMH8XMIsBPX2fNPncqoa0+/qk26zKdUpIpi4AS/zTihLDHP832v58tmfXhX/jZUl9tvdr/dmKYdrcfPbi5mLqc9rOl6cKP/4TNsMlV/AOZP1uaabPQofpl6lnVTPML0XUWYYFzY5hlc6y8jX3NIiQTGft+tb+uoWj+TbfR38d0Qlz63cBsbRLN4U6mrsyBuOXkny2pL4Tj1+2/9LOl6YQFMttmXp/MISxSwhi43g6i89A5IHZ0HjqXO6HVDufa6Oehcwkvfp6Ts6MawzzHk99fDPMsZkdfB3C//o4ZUb/oPHS+NsgLbC5+937zbf5PLRbYrJ+HUgZuPmHVLiC8gH/lVGE+YbLoO1poHKyFNuunCsAZfxN0IWEQF9lMv0w/MS2yWT9VWEDwkxLTYsJk08e02CbvPFRdSLMJPqvt59islQ9Hl35BLdEyy1LjZF0SQGZZauOfh87WUrW9vaMXYU/t1PPQOYQ+lhAy11JiyfgXMtcSZuZaZpwMyyRkriWEzLWMMIjLmZlruYTMtZTgJyWmFczMtcIm/zyUUv6s9MOdrCuNk3Wlzfp56HxmFgF++jpr9rmrCG318a+yWT8PpZRkyiKgxL+aOCHs8a8mlG8zxxRdzf+kyJV7rEHow8+iXmP7c19rMzSiynTK2c0aQtlcSxjwW4SfLQWVTAfxQJm+zmahQ/XLVJm+zvzqcV1PGCRuDOttdJm+3kYbZFkyfT2h/OpX4wZtkDcaS9IGm//N9EabdZlOGbgNhFW7kfAC/pXN7gZiubBfm4yDtclmfbO7gbAn2EQYxM020y/TT0ybbdY3uxsJflJi2kKYbPqYthDqvIPr/zLgGoLPavu1Nmvlw9GlX1BbtcyyzThZtwaQWbbZ+DJ9jZaq7e0dvQh7aqfKdMq+YCshc20jlox/IXNtZWau7cbJsF1C5tpKyFzbCYO4g5m5dkjIXNsIflJi2snMXDtt8mU6pfxZ6Yc7WXcZJ+sum3WZvoGZRYCfvs6afe5uQlt9/Ltt1mU6pSRTFgEl/j3ECWGPf4/tfz9bMuvDv/CzpdnaerX/7cQa7W4/enBzMXU57WdLe4Uf+4Ttt8lV/IOYP1s6YLPQofpl6lnVAfML0fUgYYFzYzhoc6y8jX0dJCQTGft+tb9uoWj+7bXR38deQlz63cAhbRId5k6mbsyBeOLkny2pL4Tj19O/9LOlvYQFcshmXp8cJixSwhi4Pg2i89DDIHZ0HnqEO6HVDo/Y6OehRwgv/qiTs6Maw1HHk99fDEctZkdfB3C//o4ZUb/oPPSYNsjHbS5+937HbP5PLY7brJ+HUgbuGGHVHie8gH/lVOEYYbLoOzphHKwTNuunCsAZfxP0BGEQT9pMv0w/MZ20WT9VOE7wkxLTKcJk08d0yibvPFRdSIcIPqvtD9uslQ9Hl35BndYyyxnjZD0dQGY5Y+Ofhx7SUrW9vaMXYU/t1PPQw4Q+ThMy1xliyfgXMtdpZuY6a5wMZyVkrtOEzHWWMIjnmJnrnITMdYbgJyWm88zMdd4m/zyUUv6s9MOdrBeMk/WCzfp56DFmFgF++jpr9rkXCW318V+0WT8PpZRkyiKgxH+JOCHs8V8ilG8zxxTdzP+kyJV7rEHow8+ivmz7c79iMzSiynTK2c1lQtm8QhjwJ4SfLQWVTAfxQJl+1WahQ/XLVJl+1fzqcb1GGCRuDNdsdJl+zUYbZFky/Rqh/OpX43VtkG8YS9J1m//N9A2bdZlOGbjrhFV7g/AC/pXN7nViubBfN42DddNmfbN7nbAnuEkYxFs20y/TT0y3bNY3uzcIflJiuk2YbPqYbhPqvIPr/zLgZYLPavsrNmvlw9GlX1B3tMxy1zhZ7wSQWe7a+DL9spaq7e0dvQh7aqfKdMq+4A4hc90llox/IXPdYWaue8bJcE9C5rpDyFz3CIN4n5m57kvIXHcJflJiesDMXA9s8mU6pfxZ6Yc7WR8aJ+tDm3WZfp2ZRYCfvs6afe4jQlt9/I9s1mU6pSRTFgEl/sfECWGP/7Htfz9bMuvDv/CzpUPaerX/7cRl7W4/enBzMXU57WdLT4QfT4U9s8lV/IOZP1t6brPQofpl6lnVc/ML0fUFYYFzY3hhc6y8jX29ICQTGft+tb/uoWj+PbHR38cTQlz63cBLbRK94k6m7syBeOfkny2pL4Tj1/u/9LOlJ4QF8tJmXp+8IixSwhi4vg+i89BXIHZ0HvqaO6HVDl/b6Oehrwkv/o2Ts6MawxvHk99fDG8sZkdfB3C//o4ZUb/oPPStNsjvbC5+935vbf5PLd7ZrJ+HUgbuLWHVviO8gH/lVOEtYbLoO3pvHKz3NuunCsAZfxP0PWEQP9hMv0w/MX2wWT9VeEfwkxLTR8Jk08f00SbvPFRdSC8JPqvtX9mslQ9Hl35BfdIyy2fjZP0UQGb5bOOfh77UUrW9vaMXYU/t1PPQV4Q+PhEy12diyfgXMtcnZub6YpwMXyRkrk+EzPWFMIhfmZnrq4TM9ZngJyWmb8zM9c0m/zyUUv6s9MOdrN+Nk/W7zfp56FtmFgF++jpr9rk/CG318f+wWT8PpZRkyiKgxP+TOCHs8f8klG8zxxTdzf+kyJV7rEHow8+i/mX7c/9tMzSiynTK2c0vQtn8TRjwd4SfLQWVTAfxQJnu4m2hQ/XLVJmufsfNZB+u3uZfPDcGtQ9XYgyu3rRBliXTUb9IpofQBjmkt4vflKQCxfBZSG/rMp0ycCG8za/akIQX8K9sdkMQJou+o1DGwQrlbX2zC5zxN0FDEQYxtLfpl+knptDe1je7IQl+UmIKQ5hs+pjCeMuT6epC+kXZb3n/qblWyoejS7+gwmqZJZxxsoYNILOE8+bL9F9aqra3d/Qi7KmdKtMp+4KwhMwVjlgy/oXMFZaZucIbJ0N4CZkrLCFzhSdMlAjMzBVBQuYKR/CTElNEZuaK6C1fplPKn5V+uJM1knGyRvK2LtNDeDtnYkciPDcyoa0+/sje1mU6pSRTFgEl/ijECWGPP4r3/362ZNaHf+FnSy+17Y79byd+aXf70YObi6krBKEt5bmuUcV8iiYsurdcxT+E+bOlGFzFr3YYw5t+VhWDoPhjOlnxqzHEdKz4/fUV06Lip2531f56hKL5F9Wb/j6iEuLS7wZiaZMoNncy9WAOxA8n/2xJfSEcv37+pZ8tRSUskFgEfRKbsEgJY+D6M4jOQ2OD2NF5aBzuhFY7jMM4D41DePFxnZwd1RjiMs5D41rMjr4O4H79HTPGZZ6HxtMGOb5x7x8vgFOL+N7Wz0MpAxePsGrjB8Pz0HhMoZbAOFgJJJwqxCOIrwSEQUzIPFVIKOFUIT7BT0pMiZinCokknoeqCykWwWe1fWxva+XD0aVfUIm1zJLEOFkTB5BZklg4D42lpWp7e0cvwp7aqeehsQl9JCZkriTB8Dw0MTNzJTVOhqQSMldiQuZKShhEN2bmcpOQuZIQ/KTElIyZuZI54TyUUv6s9MOdrMmNkzW5hPPQeMwsAvz0ddbsc1Mwz0NTSDgPpZRkyiKgxJ+SeR6aklC+zRxT9DD/kyJX7rEGoQ8/izqVVr5TexsaUWU65ewmFaFspiYM+A/Cz5aCSqanZsr0NFyZrnaYhiHT0xBkelrCIHFjSMuQ6WmDSKanZcr0dNogpzeWpHQBbKbTS5DplIFLR1i16YOhTE/H3D9kMA5WBgmb3XSEPUEGwiBmZG52M0rY7KYn+EmJKRNzs5tJokxXF1Iqgs9q+9Te1sqHo0u/oDJrmSWLcbJmDiCzZLEg01Npqdre3tGLsKd2qkyn7AsyEzJXlmAo0zMzM1dW42TIKiFzZSZkrqyEQczGzFzZJGSuLAQ/KTFlZ2au7E6Q6ZTyZ6Uf7mTNYZysOSTI9HTMLAL89HXW7HNzMmV6TgkynVKSKYuAEn8upkzP5f2/ny2Z9eFf+NlSLG292v92IpV2tx89uLmYukIQ2lKe65pb+JFHWF5vuYp/KPNnS/m8LXSYz5t+VpWPoPjzO1nxqzHkd6z4/fWV36Lip2531f56hqL5l5ux78/N3PcX0CZRQe5k6skciDAXaauU+nz1hXD8Ckv0y35Rz0NzExZIAYI+KUhYpIQxcKW8F5nZsSDzPLQQd0KrHRZinIcWIrz4wk7OjmoMhRnnoYUtZkdfB3C//o4ZCzPPQ4tog1zUuPcvEsCpRVFv6+ehlIErQli1RYPheWgRplArZhysYhJOFYoQxFcxwiAWZ54qFJdwqlCU4CclphLMU4USEs9D1YVUgOCz2r6gt7Xy4ejSL6iSWmYpZZysJQPILKUsnIcW0FK1vb2jF2FP7dTz0IKEPkoSMlepYHgeWpKZuUobJ0NpCZmrJCFzlSYMYhlm5iojIXOVIvhJiaksM3OVdcJ5KKX8WemHO1nLGSdrOQnnoUWYWQT46eus2eeWZ56HlpdwHkopyZRFQIm/AvM8tAKhfJs5puhp/idFrtxjDUIffhZ1Ra18V/I2NKLKdMrZTUVC2axEGHC9TJd5fCFTpldiyvTKXJmudliZIdMrE2R6FcIgcWOowpDpVYJIpldhyvSq2iBXM5akqgFspqtJkOmUgatKWLXVgqFMr8rcP1Q3DlZ1CZvdqoQ9QXXCINZgbnZrSNjsViP4SYmpJnOzW1OiTFcXUkWCz2r7St7WyoejS7+gammZpbZxstYKILPUtiDTK2qp2t7e0Yuwp3aqTKfsC2oRMlftYCjTazEzVx3jZKgjIXPVImSuOoRBrMvMXHUlZK7aBD8pMdVjZq56TpDplPJnpR/uZK1vnKz1Jcj0qswsAvz0ddbscxswZXoDCTKdUpIpi4ASf0OmTG/o/b+fLZn14V/42VIBbb3a/3aiona3Hz24uZi6QhDaUp7r2kj40VhYE2+5in8Y82dLTb0tdNjUm35W1ZSg+Js5WfGrMTRzrPj99dXMouKnbnfV/nqFovnXiLHvb8Tc9zfXJlEL7mTqxRyIaE7+2ZL6Qjh+Rf9LP1tqRFggzQn6pAVhkRLGwDV6EJ2HtmCeh7bkTmi1w5aM89CWhBffysnZUY2hFeM8tJXF7OjrAO7X3zFjK+Z5aGttkNsY9/6tAzi1aONt/TyUMnCtCau2TTA8D23NFGptjYPVVsKpQmuC+GpLGMR2zFOFdhJOFdoQ/KTE1J55qtBe4nmoupCaE3xW27fwtlY+HF36BdVByywdjZO1QwCZpaOF89DmWqq2t3f0IuypnXoe2oLQRwdC5uoYDM9DOzAzVyfjZOgkIXN1IGSuToRB7MzMXJ0lZK6OBD8pMXVhZq4uTjgPpZQ/K/1wJ2tX42TtKuE8tDUziwA/fZ01+9xuzPPQbhLOQyklmbIIKPF3Z56HdieUbzPHFL3M/6TIlXusQejDz6LuoZXvnt6GRlSZTjm76UEomz0JAx6N8LOloJLpPZkyvRdXpqsd9mLI9F4Emd6bMEjcGHozZHrvIJLpvZkyvY82yH2NJalPAJvpvhJkOmXg+hBWbd9gKNP7MPcP/YyD1U/CZrcPYU/QjzCI/Zmb3f4SNrt9CX5SYhrA3OwOkCjT1YXUg+Cz2r6nt7Xy4ejSLyh3LbN4GCerewCZxcOCTO+hpWp7e0cvwp7aqTKdsi9wJ2Quj2Ao092ZmcvTOBk8JWQud0Lm8iQMohczc3lJyFweBD8pMSnMzKU4QaZTyp+VfriT1WacrDYJMr0PM4sAP32dNftcb6ZM95Yg0yklmbIIKPH7MGW6j/f/frZk1od/4WdLzbX1av/biR7a3X704OZi6gpBaEt5rutA4ccgYYO95Sr+4cyfLQ3xttDhEG/6WdUQguIf6mTFr8Yw1LHi99fXUIuKn7rdVfvrHYrm30DGvn8gc98/TJtEw7mTqTdzIBI4+WdL6gvh+JXwL/1saSBhgQwj6JPhhEVKGAPXhEF0HjqceR46gp0dvf982UF29Nf5CMKLH+ns7CieP5JxHjrSYnb0dQD36++YcSTzPHSUNsijjXv/UQGcWoz2tn4eShm4UYRVOzoYnoeOYgq1McbBGiPhVGEUQXyNIQziWOapwlgJpwqjCX5SYhrHPFUYJ/E8VF1Iwwg+q+2He1srH44u/YIar2WWCcbJOj6AzDLBwnnoMC1V29s7ehH21E49Dx1O6GM8IXNNCIbnoeOZmWuicTJMlJC5xhMy10TCIE5iZq5JEjLXBIKflJgmMzPXZCech1LKn5V+uJN1inGyTpFwHjqKmUWAn77Omn3uVOZ56FQJ56GUkkxZBJT4pzHPQ6cRyreZY4re5n9S5Mo91iD04WdRT9fK93/ehkZUmU45u5lOKJv/EQY8AeFnS0El0/9jyvQZXJmudjiDIdNnEGT6TMIgcWOYyZDpM4NIps9kyvRZ2iDPNpakWQFspmdLkOmUgZtFWLWzg6FMn8XcP8wxDtYcCZvdWYQ9wRzCIM5lbnbnStjszib4SYlpHnOzO0+iTFcX0nSCz2r7/7ytlQ9Hl35BzdcyywLjZJ0fQGZZYEGmT9dStb29oxdhT+1UmU7ZF8wnZK4FwVCmz2dmroXGybBQQuaaT8hcCwmDuIiZuRZJyFwLCH5SYlrMzFyLnSDTKeXPSj/cybrEOFmXSJDps5hZBPjp66zZ5y5lyvSlEmQ6pSRTFgEl/mVMmb7M+38/WzLrw7/ws6Vh2nq1/+3EdO1uP3pwczF1hSC0pTzXdbnwY4Wwld5yFf8I5s+WVnlb6HCVN/2sahVB8a92suJXY1jtWPH762u1RcVP3e6q/fUJRfNvOWPfv5y571+jTaK13MnUhzkQKZ38syX1hXD8SvWXfra0nLBA1hD0yVrCIiWMgWuqIDoPXcs8D13HndBqh+sY56HrCC9+vZOzoxrDesZ56HqL2dHXAdyvv2PG9czz0A3aIG807v03BHBqsdHb+nkoZeA2EFbtxmB4HrqBKdQ2GQdrk4RThQ0E8bWJMIibmacKmyWcKmwk+EmJaQvzVGGLxPNQdSGtIfistl/rba18OLr0C2qrllm2GSfr1gAyyzYL56FrtFRtb+/oRdhTO/U8dC2hj62EzLUtGJ6HbmVmru3GybBdQubaSshc2wmDuIOZuXZIyFzbCH5SYtrJzFw7nXAeSil/VvrhTtZdxsm6S8J56AZmFgF++jpr9rm7meehuyWch1JKMmURUOLfwzwP3UMo32aOKfqY/0mRK/dYg9CHn0W9Vyvf+7wNjagynXJ2s5dQNvcRBjwl4WdLQSXT9zFl+n6uTFc73M+Q6fsJMv0AYZC4MRxgyPQDQSTTDzBl+kFtkA8ZS9LBADbThyTIdMrAHSSs2kPBUKYfZO4fDhsH67CEze5Bwp7gMGEQjzA3u0ckbHYPEfykxHSUudk9KlGmqwtpL8Fntf0+b2vlw9GlX1DHtMxy3DhZjwWQWY5bkOl7tVRtb+/oRdhTO1WmU/YFxwiZ63gwlOnHmJnrhHEynJCQuY4RMtcJwiCeZGaukxIy13GCn5SYTjEz1yknyHRK+bPSD3eynjZO1tMSZPpBZhYBfvo6a/a5Z5gy/YwEmU4pyZRFQIn/LFOmn/X+38+WzPrwL/xsaY22Xu1/O7FXu9uPHtxcTF0hCG0pz3U9J/w4L+yCt1zFP5L5s6WL3hY6vOhNP6u6SFD8l5ys+NUYLjlW/P76umRR8VO3u2p/fUPR/DvH2PefY+77L2uT6Ap3MvVlDkRmJ/9sSX0hHL+y/KWfLZ0jLJDLBH1yhbBICWPgmiWIzkOvMM9Dr3IntNrhVcZ56FXCi7/m5OyoxnCNcR56zWJ29HUA9+vvmPEa8zz0ujbIN4x7/+sBnFrc8LZ+HkoZuOuEVXsjGJ6HXmcKtZvGwbop4VThOkF83SQM4i3mqcItCacKNwh+UmK6zTxVuC3xPFRdSJcJPqvtr3hbKx+OLv2CuqNllrvGyXongMxy18J56GUtVdvbO3oR9tROPQ+9QujjDiFz3Q2G56F3mJnrnnEy3JOQue4QMtc9wiDeZ2au+xIy112Cn5SYHjAz1wMnnIdSyp+VfriT9aFxsj6UcB56nZlFgJ++zpp97iPmeegjCeehlJJMWQSU+B8zz0MfE8q3mWOKvuZ/UuTKPdYg9OFnUT/RyvdTb0MjqkynnN08IZTNp4QBz0z42VJQyfSnTJn+jCvT1Q6fMWT6M4JMf04YJG4Mzxky/XkQyfTnTJn+Qhvkl8aS9CKAzfRLCTKdMnAvCKv2ZTCU6S+Y+4dXxsF6JWGz+4KwJ3hFGMTXzM3uawmb3ZcEPykxvWFudt9IlOnqQnpC8Flt/9TbWvlwdOkX1Fsts7wzTta3AWSWdxZk+hMtVdvbO3oR9tROlemUfcFbQuZ6Fwxl+ltm5npvnAzvJWSut4TM9Z4wiB+YmeuDhMz1juAnJaaPzMz10QkynVL+rPTDnayfjJP1kwSZ/oKZRYCfvs6afe5npkz/LEGmU0oyZRFQ4v/ClOlfvP/3syWzPvwLP1u6rK1X+99OPNHu9qMHNxdTVwhCW8pzXb8KP74J++4tV/GPYv5s6Ye3hQ5/eNPPqn4QFP9PJyt+NYafjhW/v75+WlT81O2u2l+/UDT/vjL2/V+Z+/5f2iT6zZ1M/ZgDkdfJP1tSXwjHr3x/6WdLXwkL5BdBn/wmLFLCGLjmC6Lz0N/M81AXHwsdql+mnoeq33Ez2Yerj3OzoxqD2ocrMQZXH9ogyzoPRf2i89AQ2iCH9HHxu/dTgWL4LKSP9fNQysCF8DG/akMSXsC/cqoQgjBZ9B2FMg5WKB/rpwrAGX8TNBRhEEP7mH6ZfmIK7WP9VCEkwU9KTGEIk00fUxgfeeeh6kL6RRG2Pn/2KFbKh6NLv6DCapklnHGyhg0gs4Tz4Z+H/tJStb29oxdhT+3U89DfhJcdlpC5whFLxr+QucIyM1d442QILyFzhSVkrvCEiRKBmbkiSMhc4Qh+UmKKyMxcEX3kn4dSyp+VfriTNZJxskbysX4eGsLHORM7EuG5kQlt9fFH9rF+HkopyZRFQIk/CnFC2OOPQijfZo4p+pn/SZEr91iD0IefRR1VK9/RfAyNqDKdcnYTlVA2oxEGPC/hZ0tBJdNBPFCmR+fKdLXD6AyZHp0g02MQBokbQwyGTI8RRDI9BlOmx9QGOZaxJMUMYDMdS4JMpwxcTMKqjRUMZXpM5v4htnGwYkvY7MYk7AliEwYxDnOzG0fCZjcWwU9KTHGZm924EmW6upCiEnxW20fzsVY+HF36BRVPyyzxjZM1XgCZJb4FmR5VS9X29o5ehD21hyT2Q9kXxCNkrvjBUKbHY2auBMbJkEBC5opHyFwJCIOYkJm5EkrIXPEJflJiSsTMXImcINMp5c9KP9zJmtg4WRNLkOkxmVkE+OnrrNnnJmHK9CQSZDqlJFMWASX+pEyZntTnfz9bMuvDv/CzpV/asYb9byeiauvXfvTg5mLqCkFoS3muq5vwI5mw5D5yFf9o5s+WUvhY6DCFD/2sKgVB8ackLHBuDCkdK35/faW0qPip2121v/6hiP4x9v1uzH1/Km0SpeZOpv7MgSju5J8tqS+E41eJv/SzJTfCAklF0CepCYuUMAauJYLoPDQ18zw0DXdCqx2mYZyHpiG8+LROzo5qDGkZ56FpLWZHXwdwv/6OGdMyz0PTaYOc3rj3TxfAqUV6H+vnoZSBS0dYtemD4XloOqZQy2AcrAwSThXSEcRXBsIgZmSeKmSUcKqQnuAnJaZMzFOFTBLPQ9WFlIrgs9o+tY+18uHo0i+ozFpmyWKcrJkDyCxZfPjnoam0VG1v7+hF2FN7SGI/qQl9ZCZkrizB8Dw0MzNzZTVOhqwSMldmQubKShjEbMzMlU1C5spC8JMSU3Zm5sruhPNQSvmz0g93suYwTtYcEs5D0zGzCPDT11mzz83JPA/NKeE8lFKSKYuAEn8u5nloLkL5NnNM0d/8T4pcuccahD78LOrcWvnO42NoRJXplLOb3ISymYcw4MUJP1sKKpmehynT83JlutphXoZMz0uQ6fkIg8SNIR9DpucLIpmejynT82uDXMBYkvIHsJku4GNdplMGLj9h1RYIhjI9P3P/UNA4WAUlbHbzE/YEBQmDWIi52S0kYbNbgOAnJabCzM1uYYkyXV1IuQk+q+3z+FgrH44u/YIqomWWosbJWiSAzFLUgkzPraVqe3tHL8Ke2kMS+6HsC4oQMlfRYCjTizAzVzHjZCgmIXMVIWSuYpTNHTNzFZeQuYoS/KTEVIKZuUo4QaZTyp+VfriTtaRxspaUINPzM7MI8NPXWbPPLcWU6aUkyHRKSaYsAkr8pZkyvbTP/362ZNaHf+FnS6m09Wr/24nc2t1+9ODmYupy2s+Wygg/ygor5yNX8Y9h/mypvI+FDsv70M+qyhMUfwXCAufGUMGx4vfXVwWLip+63VX7GxCK5l8Zxr6/DHPfX1GbRJW4k2kAcyAqOvlnS+oL4fhV6S/9bKkMYYFUJOiTSoRFShgD10pBdB5aiXkeWpk7odUOKzPOQysTXnwVJ2dHNYYqjPPQKhazo68DuF9/x4xVmOehVbVBrmbc+1cN4NSimo/181DKwFUlrNpqwfA8tCpTqFU3DlZ1CacKVQniqzphEGswTxVqSDhVqEbwkxJTTeapQk2J56HqQqpI8FltX8nHWvlwdOkXVC0ts9Q2TtZaAWSW2j7889CKWqq2t3e4P9HahyT2U4nQRy1C5qodDM9DazEzVx3jZKgjIXPVImSuOoRBrMvMXHUlZK7aBD8pMdVjZq56TjgPpZQ/K/1wJ2t942StL+E8tCoziwA/fZ01+9wGzPPQBhLOQyklmbIIKPE3ZJ6HNiSUbzPHFAPM/6TIlXusQejDz6JupJXvxj6GRlSZTjm7aUQom40p8p/ws6WgkumNmTK9CVemqx02Ycj0JgSZ3pQwSNwYmjJketMgkulNmTK9mTbIzY0lqVkAm+nmPtZlOmXgmhFWbfNgKNObMfcPLYyD1ULCZrcZYU/QgjCILZmb3ZYSNrvNCX5SYmrF3Oy2kijT1YXUiOCz2r6xj7Xy4ejSL6jWWmZpY5ysrQPILG0syPRGWqq2t3f0IuypPSSxH8q+oDUhc7UJhjK9NTNztTVOhrYSMldrQuZqSxjEdszM1U5C5mpD8JMSU3tm5mrvBJlOKX9W+uFO1g7GydpBgkxvxswiwE9fZ80+tyNTpneUINMpJZmyCCjxd2LK9E4+//vZklkf/oWfLVXU1qv9bycaaXf70YObi6nLaT9b6iz86CKsq49cxT+W+bOlbj4WOuzmQz+r6kZQ/N0JC5wbQ3fHit9fX90tKn7qdlftzz0Uzb/OjH1/Z+a+v4c2iXpyJ5M7cyBqO/lnS+oL4fhV5y/9bKkzYYH0IOiTnoRFShgD1zpBdB7ak3ke2os7odUOezHOQ3sRXnxvJ2dHNYbejPPQ3hazo68DuF9/x4y9meehfbRB7mvc+/cJ4NSir4/181DKwPUhrNq+wfA8tA9TqPUzDlY/CacKfQjiqx9hEPszTxX6SzhV6EvwkxLTAOapwgCJ56HqQupB8Flt39PHWvlwdOkXlLuWWTyMk9U9gMzi4cM/D+2hpWp7e0cvwp7aQxL76Unow52QuTyC4XmoOzNzeRong6eEzOVOyFyehEH0YmYuLwmZy4PgJyUmhZm5FCech1LKn5V+uJPVZpysNgnnoX2YWQT46eus2ed6M89DvSWch1JKMmURUOL3YZ6H+hDKt5ljCnfzPyly5R5rEPrws6gHauV7kI+hEVWmU85uBhLK5iDCgNcm/GwpqGT6IKZMH8yV6WqHgxkyfTBBpg8hDBI3hiEMmT4kiGT6EKZMH6oN8jBjSRoawGZ6mI91mU4ZuKGEVTssGMr0ocz9w3DjYA2XsNkdStgTDCcM4gjmZneEhM3uMIKflJhGMje7IyXKdHUhDST4rLYf5GOtfDi69AtqlJZZRhsn66gAMstoCzJ9oJaq7e0dvQh7ag9J7IeyLxhFyFyjg6FMH8XMXGOMk2GMhMw1ipC5xhAGcSwzc42VkLlGE/ykxDSOmbnGOUGmU8qflX64k3W8cbKOlyDThzKzCPDT11mzz53AlOkTJMh0SkmmLAJK/BOZMn2iz/9+tmTWh3/hZ0s9tPVq/9uJgdrdfvTg5mLqctrPliYJPyYLm+ITQIcu5ufzwlC0Pk22hT456mcR4XSmhiLHJ4fFj/CeFhOOtyaE0n1R80vNGerH6qmWOifDuvz/nBHB5c/pTiRhkYVFERZVWDRh0YXFEBZTWCxhsYXFERZXWDxh8YUlEJZQWCJhiYUlEZZUew/JhCUXlkJYSmGphKmLOI2wtMLSCUsvLIOwjMIyCcssLIuwrMKyCcsuLIewnMJyCcstLI+wvMLyCcsvrICwgsIKCSssrIiwosKKCSsurISwksJKCSstrIywssLKCSsvrIKwisIqCassrIqwqsKqCasurIawmsJqCastrI6wusLqCVOTaANhDYWpSbKxsCbCmgprJqy5sBbCWgprJay1sDbC2gprJ6y9sA7COgrrJKyzsC7CugrrJqy7sB7CegrrJay3sD7C+grrJ6y/sAHC3IV5CPMU5uXypzbYhHkLU5f0QGGDhA0WNkTYUGHDhA0XNkLYSGGjhI0WNkbYWGHjhI0XNkHYRGGThE0WNkXYVGHThE0X9p+wGcJmCpslbLawOcLmCpsnbL6wBcIWClskbLGwJcKWClsmbLmwFcJWClslbLWwNcLWClsnbL2wDcI2CtskbLOwLcK2CtsmbLuwHcJ2CtslbLewPcL2CtsnbL+wA8IOCjsk7LCwI8KOCjsm7LiwE8LUQnBK2GlhZ4SdFXZO2HlhF4SJQ1OXS8IuC7si7Kqwa8KuC7sh7KawW8JuC7sj7K6we8LuC3sg7KGwR8IeC3si7KmwZ8KeC3sh7KWwV8JeC1NzxFth74S9F/ZB2Edhn4R9FvZF2Fdh34R9F/ZD2E9hv4T9FqYufldhIYSFFBZKWGhhYYSFFRZOWHhhEYRFFBZJWGRhUYRFFRZNWHRhMYTFFBZLWGxhcYTFFRZPWHxhCYQlFJZIWGJhSYQlFeYmLJmw5MJSCEspLJWw1MLSCEsrLJ2w9MIyCMsoLJOwzMKyCMsqLJuw7MJyCMspLJew3MLyCMsrLJ+w/MIKCCsorJCwwsKKCCsqrJiw4sJKCCsprJSw0sLKCCsrrJyw8sIqCKsorJKwysKqCKsqrJqw6sJqCKsprJaw2sLqCKsrrJ6w+sIaCGsoTFUpjYU1EdZUWDNhzYW1ENZSWCthrYW1EdZWWDth7YV1ENZRWCdhnYV1EdZVWDdh3YX1ENZTWC9hvYX1EdZXWD9h/YUNEOYuzEOYpzAvYYowmzBvYT7CBgobJGywsCHChgobJmy4sBHCRgobJWy0sDHCxgobJ2y8sAnCJgqbJGyysCnCpgqbJmy6sP+EzRA2U9gsYbOFzRE2V9g8YfOFqcf5C4UtErZY2BJhS4UtE7Zc2AphK4WtErZa2Bpha4WtE7Ze2AZhG4VtErZZ2BZhW4VtE7Zd2A5hO4XtErZb2B5he4XtE7Zf2AFhB4UdEnZY2BFhR4UdE3Zc2AlhJ4WdEnZa2BlhZ4WdE3Ze2AVhF4VdEnZZ2BVhV4VdE3Zd2A1hN4XdEnZb2B1hd4XdE3Zf2ANhD4U9EvZY2BNhT4U9E/Zc2AthL4W9EvZa2Bthb4W9E/Ze2AdhH4V9EvZZ2BdhX4V9E/Zd2A9hP4X9EvZbmFr4XYWFEBZSWChhoYWFERZWWDhh4YVFEBZRWCRhkYVFERZVWDRh0YXFEBZTWCxhsYXFERZXWDxh8YUlEJZQWCJhiYUlEZZUmJuwZMKSC0shLKWwVMJSC0sjLK2wdMLSC8sgLKOwTMIyC8siLKuwbMKyC8shLKewXMJyC8sjLK+wfMLyCysgrKCwQsIKCysirKiwYsKKCyshrKSwUsJKCysjrKywcsLKC6sgrKKwSsIqC6sirKqwasKqC6shrKawWsJqC6sjrK6wesLqC2sgrKEw9W8zGgtrIqypsGbCmgtrIaylsFbCWgtrI6ytsHbC2gvrIKyjsE7COgvrIqyrsG7CugvrIaynsF7CegvrI6yvsH7C+gsbIMxdmIcwT2FewhRhNmHewnyEDRQ2SNhgYUOEDRU2TNhwYSOEjRQ2SthoYWOEjRU2Tth4YROETRQ2SdhkYVOETRU2Tdh0Yf8JmyFsprBZwmYLmyNsrrB5wuYLWyBsobBFwhYLWyJsqbBlwpYLWyFspbBVwlYLWyNsrbB1wtYL2yBso7BNwjYL2yJsq7BtwraHEOtf2E5hu4TtFrZH2F5h+4TtF3ZA2EFhh4QdFnZE2FFhx4QdF3ZC2Elhp4SdFnZG2Flh54SdF3ZB2EVhl4RdFnZF2FVh14RdF3ZD2E1ht4TdFnZH2F1h94TdF6Yq3YfCHgl7LOyJsKfCngl7LuyFsJfCXgl7LeyNsLfC3gl7L+yDsI/CPgn7LOyLsK/Cvgn7LuyHsJ/Cfgn7LUzd9LsKCyEspLBQwkILCyMsrLBwwsILiyAsorBIwiILiyIsqrBowqILiyEsprBYwmILiyMsrrB4wuILSyAsobBEwhILSyIsqTA3YcmEJReWQlhKYamEpRaWRlhaYemEpReWQVhGYZmEZRaWRVhWYdmEZReWQ1hOYbmE5RaWR1heYfmE5RdWQFhBYYWEFRZWRFhRYcWEFRdWQlhJYaWElRZWRlhZYeWElRdWQVhFYZWEVRZWRVhVYdWEVRdWQ1hNYbWE1RZWR1hdYfWE1RfWQFhDYY2ENRbWRFhTYc2ENRfWQlhLYa2EtRbWRlhbYe2EtRfWQVhHYZ2EdRbWRVhXYd2EdRfWQ1hPYb2E9RbWR1hfYf2E9Rc2QJi7MA9hnsK8hCnCbMK8hfkIGyhskLDBwoYIGypsmLDhwkYIGylslLDRwsYIGytsnLDxwiYImyhskrDJwqYImypsmrDpwv4TNkPYTGGzhM0WNkfYXGHzhM0XtkDYQmGLhC0WtkTYUmHLhC0XtkLYSmGrhK0WtkbYWmHrhK0XtkHYRmGbhG0WtkXYVmHbhG0XtkPYTmG7hO0WtkfYXmH7hO0XdkDYQWGHhB0WdkTYUWHHhB0XdkLYSWGnhJ0WdkbYWWHnhJ0XdkHYRWGXhF0WdkXYVWHXhF0XdkPYTWG3hN0WdkfYXWH3hN0X9kDYQ2GPhD0W9kTYU2HPhD0X9kLYS2GvhL0W9kbYW2HvhL0X9kHYR2GfhH0W9kXYV2HfhH0X9kPYT2G/hP0Wpgp+V2EhhIUUFkpYaGFhhIUVFk5YeGERhEUUFklYZGFRhEUVFk1YdGExhMUUFktYbGFxhMUVFk9YfGEJhCUUlkhYYmFJhCVVzyuEJROWXFgKYSmFpRKWWlgaYWmFpROWXlgGYRmFZRKWWVgWYVmFZROWXVgOYTmF5RKWW1geYXmF5ROWX1gBYQWFFRJWWFgRYUWFFRNWXFgJYSWFlRJWWlgZYWWFlRNWXlgFYRWFVRJWWVgVYVWFVRNWXVgNYTWF1RJWW1gdYXWF1RNWX1gDYQ2FqX+Z31hYE2FNhTUT1lxYC2EthbUS1lpYG2FthbUT1l5YB2EdhXUS1llYF2FdhXUT1l1YD2E9hfUS1ltYH2F9hfUL9ef/zE79jyapv0DyEOYpzEuYIswmzFuYj7CBwgYJGyxsiLChwoYJGy5shLCRwkYJGy1M/Y99q/9yTj2jGh/qz/mPeqlnSxOFTRI2WdgUYVOFTRM2Xdh/wmYImylslrDZwuYImytsnrD5whaE+nNGGEJ7pno2p55vfY7l4nupcahX2qw1Xx2N+aSfi+5aqrGxbQ4d//A87Bk92wDYbsBOAnYFsPuAvQLsJ2DhQgfOYgKWBLA0gOUArDBg5QCrCVhjwNoD1gswBbARgE0CbC5gKwDbDNg+wE4AdgWw+4C9AuwrYCHDBM6iApYAsFSAZQUsP2ClAasGWEPA2gDWDTAPwIYCNgGwWYAtAWwDYLsBOwbYRcBuA/YcsE+AuYYNnEUCLA5gyQHLBFhewEoAVgmweoC1BKwLYP0BGwjYWMD+A2wRYGsB2w7YYcDOAXYTsCeAvQMsUbjAWRrAsgNWFLAKgNUGrBlgXQEbANhgwMYBNh2wRYCtBWwHYIcBOwvYTcCeAPYesF+AhQsfOIsFWFLA0gOWC7AigFUArDZgzQDrCFhvwLwBGwXYVMDmA7YSsK2AHQDsNGDXAHsA2BvAvgMWJkLgLDpgCQFLA1h2wAoBVhaw6oA1BqwdYD0B8wJsGGCTAJsD2HLANgG2B7ATgF0G7B5gLwH7DFjIiIGzKIDFBywlYJkByw9YKcCqAtYAsFaADQFsPGAzAVsO2CbA9gJ2ArDrgD0C7C1gPwALHSlwFh2wRIClASw7YAUBKwtYDcAaA9YOsB6AeQE2HLBJgM0BbBlgmwDbC9gJwC4Ddhewl4B9ASxk5MBZFMDiAZYSsCyA5QesFGBVAGsAWGvAugHmDthgwMYDNhOwJYCtB2wnYEcBuwDYbcCeAfYBsP/70WYgLCJgcQBLBlgGwPIAVhywSoDVBaw5YJ0B6wfYQMDGADYNsIWArQFsO2CHADsD2DvAfgIWLmrgLA5gyQDLCFgewEoDVg2whoC1AawrYO6ADQFsPGAzAVsM2HrAdgF2FLALgN0C7BlgHwH7vx+fB8IiAhYbsGSAZQQsD2DFAasIWF3AWgDWGbB+gPkANgaw6YAtBGwNYNsAOwTYWcBuAPYYsLeA/QQsXPTAWUzAkgCWFrCcgBUBrDxgtQBrAlgHwHoDZgNsJGCTAZsH2ErAtgC2H7CTgF0F7AFgrwH7BlioGIGzaIAlBCw1YNkAKwBYI8DaAtYDMBtgIwGbAtg8wNYCtgOww4CdA+w6YI8BewfYT8DCxQycxQAsCWDpAMsJWBHAygFWC7CmgHUArDdgCmAjAZsC2DzAVgK2GbD9gJ0C7CpgDwB7Bdg3wELHCpxFAywhYKkAywZYQcDKAFYdsIaAtQWsB2CegA0DbAJgswFbBthGwPYAdgywS4DdBewFYJ8Bc40dOIsMWDzAUgCWGbC8gJUErApg9QFrBVgXwAYANhiwcYDNAGwRYEcAOw/YLcBeAPYZsBBxAmeRAUsEWBrAsgNWCLDSgFUHrBFgbQHrAZgHYMMAmwjYbMCWAbYBsD2AHQfsEmB3AXsO2GfAQsQNnEUGLB5gyQHLDFg+wEoCVgWweoC1AqwrYAMAGwzYWMBmALYYsHWA7QTsMGDnAbsF2FPAPgD2C7AI8QJnsQFzAywDYLkAKwZYRcDqANYcsI6A9QXMB7DRgE0DbD5gqwHbBthBwM4Adg2wR4C9BewHYGHjB86iA5YDsMKAlQOsDmDNAesEWF/AhgA2HrCZgC0BbC1gOwE7Ath5wG4B9gSwD4D9BixCgsBZbMCSApYBsNyAFQOsImC1AWsOWCfA+gLmA9gowKYBtgCw1YBtA+wAYGcAuw7YI8DeAvYdsLAJA2cxAEsMWFrAsgNWGLBygNUErAlg7QDrBZgC2AjAJgM2B7AVgG0GbB9gJwG7DNh9wF4B9hWwUIkCZ1EASwBYKsCyAlYAsFKAVQOsIWBtAOsOmDtgswBbCtgGwPYBdhKwK4DdB+wdYD8BC5c4cBYTsESApQUsB2CFASsHWA3AmgDWHrBegCmADQdsMmBzAVsB2GbA9gJ2ErArgN0H7BVgXwALlSRwFhWwBIClAiwLYAUAKw1YNcAaAtYasO6AeQA2FLAJgM0EbClgGwDbDdgxwC4Adgew54B9Asw1aeAsImBxAUsOWCbA8gJWHLDKgNUDrCVgXQDrB9ggwMYC9h9giwBbA9gOwA4Ddg6wm4A9Biy8W+AsFmBJAcsEWF7ASgBWGbBGgLUFrAdgnoANAWwCYLMAWwrYBsB2AXYMsIuA3QHsOWAfAXNNFjiLBFhcwJIDlhGwvICVAKwyYPUAawFYF8D6AzYIsLGATQdsEWBrAdsB2GHAzgJ2E7AngL0H7Bdg4ZIHzmIBlhSw9IDlAqwIYBUAqw1YM8A6AtYbMG/ARgE2FbD5gK0EbCtgBwA7Ddg1wB4A9gaw74CFSRE4iw5YQsDSAJYdsEKAlQWsOmA9AfMCbDhgUwGbD9gqwLYCdgSw84DdAuwpYO8A+wVY+JSBs1iAJQUsHWC5ACsKWAXAagPWFLCOgPUBzBuwUYBNAWw+YKsA2wrYAcBOAXYNsIeAvQHsO2ChUwXOogOWCLA0gGUHrCBgZQGrAVhjwNoB1gMwL8CGAzYJsDmALQNsE2B7ATsB2GXA7gL2ErAvgIVMHTiLAlg8wFIClgWw/ICVAqwKYA0Aaw1YN8DcARsM2HjAZgK2BLD1gO0E7DZgzwD7CFjINIGzKIDFBywlYDkAKwxYOcBqAtYIsHaA9QTMC7DhgE0EbA5gywHbBNhewI4Ddhmwe4C9BOwLYCHSBs6iABYfsJSAZQEsH2ClAKsKWAPAWgPWFTB3wIYANh6wmYAtBmw9YLsAOwrYBcBuAfYMsI+A/d//kVcgLCJgsQFLBlhGwPIAVhywioDVBawFYJ0B6weYD2BjAJsO2ELA1gC2DbBDgJ0F7AZgjwF7C9hPwMKlD5zFBCwJYGkBKw9YLcCaAtYZsH6ADQRsDGCzAFsK2AbAdgN2BLALgN0G7BlgHwH7DVjEDIGzOIAlAywjYLkBKw5YJcDqAtYCsE6A9QNsIGBjAJsO2ALA1gC2HbBDgJ0F7DpgjwF7B9hPwMJlDJzFACwJYOkAywlYEcDKAVYLsKaAdQCsN2AKYCMBmwLYPMBWArYZsP2AnQLsKmAPAHsF2DfAQmcKnEUDLCFgqQDLBlhBwMoAVh2whoC1BawHYJ6ADQNsAmAbAdsD2HHArgL2ALDXgH0DLHzmwFkswJIClh6wHIAVAaw8YLUAawpYe8B6A2YDbCRgUwCbC9hKwLYAth+wU4BdAewBYK8B+wZY6CyBs6iAJQQsNWDZACsIWGnAqgPWCLC2gPUAzAOwYYBNBGw2YMsA2wDYHsCOA3YJsLuAPQfsM2AhsgbOIgMWD7DkgGUGLB9gJQGrAlg9wFoB1hWwAYANBmwsYDMAWwzYOsB2AnYYsPOA3QLsKWAfAPsFmFu2wFkGwHIDVhKwKoDVB6wVYD0B8wJsOGCTAJsF2DLANgK2B7DjgF0E7C5gLwD7DFiI7IGzSIDFAywFYJkBywdYCcCqAFYfsFaAdQWsP2CDARsH2AzAFgO2FrCdgB0B7DxgtwB7AtgHwH4DFiFH4Cw2YEkBywBYbsCKAVYRsNqANQesE2B9AfMBbBRg0wBbANhqwLYBdgCwM4BdB+wRYG8B+w5Y2JyBsxiAJQYsLWDZASsMWDnAagLWBLB2gI0AbDJgcwFbDdg2wA4Cdgaw24A9A+wjYC65AmfhAYsNmBtgGQDLDVhRwCoCVgew5oB1AqwPYD6AjQZsGmALAFsF2DbADgJ2BrDrgD0E7C1gPwALmztwFgOwRIClBSwHYIUBKwdYDcCaANYesF6AKYANB2wyYHMBWwHYZsD2AnYSsCuA3QfsFWBfAAuVJ3AWFbAEgKUCLAtgBQArDVg1wBoC1hqw7oB5ADYUsAmAzQRsKWAbANsN2DHALgD2CTDXvIGzSIAlACwVYFkBKwBYecBqAdYUsA6A9QRMAWwEYJMBmwvYcsA2A7YPsJOAXQHsHmCvAPsKWKh8gbOogMUHLBVgWQErAFhpwKoC1hCwNoB1B8wDsCGATQBsFmBLAdsA2C7AjgF2EbA7gD0H7CNgrvkDZ5EAiwtYcsAyApYXsBKAVQasHmAtAOsCWH/ABgE2FrDpgC0CbC1gOwA7DNhZwG4C9gSw94D9AixcgcBZLMCSApYesFyAFQFsDGBxC/65V2y62m1awlCh9SwJYG4FA39mCsBsgJ3S2I1nN4qcabUjoZ49B9+LXShwFg+wEoCVBqwbYD0Bu6qx+pH/i7Qw1oupenYbsIeAPQfsLWCfAfsJWMjCgbPQhQOPPbrGAhrbmOB7sQFLBp6ZAnwvFWDZwDNzgO/lAqwYeGYJ8L1SgFUDz6wBvlcLsGbgmS3A91oB1g08swf4Xi/AbOCZPuB7gwAbB545AXxvEmBzwTPng+8tBGwteOZ68L2NgO0Fz9wPvncQsLPgmefB9y4Cdhc88z743kPA3oJnvgff+wiYa5HAnxmySODfCw1YdPDMmOB7sQFLBp6ZAnwvFWBpAEsHWAbAMgGWBbBsgOUALBdgeQDLB1gBwAoBVgSwYoCVAKwUGPeOGmscbvbO4ucirtSzToB1BqwLYF0B6wZYd8B6ANYTsF6A9QasD2B9AesHWH/ABgDmDpgHYJ6AeQGmAGYDzBswH8AGAjYIsMGADQFsKGDDABsO2AjARgI2CrDRgI0BbCxg4wAbD9gEwCYCNgmwyYBNAWwqYNMAmw7Yf4DNAGwmYLMAmw3YXMDmA7YQsMWALQVsOWArAVsN2FrA1gO2EbDNgG0FbDtgOwHbDdhewPYDdhCww4AdBew4YCcBOw3YWcDOA3YRsMuAXQXsOmA3AbsN2F3A7gMWsWjgLBJgkQGLAlhUwKIBFh2wGIDFBCwWYLEBiwNYXMDiARYfsASAJQQsEWCJAUsCWFLA3ABLBlhywFIAlhKwVIClBiwNYGkBSwdYesAyAJYRsEyAZQYsC2BZAcsGWHbAcgCWE7BcgOUGLA9geQHLB1h+wAoAVhCwQoAVBqwoYMUBKwlYacDKAlYesIqAVQasKmDVAasJWG3A6gJWH7CGgDUGrClgzQFrCVhrwNoC1h6wjoB1BqwrYN0B6wlYb8D6AtYfMHfAPAFTAPMGbBlgywFbAdhKwFYBthqwNYCtBWwdYOsB2wDYRsA2AbYZsC2AbQVsG2DbAdsB2E7AdgG2G7A9gO0FbB9g+wE7ANhBwA4BdhiwI4AdBewYYMcBOwHYScBOAXYasDOAnQXsHGDnAbsA2EXALgF2GbArgF0F7Bpg1wG7AdhNwG4Ddhew+4A9BOwxYE8Bew7YS8BeA/YWsPeAfQTsM2BfAfsO2E/AfgPmWixwFhKw0ICFBSw8YBEBiwxYVMCiAxYTsNiAxQUsPmAJAUsMWFLAkgFWDrDygFUArCJglQCrDFgVwKoCVg2w6oDVAKwmYLUAqw1YHcDqAlYPsPqANQCsIWCNAGsMWBPAmgLWDLDmgLUArCVgrQBrDVgbwNoC1g6w9oB1AKwjYJ0A6wxYF8C6AtYNsO6A9QCsJ2C9AOsNWB/A+gLWD7D+gA0AzB0wT8AUwLwBGwjYYMCGAjYcsJGAjQZsLGDjAZsI2GTApgI2HbAZgM0CbA5g8wBbANgiwJYAtgywFYCtAmwNYOsA2wDYJsC2ALYNsB2A7QJsD2BPAHsK2DPAngP2ArCXgL0C7DVgbwB7C9g7wN4D9gGwj4B9AuwzYF8A+wrYN8C+A/YDsJ+A/QLsN2AuxQNnroCFACwkYKEACw1YGMDCAhYOsPCARQAsImCRAIsMWBTAogIWDbDogMUALCZgsQCLDVgcwOICFg+w+IAlACwhYIkBSwpYMsBSAJYKsDSApQMsA2CZAMsCWDbAcgCWC7A8gOUDrABghQArAlgxwEoAVgqwMoCVA6wCYJUAqwJYNcBqAFYLsDqA1QOsAWCNAGsC2BDAhgI2DLDhgI0AbCRgowAbDdgYwMYCNg6w8YBNAGwiYJMAmwzYFMCmAjYNsOmA/QfYDMBmAjYLsNmAzQFsLmDzAJsP2ALAFgK2CLDFgC0BbClgywBbDtgKwFYCtgqw1YCtAWwtYOsAWw/YBsA2ArYJsM2AbQFsK2DbANsB2C7A9gC2D7ADgB0C7AhgxwA7AdgpwM4Adg6wC4BdAuwKYNcAuwHYLcDuAHYPsAeAPQLsCWDPAHsB2CvA3gD2DrAPgH0C7Atg3wD7AdgvwFKXCJylASwtYOkASw9YBsAyApYJsMyAZQEsK2DZAMsOWA7AcgKWC7DcgOUBLC9g+QDLD1gBwAoCVgiwwoAVAawoYMUAKw5YCcBKAlYKsNKAlQGsLGDlACsPWAXAKgJWCbDKgFUBrCpg1QCrDlgNwGoCVguw2oDVAawuYPUAawBYI8CaANYMsBaAtQKsDWDtAOsAWCfAugDWDbAegPUCrA9g/QAbAJgHYF6A2QDzAWwQYEMAGwbYCMBGATYGsHGATQBsEmBTAJsG2H+AzQTsIGCHADsM2BHAjgJ2DLDjgJ0A7CRgpwA7DdgZwM4Cdg6w84BdAOwiYJcAuwzYFcCuAnYNsOuA3QDsJmC3ALsN2B3A7gJ2D7D7gD0A7CFgjwB7DNgTwJ4C9gyw54C9AOwlYK8Aew3YG8DeAvYOsPeAfQDsI2CfAPsM2BfAvgH2A7BfgLmUDJyFACwUYGEACwdYBMAiARYFsGiAxQAsFmBxAIsHWALAEgGWBDA3wJIDlhKw1IClBSw9YBkBywxYVsCyA5YTsNyA5QUsP2AFAWsJWCvAWgPWBrC2gLUDrD1gHQDrCFgnwDoD1gWwroB1A6w7YD0A6wlYL8B6A9YHsL6A9QOsP2ADAHMHzAMwT8C8AFMAswHmDZgPYAMBGwTYYMCGADYUsGGADQdsBGAjARsF2GjAxgA2FrBxgI0HbAJgEwGbBNhkwKYANg2w/wCbCdhswOYCNh+whYAtBmwpYMsBWwnYasDWArYesI2AbQZsK2DbAdsJ2G7A9gK2H7CDgB0G7ChgxwE7CdhpwM4Cdh6wi4BdBuwqYNcBC1kqcBYKsNCAhQEsLGDhAAsPWATAIgIWCbDIgEUBLCpg0QCLDlgMwGICFguw2IDFASwuYPEAiw9YAsASApYIsMSAJQEsKWBugCUDLDlgKQBLCVgqwFIDlgawtIClAyw9YBkAywhYJsAyA5YFsKyAZQMsO2A5AMsJWC7AcgOWF7D8gBUErDBgRQErDlhJwEoDVhaw8oBVBKwyYFUBqw5YTcBqA1YXsPqANQSsMWBNAWsOWEvAWgPWFrD2gHUErDNgXQHrDlhPwHoD1hew/oDNA2w+YAsAWwjYIsAWA7YEsKWALQNsOWArAFsJ2CrAVgO2BrC1gK0DbD1gGwDbCNgmwDYDtgWwrYBtA2w7YDsA2wnYLsB2A7YHsL2A7QNsP2AHADsI2CHADgN2BLCjgB0D7DhgJwA7CdgpwE4Ddgaws4CdA+w8YBcAuwjYZcCuAnYdsJuA3QbsLmD3AXsI2GPAngL2HLCXgL0G7C1g7wH7CNhnwL4C9h2wn4D9Bsy1dOAsJGChAQsLWHjAIgIWGbCogEUHLCZgsQGLWzpwFh+wYoAVB6wEYCUBKwVYacDKAFYWsHKAlQesAmAVAasEWGXAqgBWFbBqgFUHrAZgNQGrBVhtwOoAVheweoDVB6wBYA0BawRYY8CaANYUsGaANQesBWAtAWsFWGvA2gDWFrB2gLUHrANgHQHrBFhnwLoA1hWwboB1B6wHYD0B6w1YX8D6A+YOmCdgCmDegA0EbDBgQwEbDthIwEYDNhaw8YBNBGwyYFMBmw7YDMBmATYHsHmALQBsEWBLAFsG2ArAVgG2BrB1gG0AbBNgWwC7A9hdwO4Bdh+wB4A9BOwRYI8BewLYU8CeAfYcsBeAvQTsFWCvAXsD2FvA3gH2HrAPgH0E7BNgnwH7AthXwL4B9h2wH4D9BOwXYL8BcykTOHMFLARgIQELBVhowMIAFhawcICFBywCYBEBiwRYZMCiABYVsGiARQcsBmAxAYsNWFzA4gOWELDEgCUFLBlgKQBLBVgawNIBlgGwTIBlASwbYDkAywVYHsDyAVYAsEKAFQGsGGAlACsFWBnAygFWAbBKgFUBrBpgNQCrBVgdwLwAUwCzAeYNmA9gAwEbBNhgwIYANhSwYYANB2wEYCMBGwXYaMDGADYWsHGAjQdsAmATAZsE2GTApgA2FbBpgE0H7D/AZgA2E7BZgM0GbA5gcwGbB9h8wBYAthCwRYAtBmwJYEsBWwbYcsBWALYSsFWArQZsDWBrAVsH2AbANgG2BbBtgO0AbBdgewDbB9gBwA4BdgSwY4CdAOwUYGcAOwfYBcAuAXYFsGuA3QDsFmB3ALsH2APAHgH2BLBngL0A7BVgbwB7B9gHwD4BlqRs4CwpYG6AJQMsOWApAEsJWCrAUgOWBrC0gKUDLD1gGQDLCFgmwDIDlgWwrIBlAyw7YDkAywlYLsByA5YHsLyA5QMsP2AFACsIWCHACgNWBLCigBUDrDhgJQArCVgpwEoDVgawsoCVA6w8YBUAqwhYJcAqA1YFsKqAVQOsBmC1AKsDWD3AGgDWCLAmgDUDrAVgrQBrA1g7wDoA1gmwLoB1A6wHYL0A6wNYP8AGAOYBmBdgNsB8ABsE2BDAhgE2ArBRgI0BbBxgEwCbBNhOwHYBthuwPYDtBWwfYPsBOwDYQcAOAXYYsCOAHQXsGGDHATsB2EnATgF2GrAzgJ0F7Bxg5wG7ANhFwC4BdhmwK4BdBewaYNcBuwHYTcBuAXYbsDuA3QXsHmD3AXsA2EPAHgH2GLAngD0F7BlgzwF7AdhLwF4B9hqwN4C9A+wDYJ8A+wLYN8B+APYLMJdygbMQgIUCLAxg4QCLAFgkwKIAFg2wGIDFAiwOYPEASwBYIsCSAOYGWHLAUgKWGrC0gKUHLCNgmQHLClh2wHIC1hCwRoA1BqwJYE0BawZYc8BaANYSsFaAtQasDWBtAWsHWHvAOgDWEbBOgHUGrAtgXQHrBlh3wHoA1hOwXoD1BqwPYH0B6wdYf8AGAOYOmAdgnoB5AaYAZgPMGzAfwAYCNgiwwYANAWwoYMMAGw7YCMBGAjYKsNGAjQFsHGATAJsE2BTApgH2H2AzAZsN2FzA5gO2ELDFgC0FbDlgKwFbDdhawNYDthGwzYBtBWw7YDsB2w3YXsD2A3YQsMOAHQXsOGAnATsN2FnAzgP2HbAfgP0E7BdgvwFzKR84cwUsBGAhAQsFWGjAwgAWFrBwgIUHLAJgEQGLBFhkwKIAFhWwaIBFBywGYDEBiwVYbMDiABYXsHiAxQcsAWAJAUsEWGLAkgCWFDA3wJIBlhywFIClBCwVYKkBSwNYWsDSAZYesAyAZQQsE2CZAcsKWHbAcgKWG7C8gOUHrCBghQErClhxwEoCVhqwsoCVB6wiYJUBqwpYdcBqAlYbsLqA1QesIWCNAWsKWHPAWgLWGrC2gLUHrCNgnQHrClh3wKYD9h9gMwCbCdgswGYDNgewuYDNA2w+YAsAWwjYIsAWA7YEsKWALQNsOWArAFsJ2CrAVgO2BrC1gK0DbD1gGwDbCNgmwDYDtgWwrYBtA2w7YDsA2wnYLsB2A7YHsL2A7QNsP2AHADsI2CHADgN2BLCjgB0D7DhgJwA7CdhpwM4Cdh6wi4BdBuwqYNcBuwnYbcDuAnYfsIeAPQbsKWDPAXsJ2GvA3gL2HrCPgH0G7Ctg3wH7CdhvwFwrBM5CAhYasLCAhQcsImCRAYsKWHTAYmkszb3RCY7sOvpTz+IAFg+wBIAlAiwJYG6AJQcsJWCpAUsLWHrAMgKWGbDsgJUArCZgtTWWI8yCr322J2ulZ/Mq/rmPbXPo+IfnYc/o2QrANgG2B7BjgF0A7BZgTwB7B9gPwMJUCpxFAywBYCkBywxYXsCKA1YRsNqANQWsPWA9AfMEbChg4wGbAdgiwNYAtg2wA4CdAuwKYPcAewHYJ8BcKgfOIgAWC7AkgKUFLDtgBQErDVhVwOoD1hKwzoD1BcwbsJGATQZsDmDLANsA2C7AjgB2DrAbgD0C7A1g3wALVSVwFgWweIAlBywjYLkBKwpYecBqAtYYsLaAdQfMHbDBgI0FbDpgCwBbBdgWwPYBdgKwS4DdAewZYB8A+wVYuKqBsxiAJQIsNWBZAcsPWEnAKgNWF7DmgHUErDdgCmDDAZsI2CzAlgC2DrAdgB0C7Axg1wB7ANgrwL4AFqJa4CwSYHEAcwMsPWA5ASsMWFnAqgPWELDWgHUFrD9gAwEbDdhUwOb9P/buAs6qqm0b+D5TzAzDzNBhgIrdhd2UiIiKiIh0iZSUqIiIiIqIiIhdiI2Njd2N2Ijdjd36vef9ZsHFzX1ds0+Mj4/vOb+fzjDXf629dq3d+4hsvshuF9kDIntKZC+J7C2RfSKyb0X2u8iKDuBZpciaiaylyDYT2fYi21NkHUXWVWS9RTZEZGNENlFkp4hslsguFNmVIrtJZHeL7BGRPSey10T2nsi+ENmPIosO5FmpyBqIbE2RbSCyrUS2s8jaiqyzyLqLrL/IhotsvMgmi2y6yOaI7FKRXSuyBSK7T2RPiGyxyJaK7CORLRPZryIr6MKzcpE1EdnaIttEZK1EtrvIOoisi8h6imywyEaJbILIpopspsjOF9k8kd0gsjtF9pDInhHZKyJ7R2Sfiex7kf0psuKDeFZPZKuLbD2RbSGyHUXWWmSdRNZNZH1FNlRk40Q2SWTTRDZbZBeL7GqR3SKyhSJ7TGSLRLZEZB+I7CuR/SyyvK48KxNZI5G1ENlGIttGZLuKrL3IDhBZD5ENFNlIkR0jsikimyGyc0U2V2TzRXa7yB4Q2VMie0lkb4nsE5F9K7LfRVZ0MM8qRdZMZC1FtpnIthfZniLrKLKuIustsiEiGyOyiSI7RWSzRHahyK4U2U0iu1tkj4jsOZG9JrL3RPaFyH4UWdSNZ6UiayCyNUW2gci2EtnOImsrss4i6y6y/iIbLrLxIpsssukimyOyS0V2rcgWiOw+kT0hssUiWyqyj0S2TGS/iqzgEJ6Vi6yJyNYW2SYiayWy3UXWQWRdRNZTZINFNkpkE0Q2VWQzRXa+yOaJ7AaR3Smyh0T2jMheEdk7IvtMZN+L7E+RFXfnWT2RrS6y9US2hch2FFlrkXUSWTeR9RXZUJGNE9kkkU0T2WyRXSyyq0V2i8gWiuwxkS0S2RKRfSCyr0T2s8jyDuVZmcgaiayFyDYS2TYi21Vk7UV2gMh6iGygyEaK7BiRTRHZDJGdK7K5IpsvsttF9oDInhLZSyJ7S2SfiOxbkf0usqIePKsUWTORtRTZZiLbXmR7iqyjyLqKrLfIhohsjMgmiuwUkc0S2YUiu1JkN4nsbpE9IrLnRPaayN4T2Rci+1Fk0WE8KxVZA5GtKbINRLaVyHYWWVuRdRZZd5H1F9lwkY0X2WSRTRfZHJFdKrJrRbZAZPeJ7AmRLRbZUpF9JLJlIvtVZAU9eVYusiYiW1tkm4islch2F1kHkXURWU+RDRbZKJFNENlUkc0U2fkimyeyG0R2p8geEtkzIntFZO+I7DORfS+yP0VW3Itn9US2usjWE9kWIttRZK1F1klk3UTWV2RDRTZOZJNENk1ks0V2sciuFtktIlsossdEtkhkS0T2gci+EtnPIsvrzbMykTUSWQuRbSSybUS2q8jai+wAkfUQ2UCRjRTZMSKbIrIZIjtXZHNFNl9kt4vsAZE9JbKXRPaWyD4R2bci+11kRX14VimyZiJrKbLNRLa9yPYUWUeRdRVZb5ENEdkYkU0U2SkimyWyC0V2pchuEtndIntEZM+J7DWRvSeyL0T2o8iivjwrFVkDka0psg1EtpXIdhZZW5F1Fll3kfUX2XCRjRfZZJFNF9kckV0qsmtFtkBk94nsCZEtFtlSkX0ksmUi+1VkBf14Vi6yJiJbW2SbiKyVyHYXWQeRdRFZT5ENFtkokU0Q2VSRzRTZ+SKbJ7IbRHanyB4S2TMie0Vk74jsM5F9L7I/RVbcn2f1RLa6yNYT2RYi21FkrUXWSWTdRNZXZENFNk5kk0Q2TWSzRXaxyK4W2S0iWyiyx0S2SGRLRPaByL4S2c8iyxvAszKRNRJZC5FtJLJtRLaryNqL7ACR9RDZQJGNFNkxIpsishkiO1dkc0U2X2S3i+wBkT0lspdE9pbIPhHZtyL7XWRFA3lWKbJmImspss1Etr3I9hRZR5F1FVlvkQ0R2RiRTRTZKSKbJbILRXalyG4S2d0ie0Rkz4nsNZG9J7IvRPajyKJBPCsVWQORrSmyDUS2lch2FllbkXUWWXeR9RfZcJGNF9lkkU0X2RyRXSqya0W2QGT3iewJkS0W2VKRfSSyZSL7VWQFg3lWLrImIltbZJuIrJXIdhdZB5F1EVlPkQ0W2SiRTRDZVJHNFNn5IpsnshtEdqfIHhLZMyJ7RWTviOwzkX0vsj9FVnw4z+qJbHWRrSeyLUS2o8hai6yTyLqJrK/IhopsnMgmiWyayGaL7GKRXS2yW0S2UGSPiWyRyJaI7AORfSWyn0WWN4RnZSJrJLIWIttIZNuIbFeRtRfZASLrIbKBIhspsmNENkVkM0R2rsjmimy+yG4X2QMie0pkL4nsLZF9IrJvRfa7yIqO4FmlyJqJrKXINhPZ9iLbU2QdRdZVZL1FNkRkY0Q2UWSniGyWyC4U2ZUiu0lkd4vsEZE9J7LXRPaeyL4Q2Y8ii4byrFRkDUS2psg2ENlWIttZZG1F1llk3UXWX2TDRTZeZJNFNl1kc0R2qciuFdkCkd0nsidEtlhkS0X2kciWiexXkRUM41m5yJqIbG2RbSKyViLbXWQdRNZFZD1FNlhko0Q2QWRTRTZTZOeLbJ7IbhDZnSJ7SGTPiOwVkb0jss9E9r3I/hRZ8XCe1RPZ6iJbT2RbiGxHkbUWWSeRdRNZX5ENFdk4kU0S2TSRzRbZxSK7WmS3iGyhyB4T2SKRLRHZByL7SmQ/iyxvBM/KRNZIZC1EtpHIthHZriJrL7IDRNZDZANFNlJkx4hsishmiOxckc0V2XyR3S6yB0T2lMheEtlbIvtEZN+K7HeRFY3kWaXImomspcg2E9n2IttTZB1F1lVkvUU2RGRjRDZRZKeIbJbILhTZlSK7SWR3i+wRkT0nstdE9p7IvhDZjyKLjuRZqcgaiGxNkW0gsq1EtrPI2oqss8i6i6y/yIaLbLzIJotsusjmiOxSkV0rsgUiu09kT4hssciWiuwjkS0T2a8iKxjFs3KRNRHZ2iLbRGStRLa7yDqIrIvIeopssMhGiWyCyKaKbKbIzhfZPJHdILI7RfaQyJ4R2Ssie0dkn4nse5H9KbLi0TyrJ7LVRbaeyLYQ2Y4iay2yTiLrJrK+IhsqsnEimySyaSKbLbKLRXa1yG4R2UKRPSayRSJbIrIPRPaVyH4WWd4YnpWJrJHIWohsI5FtI7JdRdZeZAeIrIfIBopspMiOEdkUkc0Q2blV2dLPlu62aMDC1VZq5+n//+eBDZ6bN6LpzZ0x+1Nkc2bwbLMzePaYyB4XWa+ZPOstsp9F9ovIzjyTZ7NEttEsnm0ssodF9ojIepzFs8NE1lNkP4rsJ5H9LLKZs3l2pshmiWyjs3m2scgeFtkjIusxh2eHiewHkf0osp9EdsY5PJspsjNFtuG5PNtIZBuL7GGRPSKyHufx7DCR/SCyH0U243yenSGymSLb4AKebSiyjUT2kMgeFtkjIiu/8P//9L4XeLMLebnNRbaFyLaqyjr2vrHFeasVFGLWtSpzj+2rshML12m05pjnvsNsUFXmbeOGiWycaMt40ZZjRXacyC6vyqaNmd++/l9v7o/ZIyJ7UozDqyJ7W2Qfi+xrkf0ksr9EVusinlWIrLHImotsfZFtLrLtRLabyNqJbD+RHSyyXiIbJLIRIjtKZMeL7GSRnSGyc0R2iciuEtmNIrtDZPeL7LmqzD2uEtlHIvtWZH+KrPRinjUS2doi20xkO4qsrcgOEFlPkQ0R2TiRTRbZDJGdL7IrRXaLyO4T2VMie0Vk74nsK5H9KrKiS3hWT2Rrimwjke0osp1FtqfIWousrcgOEVlfkR0hsjEiO05kU0V2hsjOFdllIrtWZLeKbKHIHhXZcyJ7VWTviOxTkX0rst9EVnApz+qIrJHImotsA5FtKbIdRbaXyDqK7CCR9RTZIJGNFNnRIpssstNENltkF4nsSpHdKLI7RfagyJ4S2YsiWyqyD0X2lch+Ell0Gc9KRFZPZKuJrKXINhVZK5HtJrL2IttfZN1F1k9kQ0U2VmQTRXayyM6qykbuts1dO1RWdMJstsjOFtkckZ0jsnNFdp7IzhfZBSK7UGQXiexikV0isktFdpnI5orscpHNE9kVIrtSZFeJ7GqRXSOya0V2ncjmi+x6kd0gshtFdpPIbhbZLSK7VWQLRHabyG4X2R0iu1Nkd4nsbpHdI7KFIrtXZPeJ7H6RPSCyB0X2kMgeFtkjIntUZI+J7HGRPSGyJ0X2lMieFtkzIntWZM+J7HmRLRLZCyJbLLIXRbakKvPObb8hsndE9p7IPhDZhyL7TGRfiGyZyL4V2S8i+1Vkf4ksMZdn+SIrEFmJyGqLrEJkdUXWRGRNRbamyFqIbG2RrSOyDUS2kcg2E9kWIttOZNuLbBeR7SayPUS2p8jaiWxvke0rsv1E1lVkB4ush8h6iqy3yPqIbKDIBotsqMiGi2ysyMaJ7FiRHSey40U2SWQniexkkZ0mstNFNltkZ4vsfJFdKLKLRXaJyOaJ7EqRXSuy+SK7VWQLRHaXyO4R2b0iu09kD4vsUZE9KbKnRbZYZC+K7DWRLRHZUpG9KbL3RPaByD4R2Wci+0Zk34rsJ5H9IrLfRPa7yBKX8yxfZLVEViKySpHVFVkjkTURWTORrSayFiJbW2TriWwDkW0usi1Etq3IthPZDiLbUWS7iWwPkbURWTuRdRLZfiLrIrKuIusmskNE1lNkvUXWX2QDRTZMZMNFNlpkY0V2lMjGi+w4kR0vshNFdpLIpovsdJHNEtlskc0R2Tkiu1BkF4tsrsjmiew6kc0X2c0iu1Vkt4nsdpHdI7J7RfagyB4W2VMie1pki0S2WGQviexlkS0R2VKRvSOy90T2qcg+E9nXIvtGZN+J7HuR/SKy30T2l8gS83hWLLISkZWLrFJk9URWX2RNRNZMZGuKrIXI1hfZBiLbVGSbi2xLkW0lsu1EtoPIdhHZbiJrK7J2Iusosk4i6yyy/UXWVWTdRNZDZD1FNkBkA0V2hMiGiWyEyEaKbKzIjhLZsSI7TmRTRHaSyKaJbLrIZojsDJHNFtkckZ0vsgtFdrnI5onsGpFdJ7LrRXaDyG4V2W0iu0tk94jsIZE9LLInRPaUyJ4R2bMiWyyyl0T2msiWiOxdkb0nso9F9qnIPhfZFyL7RmTfiewnkf0isugKniVEViSyYpGViqy2yCpFVk9kjUTWRGTNRdZCZOuKbH2RbSiyjUS2uci2FNm2IttOZLuKbDeRtRZZW5G1F9neIuskss4i6yKyriI7TGQ9RdZPZANENkhkg0U2TGQjRDZaZGNFNkFkx4lsssimiGyqyE4W2XSRzRDZLJHNFtkFIrtQZJeJ7HKRXSGyK0V2nciuF9nNIrtVZHeL7B6RPSCyh0T2iMgeFdlTIntGZItEtlhkr4tsicjeFtm7IntfZB+I7FORfS6yr0X2jch+FtkvIvtTZNGVPMsTWb7IikVWKrJykVWKrLHImohsDZE1F9laIltbZOuLbEORbSqyzUXWSmTbiWxnke0qst1FtofI2oqsvcg6iqyTyA4SWVeRHSqyw0TWS2S9RTZAZINEdoTIholsjMjGiuwYkU0Q2USRHS+yKSKbKrJpIpsusrNENltk54nsApFdJLKLRXa5yK4Q2TUiu05kt4jsVpHdKbK7RbZQZPeK7CGRPSKyJ0T2lMheENlikb0qstdF9obIlorsXZG9L7KPRfapyJaJ7BuR/Siyn0X2q8h+E1l0Fc/yRFYksmKRVYisUmQNRdZYZE1F1kxkzUW2lsjWFdn6IttMZJuLbBuRtRLZ9iLbQWS7imx3kbUWWVuR7SuyTiI7UGQHiexgkXUT2WEi6yWyfiIbILKhIhsmslEiGyOycSI7SmQTRDZRZJNFNkVkp4lsusjOFNlZIjtbZHNEdoHILhLZZSK7XGTXiuw6kd0ksltEtkBkt4nsbpEtFNkDIntIZE+K7CmRPS+yF0T2osheEtnrIntDZG+L7F2RfSKyT0X2lciWiexbkX0nsp9F9qvI/hRZdDXPaomsWGR1RFYhsroiqyeyxiJrKrI1RNZcZOuJbH2RbSKyzUS2hci2FFkrkW0vsp1FtqvI2oisrcj2Edm+IttPZJ1FdpDIDhbZoSI7TGT9RTZAZENENlRkw0U2QmRjRDZOZMeIbILIThTZFJGdKrLTRHa6yGaI7CyRnS2y80R2gcjmiuxykV0tsmtFNl9k14vsFpEtENmdIrtbZA+K7CGRPS6yJ0X2tMieEdkLIntRZK+K7HWRvSOyd0X2kcg+EdlnIvtcZMtE9q3IfhTZzyL7S2TRNTwrFFktkZWIrFRkFSKrK7KGImsssjVF1lxkLUW2nsg2ENmGIttMZFuIbBuRtRLZLiLbVWR7iayNyNqJrL3I9hXZfiI7UGQHiayHyA4TWV+R9RfZQJENEtlQkQ0X2SiRjRHZsSKbILITRHaiyE4S2VSRnSay00V2psjOEtkFIrtQZJeJ7HKRXSGyK0V2nciuF9nNIrtVZPeIbKHIHhTZwyJ7VGSPiexpkT0rshdE9qLIlojsDZG9I7L3RPaByD4U2Wci+0Jky0T2rch+FdlvIouu5VmeyApEViiyUpGViaxSZPVE1lRkzUTWXGRriWwdkbUU2YYi21hkm4tsS5FtL7IdRLaryHYX2Z4i20tk7UXWQWSdRNZZZIeJrKfI+olsgMgGiWywyIaJbITIRotsrMgmiOw4kU0W2RSRTRXZySKbLrIZIpslstkiu0xkc0V2lciuEdl1IpsvsptFdqvI7hDZXSJ7QGQPiuwxkT0hsqdE9rTIFolsscheEdlrIvtQZB+J7HORfSmyr0W2TGQ/iOwnkf0msj/U/sR1PCsUWanIykRWLrIKkTUQWSORNRPZ6iLbUGQbiWxzkW0psq1Fto3IdhDZTiLbTWR7iKy9yPYWWSeRdRbZASI7UGTdRNZdZD1F1ltkw0Q2XGSjRTZWZEeJbLzIjhPZ8SI7UWQniWy6yE4X2SyRzRbZHJGdI7ILRXaxyOaKbJ7IbhbZLSK7Q2R3iewekS0U2YMie1hkj4vsSZEtEtkLIntFZK+JbInI3hDZOyJ7T2QfiewTkf0gsh9F9pvI/hDZXyKL5vOsUGS1RFZbZHVE1kBkDUXWTGSri2xNkTUXWUuRrSeyjUS2ich2ENmOIttNZHuIbC+RtRbZ3iLbR2T7iWx/kXUT2SEi6ymy3iLrK7J+IhsssiEiGy6ykSI7TmQTRXaiyE4S2ckiO0Vkp4vsDJGdJbKzRXahyC4S2VyRzRPZlSK7SmTzRXaDyG4R2QKRPSiyh0T2uMieFNnTIntGZC+I7EWRvSqy10X2jsjeFdlHIvtEZJ+J7HORLRPZtyL7UWQ/q/2C63lWJLLaIqsjsgqRVYqsocgai2w1ka0hspYiW1dkG4lsE5FtJrLNRbaNyFqJbEeR7SyyvUXWQWT7iWx/kR0osi4iO0Rkh4qsl8j6iGywyA4X2XCRjRTZKJGNFtl4kR0jsokimySy00U2Q2RniexskZ0jsnNFdpHILhHZ5SK7QmTzRXa9yG4R2QKR3S6yO0S2UGT3iewhkT0ishdEtlhkr4rsdZG9IbKlIntXZO+L7GORfSqyZSL7RmQ/iuxnkf0qst9EFt3AszyRFYmsWGQNRdZIZKuJbA2RNRdZC5GtK7L1RbaxyDYV2TYi21ZkO4psZ5HtKrLdRNZaZG1F1kFkHUV2iMi6i6yXyPqIrJ/I+ovscJEdIbIRIjtSZONFdrTIJopsksgmi+xEkZ0ismkimyGymSK7SGQXi+xykV0hsqtEdrXIrhfZjSK7VWS3iWyhyO4V2UMie0Rkj4nscZE9I7LnRLZYZC+J7F2RvSeyj0X2qcg+F9kXIvtGZN+J7CeR/SKy6EaeJURWJLJikZWKrLbIKkVWT2SNRNZEZOuKbD2RbSyyTUW2uci2ENm2IttOZDuJbBeRtRZZG5F1EFlHkXUS2X4i6yKyriLrLrIeIjtcZENENkJkR4pstMjGiOxokR0rsuNFdoLIThHZqSKbIbKZIpslsrNEdq7IzhfZxSK7VGRzq7KNL16j87fPHXFo+Hudqp8VVT/7jj18aP9ew0YP6tV36Ih+R7xQ8P//XFwV51X9TPzPf/n/81+LKNYnUQzlUi8/5ZBiW2FK5Qv+t3yyTEF65fNC+cK0yv/P5qvqZzsoj20J9eYbZ8skwLQH056YvcHsTUwHMB2I2QfMPsR0BNORmH3B7EtMJzCdiNkPzH7EdAbTmZj9wexPzAFgDiDmQDAHEtMFTBdiDgJzEDFdwXQl5mAwBxPTDUw3Yg4Bcwgx3cF0J+ZQMIcS0wNMD2IOA3MYMT3B9CSmF5hexPQG05uYPmD6ENMXTF9i+oHpR0x/MP2JGQBmADEDwQwkZhCYQcQMBjOYmMPBHE7MEDBDiDkCzBHEDAUzlJhhYIYRMxzMcGJGgBlBzEgwI4k5EsyRxIwCM4qY0WBGEzMGzBhixoIZS8w4MOOIOQrMUcSMBzOemKPBHE3MMWCOIeZYMMcSMwHMBGKOA3McMRPBTCTmeDDHEzMJzCRiTgBzAjGTwUwm5kQwJxIzBcwUYk4CcxIxU8FMJeZkMCcTcwqYU4g5FcypxEwDM42Y08CcRsx0MNOJOR3M6cTMADODmDPAnEHMTDAziTkTzJnEzAIzi5izwJxFzGwws4k5G8zZxMwBM4eYc8CcQ8y5YM4l5jww5xFzPpjzibkAzAXEXAjmQmIuAnMRMReDuZiYS8BcQsylYC4l5jIwlxEzF8xcYi4Hczkx88DMI+YKMFcQcyWYK4m5CsxVxFwN5mpirgFzDTHXgrmWmOvAXEfMfDDzicFzAtcTcwOYG4i5EcyNxNwE5iZibgZzMzG3gLmFmFvB3ErMAjALiLkNzG3E3A7mdmLuAHMHMXeCuZOYu8DcRczdYO4m5h4w9xCzEMxCYu4Fcy8x94G5j5j7wdxPzANgHiDmQTAPEvMQmIeIeRjMw8Q8AuYRYh4F8ygxj4F5jJjHwTxOzBNgniDmSTBPEvMUmKeIeRrM08Q8A+YZYp4F8ywxz4F5jpjnwTxPzCIwi4h5AcwLxCwGs5iYF8G8SMxLYF4i5mUwLxPzCphXiHkVzKvEvAbmNWJeB/M6MUvALCHmDTBvELMUzFJi3gTzJjFvgXmLmLfBvE3MO2DeIeZdMO8S8x6Y94h5H8z7xHwA5gNiPgTzITEfgfmImI/BfEzMJ2A+IeZTMJ8S8xmYz4j5HMznxHwB5gtivgTzJTFfgfmKmK/BfE3MMjDLiPkGzDfEfAvmW2K+A/MdMd+D+Z6YH8D8QMyPYH4k5icwPxHzM5ififkFzC/E/ArmV2J+A/MbMb+D+Z2YP8D8QcyfYP4k5i8wfxHzv/8wv1uTAJMgJg9MHjH5YPKJKQBTQEwhmEJiisAUEVMLTC1iisEUE1MCpoSYUjClxNQGU5uYMjBlxNQBU4eYcjDlxFSAqSCmEkwlMXXB1CWmHph6xNQHU5+YBmAaENMQTENiGoFpRExjMI2JaQKmCTFNwTQlphmYZsSsBmY1YlYHszoxa4BZg5g1waxJTHMwzYlpAaYFMWuBWYuYtcGsTcw6YNYhpiWYlsSsC2ZdYtYDsx4x64NZn5gNwGxAzIZgNiRmIzAbEbMxmI2J2QTMJsRsCmZTYjYDsxkxm4PZnJgtwGxBzJZgtiRmKzBbEbM1mK2J2QbMNsRsC2ZbYlqBaUXMdmC2I2Z7MNsTswOYHYjZEcyOxOwEZididgazMzG7gNmFmF3B7ErMbmB2I2Z3MLsTsweYPYjZE8yexOwFZi9iWoNpTUwbMG2IaQumLTHtwLQjpj2Y9sTsDWZvYjqA6UDMPmD2IaYjmI7E7AtmX2I6gelEzH5g9iOmM5jOxOwPZn9iDgBzADEHgjmQmC5guhBzEJiDiOkKpisxB4M5mJhuYLoRcwiYQ4jpDqY7MYeCOZSYHmB6EHMYmMOI6QmmJzG9wPQipjeY3sT0AdOHmL5g+hLTD0w/YvqD6U/MADADiBkIZiAxg8AMImYwmMHEHA7mcGKGgBlCzBFgjiBmKJihxAwDM4yY4WCGEzMCzAhiRoIZScyRYI4kZhSYUcSMBjOamDFgxhAzFsxYYsaBGUfMUWCOImY8mPHEHA3maGKOAXMMMceCOZaYCWAmEHMcmOOImQhmIjHHgzmemElgJhFzApgTiJkMZjIxJ4I5kZgpYKYQcxKYk4iZCmYqMSeDOZmYU8CcQsypYE4lZhqYacScBuY0YqaDmU7M6WBOJ2YGmBnEnAHmDGJmgplJzJlgziRmFphZxJwF5ixiZoOZTczZYM4mZg6YOcScA+YcYs4Fcy4x54E5j5jzwZxPzAVgLiDmQjAXEnMRmIuIuRjMxcRcAuYSYi4Fcykxl4G5jJi5YOYSczmYy4mZB2YeMVeAuYKYK8FcScxVYK4i5mowVxNzDZhriLkWzLXEXAfmOmLmg5lPzPVgrifmBjA3EHMjmBuJuQnMTcTcDOZmYm4Bcwsxt4K5lZgFYBYQcxuY24i5HcztxNwB5g5i7gRzJzF3gbmLmLvB3E3MPWDuIWYhmIXE3AvmXmLuA3MfMfeDuZ+YB8A8QMyDYB4k5iEwDxHzMJiHiXkEzCPEPArmUWIeA/MYMY+DeZyYJ8A8QcyTYJ4k5ikwTxHzNJiniXkGzDPEPAvmWWKeA/McMc+DeZ6YRWAWEfMCmBeIWQxmMTEvgnmRmJfAvETMy2BeJuYVMK8Q8yqYV4l5DcxrxLwO5nViloBZQswbYN4gZimYpcS8CeZNYt4C8xYxb4N5m5h3wLxDzLtg3iXmPTDvEfM+mPeJ+QDMB8R8COZDYj4C8xExH4P5mJhPwHxCzKdgPiXmMzCfEfM5mM+J+QLMF8R8CeZLYr4C8xUxX4P5mphlYJYR8w2Yb4j5Fsy3xHwH5jtivgfzPTE/gPmBmB/B/EjMT2B+IuZnMD8T8wuYX4j5FcyvxPwG5jdifgfzOzF/gPmDmD/B/EnMX2D+Imb5w/bwuzUJMAli8sDkEZMPJp+YAjAFxBSCKSSmCEwRMbXA1CKmGEwxMSVgSogpBVNKTG0wtYkpA1NGTB0wdYgpB1NOTAWYCmIqwVQSUxdMXWLqgalHTH0w9YlpAKYBMQ3BNCSmEZhGxDQG05iYJmCaENMUTFNimoFpRsxqYFYjZnUwqxOzBpg1iFkTzJrENAfTnJgWYFoQsxaYtYhZG8zaxKwDZh1iWoJpScy6YNYlZj0w6xGzPpj1idkAzAbEbAhmQ2I2ArMRMRuD2ZiYTcBsQsymYDYlZjMwmxGzOZjNidkCzBbEbAlmS2K2ArMVMVuD2ZqYbcBsQ8y2YLYlphWYVsRsB2Y7YrYHsz0xO4DZgZgdwexIzE5gdiJmZzA7E7MLmF2I2RXMrsTsBmY3YnYHszsxe4DZg5g9wexJzF5g9iKmNZjWxLQB04aYtmDaEtMOTDti2oNpT8zeYPYmpgOYDsTsA2YfYjqC6UjMvmD2JaYTmE7E7AdmP2I6g+lMzP5g9ifmADAHEHMgmAOJ6QKmCzEHgTmImK5guhJzMJiDiekGphsxh4A5hJjuYLoTcyiYQ4npAaYHMYeBOYyYnmB6EtMLTC9ieoPpTUwfMH2I6QumLzH9wPQjpj+Y/sQMADOAmIFgBhIzCMwgYgaDGUzM4WAOJ2YImCHEHAHmCGKGghlKzDAww4gZDmY4MSPAjCBmJJiRxBwJ5khiRoEZRcxoMKOJGQNmDDFjwYwlZhyYccQcBeYoYsaDGU/M0WCOJuYYMMcQcyyYY4mZAGYCMceBOY6YiWAmEnM8mOOJmQRmEjEngDmBmMlgJhNzIpgTiZkCZgoxJ4E5iZipYKYSczKYk4k5BcwpxJwK5lRipoGZRsxpYE4jZjqY6cScDuZ0YmaAmUHMGWDOIGYmmJnEnAnmTGJmgZlFzFlgziJmNpjZxJwN5mxi5oCZQ8w5YM4h5lww5xJzHpjziDkfzPnEXADmAmIuBHMhMReBuYiYi8FcTMwlYC4h5lIwlxJzGZjLiJkLZi4xl4O5nJh5YOYRcwWYK4i5EsyVxFwF5ipirgZzNTHXgLmGmGvBXEvMdWCuI2Y+mPnEXA/memJuAHMDMTeCuZGYm8DcRMzNYG4m5hYwtxBzK5hbiVkAZgExt4G5jZjbwdxOzB1g7iDmTjB3EnMXmLuIuRvM3cTcA+YeYhaCWUjMvWDuJeY+MPcRcz+Y+4l5AMwDxDwI5kFiHgLzEDEPg3mYmEfAPELMo2AeJeYxMI8R8ziYx4l5AswTxDwJ5klingLzFDFPg3mamGfAPEPMs2CeJeY5MM8R8zyY54lZBGYRMS+AeYGYxWAWE/MimBeJeQnMS8S8DOZlYl4B8woxr4J5lZjXwLxGzOtgXidmCZglxLwB5g1iloJZSsybYN4k5i0wbxHzNpi3iXkHzDvEvAvmXWLeA/MeMe+DeZ+YD8B8QMyHYD4k5iMwHxHzMZiPifkEzCfEfArmU2I+A/MZMZ+D+ZyYL8B8QcyXYL4k5iswXxHzNZiviVkGZhkx34D5hphvwXxLzHdgviPmezDfE/MDmB+I+RHMj8T8BOYnYn4G8zMxv4D5hZhfwfxKzG9gfiPmdzC/E/MHmD+I+RPMn8T8BeYvYlb8suJ3axJgEsTkgckjJh9MPjEFYAqIKQRTSEwRmCJiaoGpRUwxmGJiSsCUEFMKppSY2mBqE1MGpoyYOmDqEFMOppyYCjAVxFSCqSSmLpi6xNQDU4+Y+mDqE9MATANiGoJpSEwjMI2IaQymMTFNwDQhpimYpsQ0A9OMmNXArEbM6mBWJ2YNMGsQsyaYNYlpDqY5MS3AtCBmLTBrEbM2mLWJWQfMOsS0BNOSmHXBrEvMemDWI2Z9MOsTswGYDYjZEMyGxGwEZiNiNgazMTGbgNmEmE3BbErMZmA2I2ZzMJsTswWYLYjZEsyWxGwFZititgazNTHbgNmGmG3BbEtMKzCtiNkOzHbEbA9me2J2ALMDMTuC2ZGYncDsRMzOYHYmZhcwuxCzK5hdidkNzG7E7A5md2L2ALMHMXuC2ZOYvcDsRUxrMK2JaQOmDTFtwbQlph2YdsS0B9OemL3B7E1MBzAdiNkHzD7EdATTkZh9wexLTCcwnYjZD8x+xHQG05mY/cHsT8wBYA4g5kAwBxLTBUwXYg4CcxAxXcF0JeZgMAcT0w1MN2IOAXMIMd3BdCfmUDCHEtMDTA9iDgNzGDE9wfQkpheYXsT0BtObmD5g+hDTF0xfYvqB6UdMfzD9iRkAZgAxA8EMJGYQmEHEDAYzmJjDwRxOzBAwQ4g5AswRxAwFM5SYYWCGETMczHBiRoAZQcxIMCOJORLMkcSMAjOKmNFgRhMzBswYYsaCGUvMODDjiDkKzFHEjAcznpijwRxNzDFgjiHmWDDHEjMBzARijgNzHDETwUwk5ngwxxMzCcwkYk4AcwIxk8FMJuZEMCcSMwXMFGJOAnMSMVPBTCXmZDAnE3MKmFOIORXMqcRMAzONmNPAnEbMdDDTiTkdzOnEzAAzg5gzwJxBzEwwM4k5E8yZxMwCM4uYs8CcRcxsMLOJORvM2cTMATOHmHPAnEPMuWDOJeY8MOcRcz6Y84m5AMwFxFwI5kJiLgJzETEXg7mYmEvAXELMpWAuJeYyMJcRMxfMXGIuB3M5MfPAzCPmCjBXEHMlmCuJuQrMVcRcDeZqYq4Bcw0x14K5lpjrwFxHzHww84m5Hsz1xNwA5gZibgRzIzE3gbmJmJvB3EzMLWBuIeZWMLcSswDMAmJuA3MbMbeDuZ2YO8DcQcydYO4k5i4wdxFzN5i7ibkHzD3ELASzkJh7wdxLzH1g7iPmfjD3E/MAmAeIeRDMg8Q8BOYhYh4G8zAxj4B5hJhHwTxKzGNgHiPmcTCPE/MEmCeIeRLMk8Q8BeYpYp4G8zQxz4B5hphnwTxLzHNgniPmeTDPE7MIzCJiXgDzAjGLwSwm5kUwLxLzEpiXiHkZzMvEvALmFWJeBfMqMa+BeY2Y18G8TswSMEuIeQPMG8QsBbOUmDfBvEnMW2DeIuZtMG8T8w6Yd4h5F8y7xLwH5j1i3gfzPjEfgPmAmA/BfEjMR2A+IuZjMB8T8wmYT4j5FMynxHwG5jNiPgfzOTFfgPmCmC/BfEnMV2C+IuZrMF8TswzMMmK+AfMNMd+C+ZaY78B8R8z3YL4n5gcwPxDzI5gfifkJzE/E/AzmZ2J+AfMLMb+C+ZWY38D8RszvYH4n5g8wfxDzJ5g/ifkLzF/ERAUrTPjdmgSYBDF5YPKIyQeTT0wBmAJiCsEUElMEpoiYWmBqEVMMppiYEjAlxJSCKSWmNpjaxJSBKSOmDpg6xJSDKSemAkwFMZVgKompC6YuMfXA1COmPpj6xDQA04CYhmAaEtMITCNiGoNpTEwTME2IaQqmKTHNwDQjZjUwqxGzOpjViVkDzBrErAlmTWKag2lOTAswLYhZC8xaxKwNZm1i1gGzDjEtwbQkZl0w6xKzHpj1iFkfzPrEbABmA2I2BLMhMRuB2YiYjcFsTMwmYDYhZlMwmxKzGZjNiNkczObEbAFmC2K2BLMlMVuB2YqYrcFsTcw2YLYhZlsw2xLTCkwrYrYDsx0x24PZnpgdwOxAzI5gdiRmJzA7EbMzmJ2J2QXMLsTsCmZXYnYDsxsxu4PZnZg9wOxBzJ5g9iRmLzB7EdMaTGti2oBpQ0xbMG2JaQemHZh8MO3BtDemGOrEv7eIYn3ahfKFaZUviMqqykATl7cl1F2UXt0JHKfwyTd/w/pLTFtSnBaJhKkvDM+OX7ilvwxMGF7CZAVOO0OG0zz8Xitase0si1adtwXRyhk8XrB8+QkZHHosX26S9W8Kv9t+FuvLN8OPIC82w0hx3u5dHGU0ryq9aW/ni60bM5z2weG0LzZ1pjt+6U2fqLIeGX74PbQ3fPLNz+QnjGMY52LHh6wEMpxuyU8p/D3fqauWKRd82Dcpr/o3rlehfIUzfOwvItJu/Fue8SWOL3F8cvqEfcdSqHMvqC+FebZ7KN86vfKVoXyb9MoXhPJt0yufSE6D5Ly8zqwD6W0bVvRDON/ttqFWenXXjbttCPWXRJlsi1ZsG+w6Z8fP9o/F6Q2vMmHK4/CwztCeMK1LnCzUFdbLIlJXKFtgfNjfqnCGUWiGUeK0l617O5vtFU7bBPkZ6rV/C/VWRKuOe5FpYxG0IbTR62cLjO9WsKJcO7Pd9OYT9sV7mTaEaVLkeKyvwPh9YNt9c4FfJxsvVmdnGK9OZp4UOeOQdF3J+CciPU3jjn8eaWsXGP8FpK3YHmyr3Ve1y0J34QodZ5enKPL3F9uYcS92xt1rU4HxPcW896Y/tqutaYOd/tbYNgTf15n+djrkR6v2LzgdvL4x+WkRxfokiqNV+6FUjllC+dJo5fa3iOJ9QvnaaQ0/Krb77nb5OtxMV9xn9dYtO6+CHw7r9VDYFwv1hvKhryyNViz7daIVn0z74jrOeIY2lEMZO27Jj113KmG4+aYOz4f9ywLwlWBsPxP8OFjO7zD9QpkzPsmf4wv8YeN8C2WxrXbYp8F8O9bMNxx2mK7l0arT2W77y5224HRubdoS/CSYDnfDdIiiled9GDZuY0KWyn5dcjj3mumN89cuPxWQectDnvGVjq8AY5ddXFbKTIbTuNwMp8wZDk7v0Nd6fQGu77YvqBTja5eP5H91q/5dRHyor8D4M8S2pi60z1unCkids2G5nmXmMc6DUqj/UjJsHP98Z3yCr+eMP/q6pq3BnyvGv9IZ/7pQp92PDv4CZ12y7cTx8vrU8Pf6jq/njFd5tOp0CWW9aY/jdmkBr6OOaU8YXmnkLxO1TVsxw+HjuHvrdl2nrWpe13WGY+f1Vc689rZdFWZ4XvtwvbfreJlTF243Mus7JxySgLaEuvMdWWB+BnNT1R9wvyr8LIjRjiWP/vDKgg5bDatryic/YfktzaD+RbU+//7pxwbNrKn6V1s4YNFuSz9bWlP1Fxasdl6LG3t3rKn6Pyju3CbvtunNq6vfOx/Hzi3iOT/vPEeB8Q9CH/+w2V8odIaX/Nsi4RLkp9dmbE/4m3cuMN/xYdiljg9ZbchwPwQNTi+sC7cJ6J8350jxeCmUr3CGb4+dvHbj3+w50tqOr+345Hg+YfqFNM8H/u/5xcZV/+gzZkyffoN7DR0wvNeYEb2GjR7Uq+/QEf2OqFPVvmKn2akMyk6e1MpPGlJsK0ypfDQkw8sb9TI99RpW1fZQ3judkW+cLZMPZm8wexPTAUwHYvYBsw8xHcF0JGZfMPsS0wlMJ2L2A7MfMZ3BdCZmfzD7E3MAmAOIORDMgcR0AdOFmIPAHERMVzBdiTkYzMHEdAPTjZhDwBxiTIaXsdtnuL5U1txl7PiXKv5tl7G3AmfnrbqM3c1kuLk+BOrfBX7fy7T977mMHXX/p17GDtM+s8vYK8Yvzenzr7iMvXPVz3/yZextoc0ZXsauzPAydkFml7ETUYaXsctD+XbplV9+Gfyzqj+obUOcvj35sacVcdlMmOFkcvhjh4P9g+3z0rz0XhDaXAzt8C5L2FPQJdBGe3nI83Z7a+svyc74RHZ88FJBkdM+7/JTFH94Ce/yUwrtLbaXBU+t+pmc17gvmPwPT7vZaZj8tDa+zLTJmjiX0vEwMvRB9lI6bseXmTrx0pPadoe/lzseT9uF9pQ741BOhs0u2djLJMH3gXK9qn4P67O3jP/vJTkyHrh+4DKC27/kv/H0ZzrLe3WXxnD/A/3hpp5wGhWXsTiXJHC4eOq61Ay3rhluchp+R8alduSvu6E93jzBU7FDzbDD/B0JZripy+sj/vfSnWljqCvu/LWnxVtE8T52ecLpXOEMz17yG2/qCdMf528dp57gK53h4ilJO38rzXC9+RvahpcXcB6G9njzBC99HgsujBMOJ4qycwnzR9Me3M+zlzC9/o7tF6bS31VEq66LRSbDcSw2w0k4w/EuU9ptQRHxoT67LTi56mdyupUmVm5foVM++bewzSt3hmPL4LkutQ30jlPx8v7ppl7c//a2U23N+Ab/BpSbaeoM5VkfgccNdlzT6SPwNH4+qdMbh3NNPaHfw2mccOqxywoOF/ffbB9RZIaLfYRa1pIf7xg2+WkRxfvY5QLryHA+lOA0Ch/v3FCovyTyp22LKNYnYdeJMDw7fvZYIc1zX8XJvr00WnWdw2NDnHZ2OBG0Lb+aNofjPa9PyDflvPMt4e8ZnjNpYqdxaTXDzfAcS55dB6NIr4PefnAtUw7b4h2H4d+98Ut+9oJytu/y+poiyDNYp/LjTo9Qf5zpoZZRNT2wnL3dsBDGt7rpjv/2xif5aW3Gx6srP9LrGdYbd36VO1kBlM2g/6jw9tNwukVRdvfTcJmx+xHeLd7ebeYVxttpmcG6XhhnWfDWdW++ecucXefS7cvS7DuL4o5fnhk/tayzc8/esl4a+fuIti/D8VX7TRnO71r/1Plt+zKvr4izT87Gp9SMj1eXWi7s+Hjzy+5fJD9ef4Pn/ZKfbPY3CQB2GlW3vxOWyYqIr4/qfHO4FchON2vxGEi1o8D4t6t+4jk+db2rJqYvLmd2+nrrFHp7POH1/3Ybnfx4/X8tk3n3YthlFYeD07udGUdv+cfj1cym6/ghCWhLqDvfkey2wq+rfv5TbyuMe9tcTd/2V5O35f0a2vI///1e9Xt1t+WFg9P/i7flFVdV8E++LS+8HyEbt+XV9C25oW29eg0bO3TXqiX2P3yT36UZ3uR3aYYHqu0zPDhaXg4vlLMdP3RemWDagWlHTHsw7YlhNwuiYTcLomE3C6LpCKYjMexmQTTsZkE07GZBNOxmQTTsZkE07GZBNOxmQTTsZkE07GZBNOxmQTTsZkE07GZBNOxmQTTdwXQn5lAwhxLTA0wPYg4DcxgxPcH0JKYXmF7E9AbTm5g+YPoQ0xdMX2L6gelHTH8w/YkZAGYAMQPBDCRmEJhBxAwGM5iYw8EcTswQMEOIOQLMEcQMBTOUmGFghhEzHMxwYkaAGUHMSDAjiTkSzJHEjAIzipjRYEYTMwbMGGLGghlLzDgw44g5CsxRxIwHM56Yo8EcTcwxYI4h5lgwxxIzAcwEYo4DcxwxE8FMJOZ4MMcTMwnMJGJOAHMCMZPBTCbmRDAnEjMFzBRiTgJzEjFTwUwl5mQwJxNzCphTiDkVzKnETAMzjZjTwJxGzHQw04k5HczpxmR4833bDPdj66kbHzO8ua8+jlP42ANUrL8kymifXr4nyDu5lOrN97VM5u3vJ800cHbe4gWURJT28Ve33Hxf/snKfFc3/qc7370T5xlelBiSm+/LP1mZ7/aEVjbmO9Zv53uaJ9gn5Ob78k9W5rs96ZiN+e5dWEi6s+H388BgH4HjkHDGIcN+Y0amD8XW1MNSYRpmuD2ckeH0qfdveFhqdtXPf/LDUqdDmzN8WKpBhg9LJezDUlH8slF4UGm1qolnb34O7Ul+Muxf1023f/0ved9my4Qpj8PzLuTW5Ps2r6r6ad+3mfy0McNI5X2bc03bcdomyM9Qr/1bnPdtZnp9I8N5Ws97UCuVZcJ7UCuKXz5h93dwWiT/dhP8PflfbcjynbJ4IR/9d4Uryt1a9bdwY4e3T+FdtyqMP15y+cnw3Yix+5lQf0mUUb+WsNM+DM+On+1nytIb3vJ+xns/HNYZ2mPfx2inbfI/3NZ6dYWy9kGfh6p+xnlPo/eQCv4N+5l7Tdtx2mbaz+C42/7Wm6b40K69QRbLl5k2l2WxzWVOmzPcHq8TyuM8aFH1s+mw958tuqz9bT2nfdWp53F5Z72QP7L2Ovde8eR6+x3SdO+lwy/wjhGxX3oO/o7LC/ZL+c442eVrMfRLL1T9zeuXcL8ey1uHw8dp6j0QxR5AxPOdFebvLSL/k3D+nfwP30Va6AzXvi8u3CSRB75SeNtuWz8+mMfGORL147QtN7YA2mrL1jHDrXDK2fnlTResw2tLqKPc+Tv2j6EeWz7DGwrXTS7Xa5l9a2y77SOre7do2A+J825R7OfsfKsN4xWWC++43+4nfF71M8NtWGRv9sG6vPXb3kiJfbLXT9v+07s5Vb2UIcN9kO1wvLCd+DesP1sv7PH2QbzpkuH8a2X7Fxye2gfx1j+77LN9EHwYGf1vVT/tw6rJjz3WUf188oP7IPZG4JraB7EPuqS5DLSqbpscbvaz845tk+2xZfDXwja5oKpO7yEKO++96Zfhchh7PcPzVRms1wm13Hs3WYbxK09veK3iLLfYnjCtve1CqCvd9znXq5qg3rYnznYM/4brWXhhY03vN7NjHmwjnge1+/pY3r4Mwu77eD+jKF6bvT4yw+3Rtt61POwb1jB9g/d+6jynXbYvPhX6hhaibwjj6C1/9rqTXb/irA+1TR3eC0/S2V/H/WVvf5q9Txr319X7p227bf34ohQ2zpGo35sHkcnynLJ2f73SKWfnlzddsA6vLaEOb38d+7goqpH99e28/XVsu+3nvHfJe++xr4hWnff2JRvYV7HlAvfX7XQPOfodqxbkmtxft/sd1uHPKNJ9YMLUHbydJuF8gdc325fg2GPgFlGsTwO7nagdrZj23vDi7OfgdKyJ/ZxQf7b2c7zl29vPCePufX9AhZPZl2Z5311QzxmOV1dhrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVq6vG6vJeGpSl89Vre9dNUjh309873yLL//XXMvynPV+e/ITrAcl67kisqBenj3e+PPnZq+pngfF94Hz53VV1eue08k27snGuTc2/GrxmF/s5i//Sa3b1EqY8Du/vvmb3dNUEzfY1u8cSK7e9pq/ZVXf9apFZH737YLEsuw92f1gfX8xwfcxwOYp9zjfUXxKtuj6ns55Ud13UridpfolAqzjLHbYnTOu6Tmb74SJSF/uu3nfNeoLnvduYYXjnxPFvuJ4sNetJTV0ntssjW08+MutJPmTeeoIvZEO/B6wnn5r1xLsuF2d7kuZ6Evt+b7ueZLo98dYTtT1Jcz1p+U9aT36qofXk279pPYm7Pfk9S9uTRrCe/JXCelID9ySm/VzE331PYpr9QEu1XqplwPuOcbsMp7rfVadqpLK931Wct3Lba/qeRDVNcZ/A3ivl3Ytd0+u2va+XrduN86KVxq0AMm/dts8mBP9DwYpyzaoKxLnXyT6vEX7H4XvPXLE67H3bqR47J5x/4zKYH62476GWM152XWHPJlhv223rrxtjnCNRP05b+5xZPrTVlrX3OtVxytn5Vcspj3V4bQl1eM8SqWcTsvQyaffZBGy77aeq+9Ig+2yCt256fU0dMxzc54xzr1Pw21Stgxk+F+Xe62Sf2VXHe2nOj9jnRUL92Tre856lUMd7aU7X5edF4vZndhtnpy0uY0WkLnufavB7mO2zve8Sh+Htv7AX6u5sts/eflyc+Yz1ei/8jnu819Zs66o73rP7scF/BNu6vc041sC6EHtf9b90XWj5T1oXutbQurD/f2hdqKlz42FaePM+hWsT46tbZ3uZdba6Y0/7nE7w98M621fsn8Z5Hu7vmk8Zvm8h9jY01J+tfsN7h4bqN9I8hq8XZz3E9njP/uO0Zf2Gt39m+43Rpt/I1rP/w02/gdM20+XRLlc4HLY+js/SNvRGWB+PFetjaKN3LI3Orqvq3IrXnxWI4SQyHE7CGU42+xdvPUp+WkTxPl7/xN6XEXLvZ3Xt9NYNe408zfNddatbbqeb5Ra/pDjOchv8GXkryl1O6kxE/vkxrD/5n/eMLxr2jO9ZVSi5zd22yK8Tx6tCjFfwc6DO7U2d3rlrb/6Gv3v3U+BxZGhPuWkDllV15Yth13d8PTFsbFd9U1eweOytrgsEPx/6tkvMMoJ9u6rTWyfVelQK9V5u+lPvXRN2eUl+vHnbOlq5LixfScb/elhHribrCA4v7rlT+96GfBh+oePtl1jjsoLbrZtS2B+srg7vnYUp7A8nCsxwboVp+Z1pJ46r3U6yd4iweYB/U/utFWI4iQyHk3CG470nJLgMryXG3j8O9ZdEfj/fIor1Sah1zpsuGT4nV0/1395zt95za/bZy9BHFpG6QtkC4x83+8fZuB8vWe4hs3+M0zZBfoZ67d/s8ui9S0gtj+kOB5enQjMctj/zvOlX60IWZ38m+JNgW7VY9C+Vps147KD2ne17bGq6X8r1F/+O/uLDGuov3vmX9Rdxj9u/zFJ/MQT6i2Wmv8Dytr/A+xhxfuT2aVbk3s8wHPs3tUywezqyMZxKMRy27OXlr/h7JsteYf6Kck1JnYko3rG3d8+XOvYOvqRquN6xt3ffe10xXsGXQZ322Ns7nvXmT/h7A8fjcW1oT3m0ar/aIEZdBWLYDR3fQAwb29XQ1IXH1oVOW+tDjn4Q9E8NzTLiHXt7dXrrlFoP8Ng7LJfe+QV2f9RasFyvbtrsbftxHtjj5QpneAlTDqepd27AW5/xvqCWZhzVflh1ddjj3fVgWgwUw8kd767o61pEsT65/VfTnprcf92xasJme/912/yV2/5/5Xh3zyztQ+wO24c2on/JHe/m+oso+vv6i2411F8c+C/rL+Ie7/bOUn+xLvQX/Ux/kc7xbm6fZkXu/QzDsX/7bzreHWuWvXSflxkP+8LTSZ2JKN7xrvfshjreDX6CON711qnaYryCP14c73p9mzd/bH+LHvvO0J4413u9utTxbnXH2nbY6ljbe6el2m4Evzb0T6fEON716szkeHe66c/wu33s8e7y7zSD5foMslwnP3GOd3F49nkl73gXfdzj3XOycLx7DjnePQ+mxSspbBtKneEkTJb85Dt/U9uGUjM+WC6shxnetxd7v9I+e1ea3vDks3fedLHfBZPi8JbvV6r7/LztCXtnMy5nRaQu238Hf63Zr7TPQeEw1LOCyQ/2J1eY/cqaevYuzvKY7nBweYp7HHqL6a/qQBZn2x78b7De3yb2K+17kfE4NDiv3D/x+0PSXH9j9xeh/mw9q+v1o950+bvuY7brgnf/l12XU72P+QnTX2TrPuaHTX9RCC7T9RjbFWd5THc4dnnC4WCdK72LxfQX+ZDlO2XZ/dLvQH/xoukvsHyhabN9d06o4xVRh+07cH23+yH5Tv12XKNI37vpHTvm/83D8eZjKFcKWZEzrDxnWKoPKTKGjWepybCc2ufznhO1wwx9QRHx+H3F6D+BY7edzLFbKI/vhsd+KTwjpNYnO51LSfvsdxVi5g07zvgXxRj/r53jYW/+4P5EFPnzIsNnlut7zyzb5SDUi+MQ2mO9XXa9/t3ulyY/3rYi32TYFrut8tbfBPwtHPN56yj2p7avLa+mXju+3rku75yKdy+0PadWLsYXh1Po1GWf3cfnBArFsO09/flVC5a3rnrnvNW5juru6bfTRt3Tj+eNvHvgK8xw8LyEfYehrRP7CyxXS4yPd25EndePc34m+DpiHlQ644LTyt6rX9dpQx3RhuDrQhvsObw6ThvUeyq8NsR5B0xDpw3euvI3fA9l/Wx+r03yk+664l3rqWMy7G/tNQbsV+w5fK/vxv0U26fmOW3wjndrZ1Avnge358i9aab6o+rO+9r+yDvv652XrRDDUet98OG8Lusn7H1LwW8ao6/G/So8z2z3q1h/ie0tJe2z/aTX39ZPcfzrxRj/bUT/4F1v9fqH4Gqif7DLQagXxyG0x/pU75Oz/QPeG2efD8O+2l7P8PqtuOsqbqN7x1hXExEf33/butperKvevFX9WCPH4/y20waXk0aRP2zcr2rgjI9dRu0wC506sb/w+h5vfAqduu11r8ZV/y4iPtRXYPwBYh40cMYFp5XtExs6bagr2hB8V7Ff5fWb2K56MdrgXS+0bej+D+83sW+0/abqB5OfdNeViojPc6/fbGAy7Fdqqk9l97NlWm9ebr9qJT/q//h+1dG5/arl5p+2X2Wfyfq/vl91em6/arn9T+1XnfMP2K+64B+wX3VJbr9quflv2q+yz8VXZFBvBdQ73TynivPZXotT77yNolWnf3XvkrV9lffd7+rdWd6yGX6viWUz3ffmJj/pXpNR9wV7987Yc+veNai4ywleg7LvR0t1fCtjjq+3LFSazL5Liw2nMOLLlV0/i4hn5/0fF9sTb3/Hu7c8+Gzs79hhs3tjK81w2PWsQqdO3KZ739PujY+3bbLb03SPAV6IcQyE4+Ldw2zHkS0Htg3Bvyy26bWdNsT9vg7vGhT7vo7XY16DwnuIkp8auAblvm8ct4Fxnvnxvj8k1XWlIuLz3LtPw27vcdrYa6bZulZk3wHrvSdY9aleO3BdtP1GvtMO7730ajnJ0nvp3e0rjk+c7av3TuJUtzfe/p29xwPH0fYb2dq+tjX7YTjMclM/9iHo8N477917rA57vT7c92m3By0i/5Nw/o3rXn6U2vF1XhTv3JF3nwHW3yDGOEeifq9/iEyW55S13y1Rzyln55c3XZIfb3lQ9xIEVxP9uL23JNSL8ym0x/pUnzGy6yceC9v7BXCdZPMQh+Otn3aZwnnjPa9i70mqqJogcZ/9UsdN1W3jQnu8e5KwrB026xe8ZyiWv8MlWrXfwud/7Pfs2H4Up5mth00b7E9qYl/ZK4frt90eJX/He5/XKFy5TdU9L8iOIdYpXFGuhakzW/sY9jvOvG0BtpVNb3a/vd0nDX59WB92MvukuJ7bfeAG0Havb7TrX/Abi/XPO2+kzrdXd97Ivu8n7jlWb/oVmPEJfksxPl77VH/S2PHYTrsviOOKZbFcnmNtX9PQ/NubTt42LMybmtiGqfOL3nRV5xerm662f20MWUOT4Xpgz3mrdTb5sX2Bt356/VZlNfWyZ63RY3+vjjfqinK47Hply2H8oqhGzvdt908+brX7O945gTCcbB2PhO+Q9c7HqXNuNbEceePrtasMxi3UHRn3b77Httxk+IxUTZ3DsN/JXU/Ua+cXLue4ffT2de3+xQCxffSOLdQ0r+76emhPnPf7BcvuvbDPoOFwwvLqLb/B1UQ/h+MfZ5uIPtVtol1+cZvIviOBXUu2+44hqxXFO++MWZxjQ2/fVC2rwR+V4r5cJtPXLqu4fDWO+LDV9X877CLi2bX3ic6xgLeMh/GuiWU8m/fjePPA6y+8ZbyRybz93jh9afKj+mi8DnRHVR/tnS+w5xbZO8DinKtSx9WhjmJnXNM5t4jn9tQ1I9vH47lFtax714+w/oYxxjkS9XvX3SKT5Tll7blFbz/Rzi9vuiQ/3vKg9qGC+6evn9m8Xw73odg8xOGo7Yd3nginvd1+BH+52H54xxXqXEB1513ttXbvfHrkDJv1C94xSyjn9Vt4/nWNxMptj/v+RDu90XvHneo4wyuH16LCOOBygucKbzLH3OWQ5Ttl7XsSgr8dzhXeauosi1YdT1wG7HYC1+kyaE8i4bfVq9e2G6dZEfHsXWx3i3OFuEyxa/Y4Lb3r3fZ6+X0prk/quL669cnex6TelebVpd7BUF0/Z481vOMWrxxOA/u3sE3y7odj//a2P972JUznmti+ZPPalTqfjPPc277YewfVtStv/cN13a7XZU4bsA/y+rkyUz97RhrXMbwXzeuTvWfeQx3eu23T2f+rB8P07kmyx3q4/MY5NrTttvXXjzHOkajfe7Y8MlmeU9bu/7H7ieLcC/Afek79P36PUBgn71xrhcm8c+lq/fS2u3aZYtsre20r+C/E9srbx8nkfRd2e4XrgT1OsfdEeP2Ctx8dynn7I9hvPWfanu37jwvNuHr9p1cO++DqrhX/QvbV2PVAu/8X/F+w//d7jGvFhfA3u53A9QvP5d4U+W316rXtxmlWRHyZGbfl07hqgnn7f7h+2PtMvfUJ5yFbn2rB8LYn7y7BccblKNVjDPXe/Lox6spkXbbXdb1zDl45794oe06ijjMe7N9ev/B3b1/su4lCvWyeq+NKb7p789y7RmPPL+AybZ9P89a/uNd9sZ8JfVBm03X8pQloS6g735EF5mcwLarmCd4PFH4WxGjHkkd/eGVBh62G1TXlk58wj5LXCrAfikwbQpla0MZ8x+dBjn7dKpQc9/XNuexCZ3jJv20jXIL89NqM7Ql/K3F8vuPDsEsdHzJ2/y0anF5YF/a16LeG/jz5KYYyoXyFM/xiM3yv3ewdb7aufOdvwSfHcxOzXOK4p9DvJEqj9Jft1RYOWLTb0s+WVrdsp1v/B8Wd2+TdNr15TdW/qNbn3z/92KCZ1dW/WdXv/UYMGzl2zIBeR47t039UnzGH9+s1YPzIUQNGjz58xPBeRx0+ZnCvviNGjRpxVK+BQ/sMGn1qVbOKTY2pzqFiZ+zil5/0R7GtMKXy0R8ZvjF4RIZv5F3ew7WH8t6b5vONs2Ww598bzN7EdADTgZh9wOxDTEcwHYnZF8y+xHQC04mY/cDsR0xnMJ2J2R/M/sQcAOYAYg4EcyAxXcB0IeYgMAcR0xVMV2IOBnMwMd3AdCPmEDCHENMdTHdiDgVzKDE9wPQg5jAwhxHTE0xPYnqB6UVMbzC9iekDpg8xfcH0JaYfmH7E9AfTn5gBYAYQMxDMQGIGgRlEzGAwg4k5HMzhxAwBM4SYI8AcQcxQMEOJGQZmGDHDwQwnZgSYEcSMBDOSmCPBHEnMKDCjiBkNZjQxY8CMIWYsmLHEjAMzjpijwBxFzHgw44k5GszRxBwD5hhijgVzLDETwEwg5jgwxxEzEcxEYo4Hczwxk8BMIuYEMCcQMxnMZGJOBHMiMVPATCHmJDAnETMVzFRiTgZzMjGngDmFmFPBnErMNDDTiDkNzGnETAcznZjTwZxOzAwwM4g5A8wZxMwEMxNMBOZMMGeSemaBmUXMWWDOImY2mNnEnA3mbGLmgJlDzDlgziHmXDDnEnMemPOIOR/M+cRcAOYCYi4EcyExF4G5iJiLwVxMzCVgLiHmUjCXEnMZmMuImQtmLjGXg7kcTARmHph5pJ4rwFxBzJVgriTmKjBXEXM1mKuJuQbMNcRcC+ZaYq4Dcx0x88HMJ+Z6MNcTcwOYG4i5EcyNxNwE5iZibgZzMzG3gLmFmFvB3ErMAjALiLkNzG3E3A7mdjDJTzgHkIC/p3AOoH2m3+rjfSODbVtZenXH/kakUH+2vkHNO9PunV30rlokTFbgtNOe+cXpnzyz3D6xwtl5G9oRpm2a57665+b78k9W5rvNsjHfcd7a+Y7DTmFch+bm+/JPVuZ7vsmyMd+xfjvf07wKOjHD+Z6owfme90+f72H8ytMb3vLyFWmWD+31rkx7b4bx3tiSzry2V+6x7vrp1R17Xof6S0xb0p3Xce/kDePXML3hLS/fKM3yob3eU0V4V0FDM7ym6Q1veX/exLQB626WXt2x+/NQf4lpS7rzupkZnh0/1Z83NlmB006vPw/TH/vzhMmwPbj+2KfAcF7itMB1GuvCftfesejdbRLmOY6b3c6kedV7Zm47s/zzr9rO4PKQ286s8kl5O6OeqPP6HvukBM6PMP29vieb/QUO0/YXRZClMN3OzPUXyz//qv4Cl4dcf7HKJ7dfqj+5/dLo/+5+qfcNxWGe4x3SKcyDy3PbmeWff9V2BpeH3HZmlc//if1SXAZsf4H3+KYw3ebl+ovln39Vf4HLQ5b6i3o12F/E3lfJ9Rf//xOnv8BlwPYX+MRDCtPt9lx/sfyTletq9lt9snFdDedtKbgDEyt+P8Qsd94bwxPOOGR43vSODM+j1POmoX36yr5tHjNsd2iDtx5W9wb1LE2PJ/+bp0c+/C1L0+ONDKfH2jU9PTK8Pn1HhtOnbT1n+FhXaG/45JufUbTqOBc7HvvI8LFPYZbC3/OdumqZcsEfUFWB98RqKF/hDB+XiYi0G/9mn470nhotcXxy+uyTWNHmUOdeUF8K86xBKN86vfLLn99rA39sEcX7hLJtvbK7R7HKtvPKms/u5t/J6Zac/wOrJnB4Gh+3tQnzu33alW1HK5zywXnDyctwOHkxh5Of4XDyneF4z04ml88WUbyPfUo+1IF1/933MaW776j2t7ynnMP41UlvePUSpjwOz3szSpjW3pumQl2hXysiddm3xQV/ZNUE9d4saNcp7w0w3ts8ksvR0MTKbcdpa5eTNKdj7P3yUH9JlNFymVDzDccP98vtNA1lveld25Tz1q0444xt8N68ZJerGpg39f/p8ybDcyz14qwT2J4wrSucLNQVjvuLSF2hrP22pFPMOozDsOuw902p3ttZkuvwiWYdxmlrl5M0p2PsdTjUXxJltFwm1Hzzvh3Qm2/2jYSYxVm30l2Hcd2wy443PnhsFfYRyyO+bVB1FYq6vHsoy5xyWVpmYvctdplJ89goEXe62L4lzfOv9eKsq960Zm+bTP7nvU3We5PUKm9LNn0LDsP2LertlckP9i0XJ1Yu642rWn69flG1o46oy5sOdrphXUWiLvXWTK+uWqKuIqeuclPOLte2Tm84tl/B8rVitFmNfy2nzaEu9aYvry7vDdjem38TMYbjvYHWO95Tw4nz5jI1nLyYw8nPcDj5MYdTJ8Ph1BHDwazADEcd93jDKXDa7G177HrgnVssEMMpdNpc5pRLkJ9hOPZvanzCMDPc3874Gpx9i+THVSOQbN/TVb+r45mke9b06d63EWHZ0Fb7bUQvwLAXwe9fVv3uvYHbLmPZ/pZC+yZX9S2FXl3qDYjVfQuNHbb3jYLesAudtjYkw071W2iWVs2LZH8/tOpcnHeOPEvfPvi/3xQ2AoaD7YyiVdd99Tb35CfOPPDmf5xvocFxtG+l964L436lfQul900PuK5Vt05+mqV1sl3JinJfiHXS+8YAr6/+G751Oc9bZtSbS715gz7MG+9N13b5wPMtoQ5vOiTM76lus7C8mt55GQ4nL+Zw8jMcTn7M4VRmOJzKmMMpynA4RTGH89+87xL6irDvv2FVoWReJ2/ltmA7sZ+qyFvxd5xu2E9597oUGF8fhl0Pft+86nfv2Mquj95xvvc22+C9Y1f77QE4bPWWYq8u9XZ+9bZlb9jeNyV4wy502lpOhl1EPDtfuWbVSFS37xCmeU3sO+DxsF33vPnvHT+reeDNf6/vsfdd4TjaY/EiZzjeeTlvXcP1qSLmOrlxltbJDWDfYTOxTnp9mNdX2vuX/q59B5z+cc65eOdJvDeV2+UDz/OGOlRfnuG9H7HPp4b6S6JV50k651MLzfDYNi7Te5nU+oN14v0rbB7ZPqKI1IX3qKBvUzVS3nJgz6fGPY+XbNvuZJ0O9Xk/Q732b3H2LdQ0xXtf1LUCu2/ljW+xqEtN7zCcIdDfdDLTCPtx7Pc6m36vALJ8p2w9MuwuMOwD4feRpt9T+4H2XiS2jgRf4ni8Xzd4b1+kJEZdaj/I226WiGF795J7w/b2LYrJsNm+iP32kuB7xdwXydJ2JeV9EW/+q30Rbx5489+7/6DEZOq6QHX3sdp9Ee/4Edc1u32z6+RQs07WgizfKWvXyeBLYF9kRIrrZJxrmmluo9aN0zdj/dm6plndPqXdBqf5/GDLONs0bI/3rIHdXoTltYjUZb/9KfiJZhuM61gbMwxv/fPuBU1Os6PNsozTNkF+hnrt39R5BHvNIM1loKU3T6P45RPVbUdPMutsMWRxtqPBP1W8otwpYj21y05NTX97fqXYGU6Gz8PE7g9C/SXRqutLOv2B2n9Ifmx/kOY9l8v7A+/b1rBOfI4lEa18bGT3V7x9cu++N7sPcJ7pD/CeHdsfePeIeveXJZfV2aY/wGmb6fKI4x7mj7dfZffX4/Zn3vmI4OIs92kuF7GX+1B/tpZ7bzlUy32a9ym2jLMcYXu86zv2mwK9e3+xLnbv73yz3Gfr3t+rzHJfU/ex2mMAb5qqe4iw/N91314YZobPV69j76GLoGzTYe8/W3RZ+9t6TvuqU8/j8s56IX9k7XXuveLJ9fY7pOneS4dfUN12+06z3fa+GTLPGSe7fF0D2+17xHYbj7ewvHU4fO/ZVVZHmakjTLtK8/cWkf9JOP9O/offal/oDNeeX/e+Nbmu8Lbdtv76McY5EvXjtK0wtgDaasuWm+F619Ls/PKmC9bhtSXU4d2np64fB5fhsfq63rE6tt0eq1f37aX2PC/O+zKTYT9n51ttGK+wXOA44vNz6F+uWgcz3IZF9lvpsK7/5DXhRIbDSTjDiXPePc19ne1weNjOyLTF7utket7d29dR593TXE5a2X4Mh6f2dbz13K5jbF/HXnMM/hOzr4P9nd3HT+UZiff/pn0dPP+YwTLQqrpt/1dm24/PL3vbfnsPQPAnwLb/G7Ptx3GP88xThsth7PXsP/08YZrPC7SKs9xie8K09rY/oa6wb8GeFwhl7X1if5n1DIdhjym87aV3r0NyGfrVrGc1tX/Ojq2wjfnwN3tM4d335d17lmmbvT4yw+3RttX1DaX5K/6O84r1Dbifgr439A11qur0+oYwjt7yhw6H701/VkdtU0dxtOoym85xAe6Xe/vt9rmIcI8oHhfUF96229bfIMY4R6J+bx5EJstzytrjgrpOOTu/vOmCdXhtCXV4xwXq3pAsHRds5x0X1AUQ575SnDahHd59pbVNhn0VWy7wuADHnx0XrF+FavK4oCxate9Mtw9U21dsgz0v6p0L9sZZrfPm08BuJ2pHK6a9euZa7eek+a6z2Ps59l1nme7neMu3t59j79vHshVOZu+NbOAMx7un36urNFdXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytVVY3V513CzdL56be+6SQrnbvp751tk+b/+Wob/tOfLk59wPSBZzzxzvrwBZPlO2b2qfhYYvz2cL7/KnC+35+qwXdk41+bNv1TeH5jmNa3Yz6SF+rP1/kDvmoF6f2Ca3xOw/Jk0dQ0M2xOmdX0ns8tXEakrlLXL151VE9Y7/2z7BO9cn/deleSyemv+ym2vqetfdnlk16/uNetjdde27f3owW8A6+MDGa6PGS5Hsc/5hvpLolXX53TWk7pmeHb87HqS5jntVnGWO2yPd47ZXicJ73UpInWFsgXGP2fWE9wW2ntI4m47k8vQk2Y98b4HJd31xLsGV9168qJZT/Ih89aTcP2qwPgmsJ68Iq7z2nmntidpriex7yu360mm2xNvPVHbkzTXk5b/pPXkgxpaT97+m9aTuNuTT7O0Pfmy1opyX6Swnqh7EtNcbmOvJ/ZeqUzvSazu3v0s7Xe1VOulWgbqO5ldhlPd7/q1hva7fjDrSU3dK2Xvva1un0C9C8Au2zW1btv7etm6XVAQrTRu1b0DwD4DEfwzsG7XqvqjWrfzTX3Wseed1XNd1tb0vU7FznjZdSXuvU623bb+BjHGORL147S1z7PlQ1tt2XTudfKmC9bhtSXUUd0zSxEpXxPPQGRyr5N9BsJ7h2ece51wnzPOvU7Br1X1S4bPX7n3OtnnI9XxXrrvj4jTB2L92Tre856lUMd7aU7X5edF4vZndhtnpy0uY0WkLvtccPCbVVXkLY92+5zKc8EbFqzcdm8/Ls58xnorIn+5wuGwbd3WZltX3fGe3Y8N/l7Y1rUy41gD60LsfdX/0nWh5T9pXdirhtaFXf9D60JNnRtX35+cwrWJ8dWtsx3NOpvuczpzYJ3dT+yfxnke7u+aTxke46b9/WKZ9hveeqH6jcr0hrd8G6q+jwPbk+7zQN53Xdh+o7fpN7L1PNChpt+oqWPcuNvQAVnahk6F9XGwWB//Lz5vm+r89Naj5KdFFO/j9U+Vpp01dZ6i0oxDmueF61a33B5tllt1jdpbboOfULCi3ExSZyLyzyNj/cn/vPPOaOz5tOAnVQ03uQqdWOLXiePVQIxX8CdCnVNNnd73PHjzN/y9uu95CO2J8z0PXl35YthNHN9YDBvb1cTUhef9C5222u+MCP5E6Numm2UE+3ZVp7dOqvUI3xM40/Snca59JD/evG0drVwXlm9Ixv98WEfOJusIDi/uudMGpu35MHzv/RD2XCsuK7jduiiF/cHq6ih26khhfzhRYIZzKUzLd0w7cVztdrKBMw5qHqj7nbx54A0nkeFwEs5wypxywYVpjetPTewfh/pLIr+fbxHF+iTUOudNlzB+jdIbXj3Vf2OdoT1hWjd2Mtu/FpG6QtkC4xeY/WMcht0/9vp8/Bv2oTea/WOctgnyM9Rr/2aXRxz3OMtjusPx7iesbn9moelXG0EWZ38m+B6wrbpf9C8NTZu9cy9euQqT1XS/lOsv/h39xeIa6i+e/Zf1F3GP25dkqb/YA/qLN01/geVtf4H3MeL8yO3TrMi9n2E49m9qmbDH7jW1jNvhsGXv6ywte9/CvnBRoV9nIop37I3fBxjn2Dv4H8Wxd2NnvBqJ8Qr+F3Hs7R3PevMn/L2p4/G4NrSnPFq1X20ao64CMexmjm8qho3tambqwmPrQqetTSBHvyv0T3lmGfGOvb06vXVKrQd47B2WS+/8QkPS5vLCFeVLTJu9bT/Og9bRysNr4AwvYcrhNPXODXjrcwGMY10zjmo/rLo67PFufZgWB4rh5I53V/R1LaJYn9z+q2lPTe6/rl+17GZ7/3XtwpXb/n/leHdzsr1PdR+iMWwfthL9S+54N9dfRNHf11+0qaH+Yvd/WX8R93h33yz1F78XrSjX2fQX6Rzv5vZpVuTezzAc+7f/puPdvmbZq4QszrIX/ADYFz6a1JmI4h3vhuU57vFu8IdXDdc73vXWqUoxXsEPhTqnkmPoKIp3vFvd9d7QnjjXe7261PFudcfadtjqWDtYPDZT243gf4H+aWyM412vzkyOd482/RnO/4akzSfAcj3BtNm7r14d7+LwcPnHcjhNvXu5qjtWnZKF490p5Hh3KkyLh1PYNrDvosAs+cl3/qa2DbaPw3JhPczw2bTY+5X2GdU07xOUz6h60yXDe5HqqWX5735G9RyzX+kdeyVMhu1lz6jOMvuVNX1/mFoe0x0OLk9xj0MvIf1V3G178Iuh354r1vu6ps3pHofm+otcfxGnv7ithvqLm/5l/UXc49B7TX+B94zF6S+CvwP6iwfEcajtL9hxqN3XwPG3fYfaD2HP72IWwbiq72DE8v/E73r8u5/DyPS7Hr3nMNR3Pab5Dqvl/Zf3Tin1/iLvGQ3b97LvZcHjJfSvmf7L28anut1LVvmi6b9KwWXar2C7wrFVdf3Km6ZfSfedHNdCv/KO6RNw+bPPGYfsg6oyxc64pLAMuc8Zx90n+8hMi3S/f3kyTItPC/1h2zbizyjS8ztM10Iw9ru+S01d6JMfe/zrzSNvOPY7hMtSHA7OV/sMUihXJNqUH626nuPwypy/2f63Dvw9hWVrnbj9b6g/W985X8cMz45fWC7CuFc4bVHvgYvT7+JwKpysTa6uXF25unJ15erK1ZWrK1dXrq7/SF0hw+MUuy9caIbr7WdHJsur+jfus7c1tlQMp5hkeaZs8vfwrjB1LsX+TH7iHCPb94vgcLBcOG5JmrZFK8pgOTwuxPbY7/EMfj84Lty76vdyp7zdn/euBdrjHKyjzKnTnmfEaRXqKI3iHVtWd8yXZ7x3/GKPPaLIP0asYzIsZ5eLOubf3rGm9+630PaaePcbrhN2XnnTEb2djl7/4E1H2z/gtAkZztNsHu+n22Zv3lcYZ4+j2TrrLSusXYXOeHjrcPADqyacd89JpRjXyGmDui6E7fG+t9Ve96iEYdjp3s7YCvPvUqce++9wTqaOU486r5r8eOtc+FuG69w63jqHw7brXNxrccHXc7y9Rpb8VBiP08PbJtvpbNcJnM52u1oKbbXz026T64jhxHkPmZo21a3bdvn11m1r7f5A8mOXX9vuOk491dWbiFbsZ6h9g4RTr+p7vG0v7i/YfYm477iKO83tOWJvmnvlcHrb/S6cxslxOMWMQylk+U5Ze548+BmwP3SaqdO7Fofnzu30xumE5+3tOf1SUa9tN04zdr+jvZ4R/CzYTgyt6p+8ftxuX717PHEeFprhBT9HbJe8Ps87rgi+unfS2v0Fde+cV1dCDNu7FwDrtNdzsV0NRDmcBvZv9tjGttv7N7v/Lww/ZGE618S+ZTa3c9509+Z5hfE4bUKGy3SlGY63/uG6btdr79gU+yBvXy/O9Vl1P251+2W2j/X2y1RdxWLY1a17dthq3cN3DBY6bbXzpsJpU5kzbmE+q311b7sWt//Ga9BvkvvksF41L6vrT+z0xHXXPt+A5SrFcAqduuy8wfuqCsWw7X1V9zvblYQpXzvyn8sNy12FMw72npvQ3lLSPrudtMfTdthxxj/OfWWPwfifaLar7B63KPLnRYZ9cn2vT7bLQagXxyG0x3r2rAV6vH/entuyz69h5m0n7bzD4cRdV/NhXO09at66l4j4+Krp462rOL8bmsx7rscbjlr27Hxgyyp7Hn+JWFe951NUP1bd8yl22qjnU/D9EoWOb2iGw96rWOjUif0FlisW41Po1N3I+PCcS1EU7z0OwX8g5kEjZ1xwWtk+q7HThvqiDcF/4vRZCae8Ny8axGgDmkakDV+IfpO9uyH58bZJNdFvYl9n+031HtDkJ911pSLi89zrN+07Nb1nlOx8xTbE7VPxWQD7nEBlBvXisaV9tvA/0R95z7M1EMPx1g/7nlevn/CGbfuJgqobJlU/gftVuMzY/SpvfVT9ZCOnrrh9VJzxj9NP1obxt/2D95y61z8EVxP9g10OQr04DqE91ttlt7r3C9n+Ad8pZPsAXO/tdtbbf4u7ruIzsfvGWFcTER/ff9u62lysq968Vf3Yao7H+W2nDS4nq0X+sHG/qqkzPnYZtcMsdOrE/sLre7zxKXTqts8Lr1717yLiQ30Fxm8o5kFTZ1xwWtk+sZnThkaiDcFv6vRZqt/EdjWO0QbvOWvbhi3/4f0m9o2231T9YPKT7rpSEfF57vWbTU2G/UpN9ansPUCZ1mvfUfh/fb9q7//j+1Wdc/tVy80/bb9qSYx1NRHx8f23rav9c/tVy+1/ar9q+D9gv2rUP2C/alxuv2q5+W/ar7LfJ9Agg3rxu5XC9y6p71YJw6zue7Vr4pqr+s4xb9kMv9fEspnu9w0nP+leP/WWsUqTedeSw3CydQ3Kfq9cTY2vd9+Bul6cL4ZT6NQV53qpN2x7vfTiGPvfOK7qHpHqvo/LThv1fVzYZ3jXi+y9PGzfv9CpE7fp3vVvb3zUdbDg8Z2caj/MvpPzajEPGjrjgtPK3hfqXYssE20Ifr7Yppc5bcB21Y/RhjjXQ28S23Tve81r8Nq9ez+VvS4c6mXrCvp015WKiM/zkKn3CXvX5+x8xTakcw+O/e5c795M1aeq94d4/Ya3DVXvb/GWk+BqYvuK4xNn+6qeAchk+2rv8fDer5Pt7evWZj/Me8eY12ejKyTjqt4DZW2yDu+91Mm/t4j8T8L5N66X+ZG/3bDbgbCu5kXxthveNX6sv3GMcY5E/d57JCOT5Tlly81wGzrl7PzypksU6Xc8eetncP/mftzeS4DrJJuHOBxv/bTLFM4bO8+iaNX3BX4E2+CpZF8E26COm6q7P82+VxDXAyxrh836Be+eDPtOde9ZyeS0KCDHBQloOy4rce5Nw/4k3Xv3vHtwGolyuH7b7VHyd3xO4/taK7cJj6fznbL23c3B/wrfdfCTqTNb+xif5vttjUhb2fQuIt4eHwX/p7Nv7p2vtcer3nc04Ty069/ybUbxiuHF+Y4mdZ9Tde+Ntsej6r3RTZzx8d4Rao9tisX4eO1T/Ul11w/svqB3nteOX55jbV/TxPzbm07eNizMm5rYhtlj01Avm67e9zbEna62f8Vzj/a7rHA9sMf0ap1Nfmxf4K2fXr9VU/vU6p5/rxwuu15Zde9kls73bfdPvudc3TtZU/ecv1j1D+98nD3nVtPLkTe+XrsqYNxC3ZFxNXHciuNvlxM1rslPuvfqe9cl1Ltl7bmmbO1f3Btj/wLL1ibjy7b3dvsY/M5i++ita+o8SnXHInaZU+dfg8V7L9Dbba33bEkNbhO3S3WbqK7FJz+p7jvZ5dfbXtppyZ59sM/GhaxWFO9ZKXvOh60DdrmKu6wG3ynFfdNMpq9dVnH5YvumYZysb0iGner9DwfB+A+FZS+MQ2TGuyaW8Wyeu/DmgddfeMu43e/D8bfTO1vXeOeZbTluT+27C9g763PnFrN7btHbp4lMluq5RTa/qju3iOXUucXg/unr5991btG7HyLVc4s47e32I/hjxPYj2+cWQ3uyfW6xwinn9Vth+MlpVGr2LVN990Kq9594+8teOXzHR3XnCk8uXrlN3vuxsKx9p0vwpxevKDfN1Jmtffmv8vy2evXaduM0Y+90qTDjFvyZzv6Bt/zZYwfvvCvOQ7s+BX92iuuTOl6rbn0K7VHno1Vdal2urp+zxxrecYtXDqeB/VvYJnnPb7J/e9ufGrwHocbP5XjT3Zvn3vbF3leIy7Q9/lHvpEp+1Hk/7GdCH+T1c2Wmfq+fS0Qrr2PeO3pYHfa9e953MaWz/4fnEwud4bL7vHD/Tx0b2nbb+hvGGOdI1K/eOYjvi7Fl7f5ffaecnV/edIkif3kIy+Pf/c6lf8o5NHtvJa6fbB7icNT+n/cOMjvPkh/7DrKHxfYq2+/tsdsrXA/scUqcd3d5+9GhnLc/gv3WnXkrO/bevGfM/lAJZPlOWbuPFfz7sI/1vOkzsbx9b29YJyNneFG06jzwlptyMHa/FN/7VRGjLjX/vfccVIhhY7sqRTmcBt7f2HjU4D1mbj9TAsD2M960RJ/utPTea2HfkYnLlH13Ybbe2XiS2b8vEfXaZR7bzPbvQ30Fxn/s7N/bOnFdxfEP88jbVhWR4X0u+ks1z6Jo1Xlc3TvrSkz7cH2xx9JYzh7L1BfDSX5am7rUvk5N35vvbROq2w/yypbFaIeaBurdUtneZygW49GQDMe23/7NO5ay21S7b+j1x3/3vhr267YP9dYv9HHO0XjrV0W06rS1+xjYh5ab4Xh9Xdz3Y+L+xDNmv6AWuMIYw6wFf7PTwtuPwL7Q3vdXLMbXqytPDLu6fRI7bG9b7pXDaaCGVSTaVt12VrVN7bNg2yKnrB2Xihh1heUgX5THOrBcuanDm5fh78WizfhuZc+H+uw5xjWqKqruOl1YhmviXgpcJ+OsT6nuZ3vrk3eO2u6fYVvsflEtZzi4D277FpxetWBch1aNQFiOi5y2qvVbrUPVrd92Pwv7tTjHHKpvqW79tcNO55hDDUvt+1S3/VFtqy/KqeOhhDMulTHqsn2LVx7r8Poe27fgvAx/ryXajN9b4Xl7jj/4nWP2LWEZrom+BddT27d465PaVlc3vUP93rGfPT/s9QdhOEXOcArhb7ZvwfEqgnHd2PQt3nOBYZjZvgYSpku610BU31LdNRA77HSugahhqWPH6t5jotrWRJRT12cSzrg0jlGX7Vu88lgHlqvuueEoSu0ejVTfwXpozL7lv+X91NVNb7tvoq4vec+wqW0f9oO2b/G2ff/7jEni//+e2XQd/0cC2hLqzndkgfkZzBFV8wT38cLPghjtWPLoD68s6LDVMPtd58lPmEelGdS/qNbn3z/92KCZ1dWP59nCJ9+UCduJAsi8/b8C40dXNT45bceadaXQGV7yb5OFS5CfXpuxPeFvJY7Pd3wYdqnjQ1YbMlwH0eD0wrrw3CX6E+B+hOQHjzfwuzvs8PEYISLtZt9JZ+vKd/4WfHI8jzHLPY57Cv1aIpNle7WFAxbttvSzpTW17nxQ3LlN3m3Tm1dXf3iHz4DxY0b16TemV7+hfQ4f1mvs8H4jho/+n78cPnxA/xer5lexKZ7q5Cp2RiV++SlvFNsKUypf8Ea4lF6UXvniUL5WWuVXDHcWlMe2hHrzjbNlEmDOAnMWMbPBzCbmbDBnEzMHzBxizgFzDjHngjmXmPPAnEfM+WDOJ+YCMBcQcyGYC4m5CMxFxFwM5mJiLgFzCTGXgrmUmMvAXEbMXDBzibkczOXEzAMzj5grwFxBzJVgriTmKjBXEXM1mKuJuQbMNcRcC+ZaYq4Dcx0x88HMJ+Z6MNcTcwOYG4i5EcyNxNwE5iZibgZzMzG3gLmFmFvB3ErMAjALiLkNzG3E3A7mdmLuAHMHMXeCuZOYu8DcRczdYO4m5h4w9xCzEMxCYu4Fcy8x94G5j5j7wdxPzANgHiDmQTAPEvMQmIeIeRjMw8Q8AuYRYh4F8ygxj4F5jJjHwTxOzBNgniDmSTBPEvMUmKeIeRrM08Q8A+YZYp4F8ywxz4F5jpjnwTxPzCIwi4h5AcwLxCwGs5iYF8G8SMxLYF4i5mUwLxPzCphXiHkVzKvEvAbmNWJeB/M6MUvALCHmDTBvELMUzFJi3gTzJjFvgXmLmLfBvE3MO2DeIeZdMO8S8x6Y94h5H8z7xHwA5gNiPgTzITEfgfmImI/BfEzMJ2A+IeZTMJ8S8xmYz4j5HMznxHwB5gtivgTzJTFfgfmKmK/BfE3MMjDLiPkGzDfEfAvmW2K+A/MdMd+D+Z6YH8D8QMyPYH4k5icwPxHzM5ififkFzC/E/ArmV2J+A/MbMb+D+Z2YP8D8QcyfYP4k5i8wfxHzv/8wv1uTAJMgJg9MHjH5YPKJKQBTQEwhmEJiisAUEVMLTC1iisEUE1MCpoSYUjClxNQGU5uYMjBlxNQBU4eYcjDlxFSAqSCmEkwlMXXB1CWmHph6xNQHU5+YBmAaENMQTENiGoFpRExjMI2JaQKmCTFNwTQlphmYZsSsBmY1YlYHszoxa4BZg5g1waxJTHMwzYlpAaYFMWuBWYuYtcGsTcw6YNYhpiWYlsSsC2ZdYtYDsx4x64NZn5gNwGxAzIZgNiRmIzAbEbMxmI2J2QTMJsRsCmZTYjYDsxkxm4PZnJgtwGxBzJZgtiRmKzBbEbM1mK2J2QbMNsRsC2ZbYlqBaUXMdmC2I2Z7MNsTswOYHYjZEcyOxOwEZididgazMzG7gNmFmF3B7ErMbmB2I2Z3MLsTsweYPYjZE8yexOwFZi9iWoNpTUwbMG2IaQumLTHtwLQjpj2Y9sTsDWZvYjqA6UDMPmD2IaYjmI7E7AtmX2I6gelEzH5g9iOmM5jOxOwPZn9iDgBzADEHgjmQmC5guhBzEJiDiOkKpisxB4M5mJhuYLoRcwiYQ4jpDqY7MYeCOZSYHmB6EHMYmMOI6QmmJzG9wPQipjeY3sT0AdOHmL5g+hLTD0w/YvqD6U/MADADiBkIZiAxg8AMImYwmMHEHA7mcGKGgBlCzBFgjiBmKJihxAwDM4yY4WCGEzMCzAhiRoIZScyRYI4kZhSYUcSMBjOamDFgxhAzFsxYYsaBGUfMUWCOImY8mPHEHA3maGKOAXMMMceCOZaYCWAmEHMcmOOImQhmIjHHgzmemElgJhFzApgTiJkMZjIxJ4I5kZgpYKYQcxKYk4iZCmYqMSeDOZmYU8CcQsypYE4lZhqYacScBuY0YqaDmU7M6WBOJ2YGmBnEnAHmDGJmgplJzJlgziRmFphZxJwF5ixiZoOZTczZYM4mZg6YOcScA+YcYs4Fcy4x54E5j5jzwZxPzAVgLiDmQjAXEnMRmIuIuRjMxcRcAuYSYi4Fcykxl4G5jJi5YOYSczmYy4mZB2YeMVeAuYKYK8FcScxVYK4i5mowVxNzDZhriLkWzLXEXAfmOmLmg5lPzPVgrifmBjA3EHMjmBuJuQnMTcTcDOZmYm4Bcwsxt4K5lZgFYBYQcxuY24i5HcztxNwB5g5i7gRzJzF3gbmLmLvB3E3MPWDuIWYhmIXE3AvmXmLuA3MfMfeDuZ+YB8A8QMyDYB4k5iEwDxHzMJiHiXkEzCPEPArmUWIeA/MYMY+DeZyYJ8A8QcyTYJ4k5ikwTxHzNJiniXkGzDPEPAvmWWKeA/McMc+DeZ6YRWAWEfMCmBeIWQxmMTEvgnmRmJfAvETMy2BeJuYVMK8Q8yqYV4l5DcxrxLwO5nViloBZQswbYN4gZimYpcS8CeZNYt4C8xYxb4N5m5h3wLxDzLtg3iXmPTDvEfM+mPeJ+QDMB8R8COZDYj4C8xExH4P5mJhPwHxCzKdgPiXmMzCfEfM5mM+J+QLMF8R8CeZLYr4C8xUxX4P5mphlYJYR8w2Yb4j5Fsy3xHwH5jtivgfzPTE/gPmBmB/B/EjMT2B+IuZnMD8T8wuYX4j5FcyvxPwG5jdifgfzOzF/gPmDmD/B/EnMX2D+IsZ7ftqaBJgEMXlg8ojJB5NPTAGYAmIKwRQSUwSmiJhaYGoRUwymmJgSMCXElIIpJaY2mNrElIEpI6YOmDrElIMpJ6YCTAUxlWAqiakLpi4x9cDUI6Y+mPrENADTgJiGYBoS0whMI2Iag2lMTBMwTYhpCqYpMc3ANCNmNTCrEbM6mNWJWQPMGsSsCWZNYpqDaU5MCzAtiFkLzFrErA1mbWLWAbMOMS3BtCRmXTDrErMemPWIWR/M+sRsAGYDYjYEsyExG4HZiJiNwWxMzCZgNiFmUzCbErMZmM2I2RzM5sRsAWYLYrYEsyUxW4HZipitwWxNzDZgtiFmWzDbEtMKTCtitgOzHTHbg9memB3A7EDMjmB2JGYnMDsRszOYnYnZBcwuxOwKZldidgOzGzG7g9mdmD3A7EHMnmD2JGYvMHsR0xpMa2LagGlDTFswbYlpB6YdMe3BtCdmbzB7E9MBTAdi9gGzDzEdwXQkZl8w+xLTCUwnYvYDsx8xncF0JmZ/MPsTcwCYA4g5EMyBxHQB04WYg8AcRExXMF2JORjMwcR0A9ONmEPAHEJMdzDdiTkUzKHE9ADTg5jDwBxGTE8wPYnpBaYXMb3B9CamD5g+xPQF05eYfmD6EdMfTH9iBoAZQMxAMAOJGQRmEDGDwQwm5nAwhxMzBMwQYo4AcwQxQ8EMJWYYmGHEDAcznJgRYEYQMxLMSGKOBHMkMaPAjCJmNJjRxIwBM4aYsWDGEjMOzDhijgJzFDHjwYwn5mgwRxNzDJhjiDkWzLHETAAzgZjjwBxHzEQwE4k5HszxxEwCM4mYE8CcQMxkMJOJORHMicRMATOFmJPAnETMVDBTiTkZzMnEnALmFGJOBXMqMdPATCPmNDCnETMdzHRiTgdzOjEzwMwg5gwwZxAzE8xMYs4EcyYxs8DMIuYsMGcRMxvMbGLOBnM2MXPAzCHmHDDnEHMumHOJOQ/MecScD+Z8Yi4AcwExF4K5kJiLwFxEzMVgLibmEjCXEHMpmEuJuQzMZcTMBTOXmMvBXE7MPDDziLkCzBXEXAnmSmKuAnMVMVeDuZqYa8BcQ8y1YK4l5jow1xEzH8x8Yq4Hcz0xN4C5gZgbwdxIzE1gbiLmZjA3E3MLmFuIuRXMrcQsALOAmNvA3EbM7WBuJ+YOMHcQcyeYO4m5C8xdxNwN5m5i7gFzDzELwSwk5l4w9xJzH5j7iLkfzP3EPADmAWIeBPMgMQ+BeYiYh8E8TMwjYB4h5lEwjxLzGJjHiHkczOPEPAHmCWKeBPMkMU+BeYqYp8E8TcwzYJ4h5lkwzxLzHJjniHkezPPELAKziJgXwLxAzGIwi4l5EcyLxLwE5iViXgbzMjGvgHmFmFfBvErMa2BeI+Z1MK8TswTMEmLeAPMGMUvBLCXmTTBvEvMWmLeIeRvM28S8A+YdYt4F8y4x74F5j5j3wbxPzAdgPiDmQzAfEvMRmI+I+RjMx8R8AuYTYj4F8ykxn4H5jJjPwXxOzBdgviDmSzBfEvMVmK+I+RrM18QsA7OMmG/AfEPMt2C+JeY7MN8R8z2Y74n5AcwPxPwI5kdifgLzEzE/g/mZmF/A/ELMr2B+JeY3ML8R8zuY34n5A8wfxPwJ5k9i/gLzFzErflnxuzUJMAli8sDkEZMPJp+YAjAFxBSCKSSmCEwRMbXA1CKmGEwxMSVgSogpBVNKTG0wtYkpA1NGTB0wdYgpB1NOTAWYCmIqwVQSUxdMXWLqgalHTH0w9YlpAKYBMQ3BNCSmEZhGxDQG05iYJmCaENMUTFNimoFpRsxqYFYjZnUwqxOzBpg1iFkTzJrENAfTnJgWYFoQsxaYtYhZG8zaxKwDZh1iWoJpScy6YNYlZj0w6xGzPpj1idkAzAbEbAhmQ2I2ArMRMRuD2ZiYTcBsQsymYDYlZjMwmxGzOZjNidkCzBbEbAlmS2K2ArMVMVuD2ZqYbcBsQ8y2YLYlphWYVsRsB2Y7YrYHsz0xO4DZgZgdwexIzE5gdiJmZzA7E7MLmF2I2RXMrsTsBmY3YnYHszsxe4DZg5g9wexJzF5g9iKmNZjWxLQB04aYtmDaEtMOTDti2oNpT8zeYPYmpgOYDsTsA2YfYjqC6UjMvmD2JaYTmE7E7AdmP2I6g+lMzP5g9ifmADAHEHMgmAOJ6QKmCzEHgTmImK5guhJzMJiDiekGphsxh4A5hJjuYLoTcyiYQ4npAaYHMYeBOYyYnmB6EtMLTC9ieoPpTUwfMH2I6QumLzH9wPQjpj+Y/sQMADOAmIFgBhIzCMwgYgaDGUzM4WAOJ2YImCHEHAHmCGKGghlKzDAww4gZDmY4MSPAjCBmJJiRxBwJ5khiRoEZRcxoMKOJGQNmDDFjwYwlZhyYccQcBeYoYsaDGU/M0WCOJuYYMMcQcyyYY4mZAGYCMceBOY6YiWAmEnM8mOOJmQRmEjEngDmBmMlgJhNzIpgTiZkCZgoxJ4E5iZipYKYSczKYk4k5BcwpxJwK5lRipoGZRsxpYE4jZjqY6cScDuZ0YmaAmUHMGWDOIGYmmJnEnAnmTGJmgZlFzFlgziJmNpjZxJwN5mxi5oCZQ8w5YM4h5lww5xJzHpjziDkfzPnEXADmAmIuBHMhMReBuYiYi8FcTMwlYC4h5lIwlxJzGZjLiJkLZi4xl4O5nJh5YOYRcwWYK4i5EsyVxFwF5ipirgZzNTHXgLmGmGvBXEvMdWCuI2Y+mPnEXA/memJuAHMDMTeCuZGYm8DcRMzNYG4m5hYwtxBzK5hbiVkAZgExt4G5jZjbwdxOzB1g7iDmTjB3EnMXmLuIuRvM3cTcA+YeYhaCWUjMvWDuJeY+MPcRcz+Y+4l5AMwDxDwI5kFiHgLzEDEPg3mYmEfAPELMo2AeJeYxMI8R8ziYx4l5AswTxDwJ5klingLzFDFPg3mamGfAPEPMs2CeJeY5MM8R8zyY54lZBGYRMS+AeYGYxWAWE/MimBeJeQnMS8S8DOZlYl4B8woxr4J5lZjXwLxGzOtgXidmCZglxLwB5g1iloJZSsybYN4k5i0wbxHzNpi3iXkHzDvEvAvmXWLeA/MeMe+DeZ+YD8B8QMyHYD4k5iMwHxHzMZiPifkEzCfEfArmU2I+A/MZMZ+D+ZyYL8B8QcyXYL4k5iswXxHzNZiviVkGZhkx34D5hphvwXxLzHdgviPmezDfE/MDmB+I+RHMj8T8BOYnYn4G8zMxv4D5hZhfwfxKzG9gfiPmdzC/E/MHmD+I+RPMn8T8BeYvYpZ/pz38bk0CTIKYPDB5xOSDySemAEwBMYVgCokpAlNETC0wtYgpBlNMTAmYEmJKwZQSUxtMbWLKwJQRUwdMHWLKwZQTUwGmgphKMJXE1AVTl5h6YOoRUx9MfWIagGlATEMwDYlpBKYRMY3BNCamCZgmxDQF05SYZmCaEbMamNWIWR3M6sSsAWYNYtYEsyYxzcE0J6YFmBbErAVmLWLWBrM2MeuAWYeYlmBaErMumHWJWQ/MesSsD2Z9YjYAswExG4LZkJiNwGxEzMZgNiZmEzCbELMpmE2J2QzMZsRsDmZzYrYAswUxW4LZkpitwGxFzNZgtiZmGzDbELMtmG2JaQWmFTHbgdmOmO3BbE/MDmB2IGZHMDsSsxOYnYjZGczOxOwCZhdidgWzKzG7gdmNmN3B7E7MHmD2IGZPMHsSsxeYvYhpDaY1MW3AtCGmLZi2xLQD046Y9mDaE7M3mL2J6QCmAzH7gNmHmI5gOhKzL5h9iekEphMx+4HZj5jOYDoTsz+Y/Yk5AMwBxBwI5kBiuoDpQsxBYA4ipiuYrsQcDOZgYrqB6UbMIWAOIaY7mO7EHArmUGJ6gOlBzGFgDiOmJ5iexPQC04uY3mB6E9MHTB9i+oLpS0w/MP2I6Q+mPzEDwAwgZiCYgcQMAjOImMFgBhNzOJjDiRkCZggxR4A5gpihYIYSMwzMMGKGgxlOzAgwI4gZCWYkMUeCOZKYUWBGETMazGhixoAZQ8xYMGOJGQdmHDFHgTmKmPFgxhNzNJijiTkGzDHEHAvmWGImgJlAzHFgjiNmIpiJxBwP5nhiJoGZRMwJYE4gZjKYycScCOZEYqaAmULMSWBOImYqmKnEnAzmZGJOAXMKMaeCOZWYaWCmEXMamNOImQ5mOjGngzmdmBlgZhBzBpgziJkJZiYxZ4I5k5hZYGaByQdzFpiziJkNZjYZ1tlgziZmDpg5xJwD5hxizgVzLjHngTkPTPJTDB7Ht0UU6zMrlK+VVvmCqKyqTBH81batOL26EzhO4ZNv/ob1l5i2pDgtEglTXxieHb/w2GwZmDC8hMkKnHaGrBCyMP2TP8PxfFm06rwtilbO4BHe5etFyPIhC+tDmCfYrhTmyezMlpeosOaWl6jov3F5KTBZNpYXrMMuL6GO5Cf0Jck69oDfzy5dUd4uR/nRysskjl+Gy9b5xaaNKc6P3b3pG373pq+d9jjc8LudvsnPEuiD7bjnp9X2FeOe3rSL9qgXrTp8rCuKViwzETict2Gcw3gWOz5kJZDZ4ZTC3/OdumqZcsGH82vlVf/GdSiUr3CGj+tvRNqNf8szvsTxJY5PTp9w/rMU6twL6ktleQ3lW6dXviCUb5NW+cTy9rdNq3yUCOXbpVd+g1C+PfyxRdXPLfp3GvXulpdueGfnNrefcEK3wzbY+pP2R9818sy93v1h1jIY9t5O2Wo+u4ayHVIvu00ou0/qZbcNZTvCH1tEsT6tQtl9Uy+7XSjbKfWy24ey+6VedodQtnPqZXcMZfdPvexOoewBqZfdOZQ9MPWyu4SyXVIvu3xdPCj1ssvXha6pl80LZQ9OvWx+KNst9bLL+65DUi9bGMp2T71sUSh7aOpla4WyPVIvWxzKHpZ62ZJQtmfqZUtD2V6pl60dyvZOvWxZKNsn9bJ1Qtm+qZctD2X7pV62IpTtn3rZylB2QOpl64ayA1MvWy+UHZR62fqh7ODUyzYIZQ9PvWzDUHZI6mUbhbJHpF62cSg7NPWyTULZYamXbRrKDk+97G6h7IjUyzYLZUemXna1UPbI1MuuHsqOSr3sGqHs6NTLrhnKjkm9bPNQdmzqZVuEsuNSL7tWKHtU6mXXDmXHp152nVD26NTLtgxlj0m97Lqh7LGpl10vlJ2Qetn1Q9njUi+7/DhlYuplNwxlj0+97Eah7KTUy24cyp6QetlNQtnJqZfdNJQ9MfWym4WyU1Ivu3koe1LqZbcIZaemXnbLUPbk1MtuFcqeknrZrcN5mFPhj/b8xzT4e/zj8vxY592x/hLTltSGFy0f3jRneDh+9jzqaU5bKpysPbTLZvnO3/JydeXqytWVqytXV66uXF25unJ15erK1ZWrK1fXKtne/9B2ZbOuDlmsa58s1tUxi3Xtm8W6OmWxrv2yWFfnLNa1fxbrOiCLdR2YxbpyfWGuLpt1yWJdB2Wxrq5ZrOvgLNbVLYt1HZLFurpnsa5Ds1hXjyzWdVgW6+qZxbp6ZbGu3lmsq08W6+qbxbr6ZbGu/lmsa0AW6xqYxboGZbGuwVms6/As1jUki3UdkcW6hmaxrmFZrCu3n5NaXcP/oe0akcW6RmaxriOzWNeoLNY1Oot1jcliXWOzWNe4LNZ1VBbrGp/Fuo7OYl3HZLGuY7NY14Qs1nVcFuuamMW6js9iXZOyWNcJWaxrchbrOjGLdU3JYl0nZbGuqVms6+Qs1nVKFuvK7X/l6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF2p1ZXNZxZz0z5XV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubr8unLvhs/VlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqSq2u4qqf06DuZF0tolifNYtN3aFtLaJ4n1B+enrDX17+dCifwvATofwMKJ+IX36TUP6M9MofF8rPhPLxxz+/Vih/ZlrlC6LS//l/rf/576jy//+X4qo6akF9KYxPVFbli+FvYZ6EukvSa2siYeqLohXLPWah/hLTlhSXrUTC1BeGZ8cvrGdh/ErTGl7B8mld6gwP6wztCdO6tpOFusqq/l1E6qq9fOgr+3lVqMIZhl02Qobtxb+F6VP4P/9dUrpy23HaJsjPUK/9G/ZvdtzD/AnDKYJy06E915SuPC7FkOU7ZcN6VmB8t/IV5eZX1Vkerbr8hTaWR/78wt+95a5EjL+3DiScLNSVZ/7mDRuXGzR5ZjoEv6Bq3JPLyHFV06TMlImizOc1tr3YtD2UL4TfzzQGfy+GcYlMHcnPaZCjX1g1rpn1a1FUF8pFkb+OFzntT47ffWb5teNe3fIbfAdYfh80yy8OO0z38mjV+WDbiPM73/mbnafecMK0TbMPL/H6mfAJWalpdxStvOzhOOAH25Vc3ifB8m6dHSZOt1KTedvOdNcTrCu8iyOz5TX/r7Jo1XUE+9TFZpkshczrS0I7CozfBJbJl0mdUeQvW2E59/pZLIv/znOs3T7VhnGxy44dj2CXmn6iDMpk2k+Eusqd9hSTtofyBzltt9sZXCciZ7h5Tt1smkVOG0M9dnn1yuG2mQ3T9tEfmWmf3r6ZP+3jrLcZrmv/8n3efLk+/937vN/V0D7vV/+hfd6/azuS5jrVNJTH6dYiVtFod9uXxi+bWN7uOsv/ktoyW9327y+zrSqHzNv+helXYPyzdVaUy6uaSGXGhDq8n1EUb95iXXbeVkD5FOZtk1C+Mq3y+Z9UN41Laq+oN/lfXci8aRzGo8D4uTCNy6rqLHfKh+Xf7lPbNtr91eSnRVT956//+YT6wjSr5Qyr2IxHsPVqryhzJTnuwumQHN8GZhp6xw64T9XODDv4C2EaNhbTMCxn3j598tMiivfxjunt9hb77hSW2+Zxt7eh/pLIXx5aRLE+CbU9wfGz29vy9Ia3ZnJ5KY1WXW7bQH047XA4xaYN+em1oV5mx3R5X3nnE7BvaGmWa9xnV+c+7H77qbBcr1/1xwzHPT+0KczbPGhTwmmTHYf8SPdBwWM/YfdPcFh2f3lT6EeuKV/ZJ0Qbkp/WVT+98wYlpH04T+o47UuY8niOBvtYe44m+G3MfEuzX3D3/0Nd3nk+ey4E26r2p71zIXH26zI8ziiO2+/9p48z0pt/+bVUP+sdS9j9LG8ZDtvSIlJXKFtgfOsqVOEMwx5nlDvtxb/hccZuZh/x7zrOYP3w3qYf9tZ57IfD+m/7pGOgH+5o9i+8Pua/f32Mmv2718eoabrrYx0ns+sKWx/t8hX8YWZ9rANt6mKGUcdpL/4N18duf/P6mOG58ubVrc/9Utyvsse1wR8A6/NAsz6reZ+N6ecd+yf/axHF+qytjr8zPGaOvQ0O9ZdEq24/0lnnK8zw2DYmjHul05YKJ7PTuNIZTqUzHK+uWrm6/uN1eX2PPaZPc1kszHDdqVVd3zXZ9F2VkHl9l913C3536LtOMn0XHptg3xVFK6/HwbHrzi2iWJ/i5HyZb8714DwthHqT/9WFzC4D3rqMxzx1TIbLQKjDmw6Vpg0FThvwb2o5DK7MKWf74DT3u1rE7YPtflea81Dud3nTJYxf3fSG11wtC1in3fbWc7JQV/2qfxeRukLZAuMvMvtdOAzbf4UM24t/w/2uc/+m/S67PLK+Z67pewog8/oee646+C2h77nC9D1Y3h4H4bJpj4NSXR+xfIEYTu0Mh1M75nD+rvHJy3A4ec5wMrtGsmJdLoB2qG17GF699IaXH3c7EurPdP3DYZVEGfXrCdV2dU8d9mN2W6b60Lh11eQ8wWlVz7Td60+9e7O8/Zd6JsP1pK7JcB8Er2u1qipUHq06be26luq+a54zzAy3m/XsdhA/IasPdReZrAFk9vxRQ8jsdrcRZAmTNYYM95vtJ9/8G6dDcl48kMJ9azifwvh691jZeZjqvaze9kzV5e3H2nWjiHh771Dwr8O1kLoVfp24DU+INidgGFG06jprr18E/ya0oUFVG8qd4eWR4UVO+6JIT+8EqcvbvuDybKdNXF8P2uTtP1pvtwFs+5OI/HXe1llC2oPLi3e+rcD4T2Be2Xufsd9IkJ9RFG8fFOsK+5m2D8rGcOo7wwnTKPRnuPzjehemeYHxpWUryn1D9osT1dQZfOg32XGH3Y8O/gdnPtk6cdn1rjnaNuOy21D4xinW3wjGId/UgcMqMP43cR03mIi0oS5pcxHxjUwbgv/L6T+9Yz27jfP2rRsag797/Tv6AtO+5ctm2arts3VGkb9/39a0wVsWvWlql8Vipw12/bPbmzplKzuvP/DqSDh1JJz6ve2ZPZcffCW0v3GFP02iaNXrMcmP3eZ4y6U338ujVZfTRibDcnYa1HfGtaEY1+Abi3Gtn4VxxXY2NONT6oxrsVMu+WkRxfvYe2mxjuJo1elSE+fRQv0lpi0pDi+R6jIXxq9ResNrjvdRYV+B91HhtMPh1DdtQBdFqc8/b5uf4fjFnn+h/pJo1WUxnfmn1ovkx86/xukNb6X5h/ee4/zDaedtc+3xW8ixfX/39E9zfU3E6YOTn2xN/4Qpj8PDOkN7wrRu4mShrqZV/y4idYWyBcZvZ7anTaBN9vp/E6e9+Dc8D71V2cptx2mbID9DvfZvdt8cxz2V5THN+RV7eQz1Z2t59JYPtTw2SW94zePMX2xPmNZNnSzU1azq30WkrlC2wPh2ZnlsCm2yy2NTp734N1we9zTLI07bTJdH1T/ifjNeF+lo9kEbQqaOjVbZh4brIvuVrWhz0uBxewNoR3VtO8C0rXaKbQv+DTjePaiMDzvT6Y91dTHjWDuLw6kthsOufx1mpiU+g+Bd/7LTMvgnYFr2rvrdu/5lr+OoZwrtdSq0ecaG86Pec6K23hJSFuu1884rh+uvHaY9pgx2SNXAip36U+gT3XueC6ppH06/UtK+4X9D+xLRqvPQOw9qj+ND+aLIPw627z0IfpQ4l5Bw2oDnK8tjtMFee/LaME60wTunguOVb+ovjvR0sOdUlt+r67ShLFp1OmTaD6m2hGtOx0N/cZLpg7zlQp3fCW1i53fschH8ieL8jrdcYVu9Z+BCmQzXnT3iTHesvyRadTlJZ3/OWw5x/Oz+XGF6w9s9Ycrj8LBOew9HsZOFurx3omBddrsV/CyzP4fDsPe5xL0vPTnc0/+G/QmcP2p5THc4WJe9lsH2J84363IhZPlO2b2qftr+4SLoHx41+xP23jn8vVa08jhab8/1eX0p+lqmfcHPFf25N87YrplknK8Q5zC9Zc97BtGuD+i9Zdubpvaam50G1tt7iYuFT35mkLayda84hfYkP2eQ9rDrimwePwLL4I1mGcT2qX3afDKuuGzgvLXrw/J3N8Gy0Qy23ZEZRi0zrulug7z7V3GZsuug944I7x6C4L1nS7z3o3j3nNlhe9sRnKZ2fyFMo6LIXzdCfQXG3y/2F7zjBNuPxm17ntN22+/afuZ80V9iH2mXVe9Z21LIK5yy4d94b4C1ZWY4mNlzgw2caYDPPdhlx7uOgPfw2PdgedduImc4OE5YzpvHFWL8apM6U51O9pzVf8t0qu2USzj1pLq847mJw8wyXpu0jU037x5WO93Ys2qhPnuu6x2xT+Cdo2rgjJt3zdNedwt1hvOV7P6GUH95xOe9mkb4N3VPUgNSF44rnlu1+wfBf5ri9WrvnsjgvXOvOG1Ce7xp01SUw2nilW0Uox0NRLubOR7PY9v+G6drsxjDrp/FYTdwhu2VU8uW7S/t3+yy7vVNTYzF+dXU2JDFOU9Ym5TFYbJ6G6RZb2ivN43x+kbyg/sVwWW439fC2+/D6W33X7xrMt41ILVM4vwL7bbXV3C6qesatr/F4XjnkOzxue2r7bWGJpB555rssZO3Tql7T1ZzPK7Xdh3E6bOaKIfTvcCMS0O4RlNRZ+X2YP1xxje0gd2fac8HBl+/arje/Zne+vG/7zOq47vkZ7rjvGkWZ/n0rtl528GmpC52L5PdDga/BkwLux30lg+1HVzd8auBsfcy4TisbsqxftXr87FfsH+z64add5jlVVO39+9mYvy8+368/nT59cuqn9nsT3Ha2f5UbYOTn3T7i4po1XnfxGS472KXZW//K25/iteOO5J7G7Fe7/mR4L1nY/Bakz2mwXbUMxl7pjLUHRlXE8sCjo9dFrz7Fr3nKoP39rPwmM72XbhvYZcT9XySd50g7jEcPl85lzz3XV29alnwnvOLMz29ZQeXD/s8TZxnbrHf956Bsfewtnf6ffWMV008o47TyC6PavlKflI9/xCmSUW0at9c12Q4jcMwveUL3x0w2TxrjO+CSZCfoa32b3bdUe+hKYcy+U4b7TNmuD+I+y3dzL6Yd29Gbadee2/GYNi/O9TsC3nv4Ck3/66ufwwuw+Wxmbc84rtO7PIY990oqn/B81Pq/Qb22MN7z0YiWnV+pto/4rFHP/McObbVLsuVMM7Wlpn2qelmlwlcF4uIt/1Z8MOhP4vzjB62ayap80ixb+xtD9Q1suq2B/Ycr7c98JYj3Kfx/sa2B7ZvscNk8w6XN7tseedivb4l7jtObR/ntcPbluL1lXKTsfdKhboj4zLrZ/KL/8n9jL3upfoZ75pw3H4G3/e3N3l3GNbr3Xunpo9aduJOn3JnvO37bLBcCRkO217ad84Ff2bM/bAw7AyXx0Q23xWU/KR6zGS3bdgHlpvMe7dQtrd7LWO8pzr8G9/Va60dr3KnXMKUS6ft+dD2BqbtdUXb7XVBb57Emed2vHH7hMs+1nFm1U97DHK12L56+/9qPa9u/z+0R11/9MrZZ6qS/3nPxqjzYt6zC41E2/DYxN6b3wiGYW2ZsfY8l3ftyBtnLGefX0p+WkTVf/A99mEcaol22GeGb4dlI7zHXrU1Ea18vdJ7hgDL2f44+LvFMmnne/JzKvwt1flur5l6873YaXsKxzmNvGeOwsd7f4h9ZgPPo9pjYTxvZ+/Bxk+++TeOT3I6r2G2e5FTl9fH2fft2nW1rjNe3r2XrFz4dz1RTzkZHutHcVrYft47D4jfcRGcvT/C+xmZ+sLH7g9iXfbcAh7nee1vZ9qP2xw8t/Ci2f/3jsfKnXrt8difcG7hFXNuwTvG8d71k/y0iOJ91PTO8H1Nsb9fItRfYtqS4vCW33ft7Z959/V4z5SnMLyVvl8C9xfbQH3efT3eelTdcjit6md1y+F7KS6HoV67HH4Cy+GHpk7vWDXuOl8O7bHfHVTdPpk9XvPeXYPePjMU/BfiPIp3DkPdE1bdNQJ7bI7Lg902YrkSMhxv/9Pb1gf/XcxjL3xOP9QTskyPvXAa2WMvtU+b/KT63gx7nhv3ReqZzHteUi2LuNzbZdzbRuL66G3b2T2A2Th+seuK995Sta4EX1BVkVpXUj0mqgV15o6JcsdEaBvCsvF3HhM1Fcvkf+KYyLtfzR4L2HcseNPHOxZg5cK/1bFAhVMuw/3Ef+zxWxifuMdv2d52vBjjmoLqf8ocb+99jiL/vUu2T6kNw7DWfsdwGYyDHaZ9TjrYbaomgvedFSksS+5z0vZ5Km86evuvCWd88p06ziTjtL3oU7zvVlHz0tvnxvGy38+F1yjtedI6MIzq5jvur9thsu/y3N3MyzSP59x5WUHGJZiDnPbZf4fxLnPqyXcyr2+w14txuh1EMm9623sE1Hda1yHjg8Pw+vtQzjsew+sE4bvMvWuM7JnvfZ1l3Du+sM8Mpnd8UeAeX+D8sccX3nOb6O16pp67S/4e9kUrolXngf3uEO+aRsJpg7efa7cR3vcfJsf1PnMMrZ5r9doR2l9EvL0HJvgeznGBtwwnyPCwffg39e4DW6/3PZHquiquh972kC0LCVK/fdbMPleLv6f6HWxYvpjUhdsjnIZ2exT8YLE98raJCad9dlqi97bz3rSx041993mo29ZZE30Ijr/tQ9S4Jj922njbdtye2D4Et2HqfgX2/h4cTtw+BJeha6ombGbTdcIbCWhLqDvfkQXmZzATquYJjnP4WRCjHUse/eGVBR22Gubt54d5VJpB/astHLBot6WfLa2u/uTydZTYRoVymb3XpCCB7Q+ffPM3rP+/670mBcuX81Tfa+J9z0moy3tWHesqWj70lf2MqvlZEa26ntlrSkVOe71zWMnhnmqWk7/rvSa2zwrtOcu8Pxsz7zjFbmuCP7d8Rbk5Vb+XR6tu20Ib8Rn5fCe39V8Qc78z/F4T2wyc9nHeQ6C2p94y471nxVv+DjKZXebx94QznLj35XjLSbp96fW1F+957yXFPWuqry4sWO28Fjf27lhd/eGY1U5/LIPvM8l3PB4bob8J1oFbYNkJf7PDS/7tfuFS7Q8KzN9KHJ/v+DDsUseHjO0vocHphXWVkOHdB/1E8oP7N6F8hTN83LeMSLu9Y4yEU1e+8zfsr+8wy31627YoYfcT7PYJ952mwzDYu1Qegf7wqYrU6iwgdT4OdT4LfSyaUIf3M4ribaewrtOilYdjz4F4P+MOB+vC8U/+533PCq4/7P08bD/CTtPgX4Bpar+Pw9uvwnW2bYw2lMRow8vOsbvdd0p+8L6CV01bvfcuFYlhB78E+sQyc95AvUMqZLUrVpR/02yPS0jb3zZtL3XajsO261jw70Hbiyv8OiMyPez1/NC/sPMu7PukPxLXY713omC7ZpI6PxXnBbxjX7UfU92xrz0v4N0/Hnc+2XOSwX/tjE+G1xXy1fTIF+NQ3fSw319ZKurC7aqd594yE/xPsNz+GGMZxj4Q9z9s/2OXYWvsehT8b6IPrA1lvHnO1os/Ybwi8y4x3L6cHq3qvGlv+5/lfS30P/kx+gCv/y4T44X9lXcuvwicnX/eue6454OwP39V9NG47bXTKGQVVWWS+SJRPoxXJvv5i2p9/v3Tjw2aWVPHEd89N2bNRusUnlhT9X9Q3LlN3m3Tm9dU/bduu8mOdbqtNymVc1ZYf/ITrv1h2fZVP4ujVedrIka7qj6tvXNEKZQfEMoXpVe+XyhfK73yI0L54vTK9w/lS9Ir3yaUL02v/KhQvnZ65XcM5cvSK9/C2y6nUP7wUL48vfLDvWvUKZQfF8pXple+j3f/dgrlh3r33qRQfrR3D3QK5Y/2nt1Iofww73uhUijf196nlmL5Y73vikmh/Ejvu1hSKD82lG+aXvkxoXyz9Mr3CuVXS6/8wFB+9fTKbxb2RdaAPyaqfoa614S/p7DPvhNuk8LHuz4S6i8xbUlxeMuvj6xphmfHL2x3w7g3d9pS4WQJ83tzZzjNneF4dRVmsa6iLNZVK4t1FWexrmxOr5Is1lX6D60rm/Mxm+2qncW6yrJYV50s1lWexboqslhXZRbrqpvFurI57bPZ52Rz+aqXxbrqZ7GuBlmsq2EW68pm/5XNZTWby0SjLNb1T+2/GmexriZZrKtpFutqlsW6srkOZbOfyOb0yta+XPJzRhbrmpGlurLdT2SzL1ztH1pXNreP2TxWyOZy/0/dduSWr//+5Sv5yVZfmPzdnk9KVP0b78nA+yVOgxz9k+b6b5r36+zq3R8RhuFdQ0il7oSpL4r881Sh/jJneKFdJU4W5zrRurPefrPR9KF9EqZ8aIv9m73u792L7p3z8q53pDCtdlTPFuH18ShadZolPzj/QxuSplXByu0rTrN9caYf1u9do+4KLpV5UeEMJy+LdeWnWVfdaOVlFNfDTK5tXnXfGY+e8PGuDWvq2unJ3TZ+ruzGhvVrqv4hC7Z69v7VX59eXf3hvEmvXn1HjB3ev8+oo3v1Gzyg3xGDq/5ebMqkuMwmip32xy8/pV2xrTCl8gXtwjqXSfvt8plC+eXLJd674j27Z+9xsWWSuXdveDDJdQPfCWaPJ/E+bHWvVYbj2y7D507c++zxmsb/VyvXjZl3n2Ryeuxe9XuGy0O7zKZPwf/uq7FlICzre6VV94p1rTX8sUUU7xPKtkm97PL7jfep+kPuuaR/x3NJ61X99J4LaW2GkcpzSWuZttf0c0mZrrPePI1il48S1T3vsqn5O2b5Ee8v7PHIVlBui6rf4z4Xpe6vDmW3rfqZXD72r/rd669DXdl4LqoLDAfbkvzYY1Vvn9FbVsLfveMKb//Wu8e/jckyeS5qLzOOcZaTKFp1fPFnKBPqjaJVxxczvL/TPtuD98XmO3XVMuWC71D103sOCo9R7PBxWYxIu73n2xNOXfnO37Av2gvanOEzyu0SZpipPqPc2bTVrrMtIv2p6WeU495PWpPPvXWr+pmctt2rfq/uubdBwqW6vflve+5tYNXPf/Jzb72qfs/Gc2/hXGivXuP6DD28f58xA3r1H9BvRP8B/V+qSv6zR7ST2md2RBu1z2wPOsrP8Gzl8rW0DZT3nmar7og2AaYdmHamXd6WPwzbbjFxGN5RSKg72ZtUwu/4hlK7BU9n3qS5bC0/OsTh45FF8rMX+BZVP7fo32nUu1teuuGdndvcfsIJ3Q7bYOtP2h9918gz93r3h1nLooyODPPC0d3D8Eec594d/HtBm709ohZRrE/uDv4qn7uDP63yuTv4q3zuDv60yufu4K/yad7Bf1yGd/BvEsqvkV75gd5d/imU38zeRR/qSH6KTV0pbutjP0HQour3EtOWFIeX8MZdXTkP476W05YKJ0uY39dyhrOWMxyvrsIs1lWUxbpqZbGu4izWlc3pVZLFukr/oXVlcz5ms121s1hXWRbrqpPFusqzWFdFFuuqzGJddbNYVzanfTb7nGwuX/WyWFf9LNbVIIt1NcxiXdnsv7K5rGZzmWiUxbr+qf1X4yzW1SSLdTXNYl3NslhXNtehbPYT2Zxe2dyXWy2Lda2exbqy2U9ksy9c4x9aVza3j9lcvrK53P9Ttx255evfsXxlsy8M55O86xvJT4so3ieUxbeZhb97d5QUGP+QaYf9NoYWUazPrurNmxnetR77CQS8094OL7SrxMnSeQLBu/OH3VGSiPy3n3nnzLzrLSlMK/cJBPutBbhcFJsM173QhuS0e9K0L90nJOJMP6zfu3PK3jkYd15UOMOJc0dX3Lry06wrPIHgPTGT+V1F49snoA3JT6p3FT1R9bOm7yoKf/+n35X2YtXPf/Jdac9Am8NwRw/oM6rf4EX5Kw/pP3MXy4nDi22FKZXPH57ZFit/Q+/KfArjv3y42BthW0K9+cbZMthz4L3zbYjJ5G4YNO3BtCdmbzB7E9MBTAdi9gGzDzEdwXQkZl8w+xLTCUwnYvYDsx8xncF0JmZ/MPsTcwCYA4g5EMyBxHQB04UY/G63g4jpCqYrMQeDOZiYbmC6EXMImEOI6Q6mOzGHgjmUmB5gehBzGJjDiOkJpicxvcD0IqY3mN7E9AHTh5i+YPoS0w9MP2L6g+lPzAAwA4gZCGYgMYPADCJmMJjBxBwO5nBihoAZQswRYI4gZiiYocQMAzOMmOFghhMzAswIYkaCGUnMkWCOJGYUmFHEjAYzmpgxYMYQMxbMWGLGgRlHzFFgjiJmPJjxxBwN5mhijgFzDDHHgjmWmAlgJhBzHJjjiJkIZiIxx4M5nphJYCYRcwKYE4iZDGYyMSeCOZGYKWCmEHMSmJOImQpmKjEngzmZmFPAnELMqWBOJWYamGnEnAbmNGKmg5lOzOlgTidmBpgZxJwB5gxiZoKZScyZYM4kZhaYWcScBeYsYmaDmU3M2WDOJmYOmDnEnAPmHGLOBXMuMeeBOY+Y88GcT8wFYC4g5kIwFxJzEZiLiLkYzMXEXALmEmIuBXMpMZeBuYyYuWDmEnM5mMuJmQdmHjFXgLmCmCvBXEnMVWCuIuZqMFcTcw2Ya4i5Fsy1xFwH5jpi5oOZT8z1YK4n5gYwNxBzI5gbibkJzE3E3AzmZmJuAXMLMbeCuZWYBWAWEHMbmNuIuR3M7cTcAeYOYu4Ecycxd4G5i5i7wdxNzD1g7iFmIZiFxNwL5l5i7gNzHzH3g7mfmAfAPEDMg2AeJOYhMA8R8zCYh4l5BMwjxDwK5lFiHgPzGDGPg3mcmCfAPEHMk2CeJOYpME8R8zSYp4l5BswzxDwL5llingPzHDHPg3memEVgFhHzApgXiFkMZjExL4J5kZiXwLxEzMtgXibmFTCvEPMqmFeJeQ3Ma8S8DuZ1YpaAWULMG2DeIGYpmKXEvAnmTWLeAvMWMW+DeZuYd8C8Q8y7YN4l5j0w7xHzPpj3ifkAzAfEfAjmQ2I+AvMRMR+D+ZiYT8B8QsynYD4l5jMwnxHzOZjPifkCzBfEfAnmS2K+AvMVMV+D+ZqYZWCWEfMNmG+I+RbMt8R8B+Y7Yr4H8z0xP4D5gZgfwfxIzE9gfiLmZzA/E/MLmF+I+RXMr8T8BuY3Yn4H8zsxf4D5g5g/wfxJzF9g/iLmf/9hfrcmASZBTB6YPGLyweQTUwCmgJhCMIXEFIEpIqYWmFrEFIMpJqYETAkxpWBKiakNpjYxZWDKiKkDpg4x5WDKiakAU0FMJZhKYuqCqUtMPTD1iKkPpj4xDcA0IKYhmIbENALTiJjGYBoT0wRME2KagmlKTDMwzYhZDcxqxKwOZnVi1gCzBjFrglmTmOZgmhPTAkwLYtYCsxYxa4NZm5h1wKxDTEswLYlZF8y6xKwHZj1i1gezPjEbgNmAmA3BbEjMRmA2ImZjMBsTswmYTYjZFMymxGwGZjNiNgezOTFbgNmCmC3BbEnMVmC2ImZrMFsTsw2YbYjZFsy2xLQC04qY7cBsR8z2YLYnZgcwOxCzI5gdidkJzE7E7AxmZ2J2AbMLMbuC2ZWY3cDsRszuYHYnZg8wexCzJ5g9idkLzF7EtAbTmpg2YNoQ0xZMW2LagWlHTHsw7YnZG8zexHQA04GYfcDsQ0xHMB2J2RfMvsR0AtOJmP3A7EdMZzCdidkfzP7EHADmAGIOBHMgMV3AdCHmIDAHEdMVTFdiDgZzMDHdwHQj5hAwhxDTHUx3Yg4FcygxPcD0IOYwMIcR0xNMT2J6gelFTG8wvYnpA6YPMX3B9CWmH5h+xPQH05+YAWAGEDMQzEBiBoEZRMxgMIOJORzM4cQMATOEmCPAHEHMUDBDiRkGZhgxw8EMJ2YEmBHEjAQzkpgjwRxJzCgwo4gZDWY0MWPAjCFmLJixxIwDM46Yo8AcRcx4MOOJORrM0cQcA+YYYo4FcywxE8BMIOY4MMcRMxHMRGKOB3M8MZPATCLmBDAnEDMZzGRiTgRzIjFTwEwh5iQwJxEzFcxUYk4GczIxp4A5hZhTwZxKzDQw04g5DcxpxEwHM52Y08GcTswMMDOIOQPMGcTMBDOTmDPBnEnMLDCziDkLzFnEzAYzm5izwZxNzBwwc4g5B8w5xJwL5lxizgNzHjHngzmfmAvAXEDMhWAuJOYiMBcRczGYi4m5BMwlxFwK5lJiLgNzGTFzwcwl5nIwlxMzD8w8Yq4AcwUxV4K5kpirwFxFzNVgribmGjDXEHMtmGuJuQ7MdcTMBzOfmOvBXE/MDWBuIOZGMDcScxOYm4i5GczNxNwC5hZibgVzKzELwCwg5jYwtxFzO5jbibkDzB3E3AnmTmLuAnMXMXeDuZuYe8DcQ8xCMAuJuRfMvcTcB+Y+Yu4Hcz8xD4B5gJgHwTxIzENgHiLmYTAPE/MImEeIeRTMo8Q8BuYxYh4H8zgxT4B5gpgnwTxJzFNgniLmaTBPE/MMmGeIeRbMs8Q8B+Y5Yp4H8zwxi8AsIuYFMC8QsxjMYmJeBPMiMS+BeYmYl8G8TMwrYF4h5lUwrxLzGpjXiHkdzOvELAGzhJg3wLxBzFIwS4l5E8ybxLwF5i1i3gbzNjHvgHmHmHfBvEvMe2DeI+Z9MO8T8wGYD4j5EMyHxHwE5iNiPgbzMTGfgPmEmE/BfErMZ2A+I+ZzMJ8T8wWYL4j5EsyXxHwF5itivgbzNTHLwCwj5hsw3xDzLZhvifkOzHfEfA/me2J+APMDMT+C+ZGYn8D8RMzPYH4m5hcwvxDzK5hfifkNzG/E/A7md2L+APMHMX+C+ZOYv8D8RcxKX2mQ55sEmAQxeWDyiMkHk09MAZgCYgrBFBJTBKaImFpgahFTDKaYmBIwJcSUgiklpjaY2sSUgSkjpg6YOsSUgyknpgJMBTGVYCqJqQumLjH1wNQjpj6Y+sQ0ANOAmIZgGhLTCEwjYhqDaUxMEzBNiGkKpikxzcA0I2Y1MKsRszqY1YlZA8waxKwJZk1imoNpTkwLMC2IWQvMWsSsDWZtYtYBsw4xLcG0JGZdMOsSsx6Y9YhZH8z6xGwAZgNiNgSzITEbgdmImI3BbEzMJmA2IWZTMJsSsxmYzYjZHMzmxGwBZgtitgSzJTFbgdmKmK3BbE3MNmC2IWZbMNsS0wpMK2K2A7MdMduD2Z6YHcDsQMyOYHYkZicwOxGzM5ididkFzC7E7ApmV2J2A7MbMbuD2Z2YPcDsQcyeYPYkZi8wexHTGkxrYtqAaUNMWzBtiWkHph0x7cG0J2ZvMHsT0wFMB2L2AbMPMR3BdCRmXzD7EtMJTCdi9gOzHzGdwXQmZn8w+xNzAJgDiDkQzIHEdAHThZiDwBxETFcwXYk5GMzBxHQD042YQ8AcQkx3MN2JORTMocT0ANODmMPAHEZMTzA9iekFphcxvcH0JqYPmD7E9AXTl5h+YPoR0x9Mf2IGgBlAzEAwA4kZBGYQMYPBDCbmcDCHEzMEzBBijgBzBDFDwQwlZhiYYcQMBzOcmBFgRhAzEsxIYo4EcyQxo8CMImY0mNHEjAEzhpixYMYSMw7MOGKOAnMUMePBjCfmaDBHE3MMmGOIORbMscRMADOBmOPAHEfMRDATiTkezPHETAIziZgTwJxAzGQwk4k5EcyJxEwBM4WYk8CcRMxUMFOJORnMycScAuYUYk4Fcyox08BMI+Y0MKcRMx3MdGJOB3M6MTPAzCDmDDBnEDMTzExizgRzJjGzwMwi5iwwZxEzG8xsYs4GczYxc8DMIeYcMOcQcy6Yc4k5D8x5xJwP5nxiLgBzATEXgrmQmIvAXETMxWAuJuYSMJcQcymYS4m5DMxlxMwFM5eYy8FcTsw8MPOIuQLMFcRcCeZKYq4CcxUxV4O5mphrwFxDzLVgriXmOjDXETMfzHxirgdzPTE3gLmBmBvB3EjMTWBuIuZmMDcTcwuYW4i5FcytxCwAs4CY28DcRsztYG4n5g4wdxBzJ5g7ibkLzF3E3A3mbmLuAXMPMQvBLCTmXjD3EnMfmPuIuR/M/cQ8AOYBYh4E8yAxD4F5iJiHwTxMzCNgHiHmUTCPEvMYmMeIeRzM48Q8AeYJYp4E8yQxT4F5ipinwTxNzDNgniHmWTDPEvMcmOeIeR7M88QsArOImBfAvEDMYjCLiXkRzIvEvATmJWJeBvMyMa+AeYWYV8G8SsxrYF4j5nUwrxOzBMwSYt4A8wYxS8EsJeZNMG8S8xaYt4h5G8zbxLwD5h1i3gXzLjHvgXmPmPfBvE/MB2A+IOZDMB8S8xGYj4j5GMzHxHwC5hNiPgXzKTGfgfmMmM/BfE7MF2C+IOZLMF8S8xWYr4j5GszXxCwDs4yYb8B8Q8y3YL4l5jsw3xHzPZjvifkBzA/E/AjmR2J+AvMTMT+D+ZmYX8D8QsyvYH4l5jcwvxHzO5jfifkDzB/E/AnmT2L+AvMXMSt+WfG7NQkwCWLywOQRkw8mn5gCMAXEFIIpJKYITBExtcD8v+7OLDaqKozjZ+ZOy7SdtnSZUijQYV/KWvZ96ca+71sp7VAGKNU6VAwJkYRoTDDy5Js+aAyJCSFRND4oxkQ00WB40mhIeDEh0cQnffBNb5hv+ufr+U/vnetEwnm5d+75fd/5zved853be5KeUYSJAhMlTAkwJYQpBaaUMGXAlBEmBkyMMOXAlBOmApgKwlQCU0mY0cCMJkwVMFWEqQammjA1wNQQphaYWsLEgYkTpg6YOsKMAWYMYeqBqSfMWGDGEmYcMOMI0wBMA2HGAzOeMBOAmUCYicBMJEwjMI2ESQCTIMwkYCYRZjIwkwkzBZgphJkKzFTCTANmGmGmAzOdMDOAmUGYmcDMJMwsYGYRZjYwswnTBEwTYeYAM4cwc4GZS5h5wMwjzHxg5hNmATALCLMQmIWEaQammTCLgFlEmMXALCbMEmCWEGYpMEsJswyYZYRZDsxywqwAZgVhVgKzkjCrgFlFmNXArCbMGmDWEGYtMGsJsw6YdYRZD8x6wmwAZgNhNgKzkTAtwLQQphWYVsK0AdNGmHZg2gnTAUwHYTYBs4kwm4HZTJgtwGwhzFZgtgLjALMNmG1Ez3ZgthNmBzA7CLMTmJ2E2QXMLsLsBmY3YfYAs4cwe4HZS5h9wOwjzH5g9hPmADAHCHMQmIOEOQTMIcIcBuYwYY4Ac4QwR4E5SphjwBwjzHFgjhPmBDAnCNMJTCdhTgJzkjBdwHQR5hQwpwjTDUw3YXqA6SFMEpgkYU4Dc5owvcD0EuYMMGcIkwImRZizwJwlzDlgzpH8cx6Y84qxndLsPk8YT6U12FmTzig50RhPGhVbgp2u7ESxT9mn6hnqL1G2+PRFKKT0SXu6f/KJw3aicUjVeT3RWPzvXiX3xczw2Babp+vgc0t2/RK/o10+/L4t4PmjjQFPYnZyxQFtwtOj2Rh81seQ7bRm7CPT5fXkZ9FVyJigr/SJ3noMYt1/MTdQv54bot8t55RcEdRJTnX1d8F9N8i4pU/lcGOG/BpW/UwYL8XpCzZXTaiatC/3xjz7p1afzMDP8qnV8o6Ip563gD4/MXN1uL74TOXrfM971nNTTlHXOiXOtlxgfNgfUe2lYM7cdfzZhCe7I49z8is1dzGmfvK8WySm4oNSxSSMt2LLtaIrpn5Lve06kp2VFjv1+lAGv8XHODeLFC9zuRh4ZHRMhH8ZYvK1inNE9QftckuLBxvKPNhwGWz4Vs0f7YeE8VKGv8Oij12/XHHstuOYLvZg+1VnSO5jyHnI4JjS8h+B/DU1J2LE9teU7eUW21G2SLUt/BvQ9m2i0xB/oP6QeTrP2/hyZYPwb1pir3Viv8pBZxnReQN0fqd0ypqD/bLNUXk+2sJXWvpVoWxAWa9xCqv+CP+2pT9RSxv5vPvZ/OHk6MNI/pD+VJjh8dK6RC5ihsfcNmaEfxfG7TsexjDmUHxH1PlLj2HN6Hkk/Hs5cmgFyNhizubFB9Cvm5l72/ok6z1yNt/r/CN1t6CdDz3kgBg8E9/EcvQL85Vt3SsG7jbJydh+cY72bfkJc70tR+ParX0kdZ9CfO/nkJd+lSpdUu99fl7O/ltnB/rhWMiIugrzReZGvw/KWpYwucsv9/768c6W5r4qJe8WyVOlAfTfvPvWvauP18YLpf/1Q00/xG7Hawqlv+Hz5IN1D397WCj9D0b9/uf33/TeKJT+X6O72sKfXG8slP6zd5rvfzn+5+sj6Zd815Ps7u97of+lZOeZ1IX0xMzTqJLwN4tMCDOlf/lXO6JaoS950xHsS8IT+0UmD/lsRmwFedtXBf1VEmXcrFcB95Ug45Y20BdSde2WdgP2qU3k88usJlxthrePXy/cPtZnftveiHAs4Zucza/G8ixk0aN9g3FIZK41C81PjY+WvNJUt7R/5+C1R/tuXal9f9bjyvo/Lq4e/Pthv+5LOIftsRw2xCz9Qf8EW9kudQRd2SZkroVe2bJfLdJPctKkzO/nJSflOf/CAeefNSfZ5mKunGTbKZE8NFK+wpwkugPm6fZCfvGVnNSAAmbIT0WGz+WIYutApoboKzYj5waH2DE2c2/bwXRLwngqIVs7IUs7tjyGfvu/c1Uicy10rhqXue9JDSS706nBZOe/CSvZmxzofPFifzqVvJAWT0RBSjT6nf1uye+73NN/vxllC+rNNpi5RixyIfI7rK65WP0cn8UsdaKzOnNFe6Uf8p0DozGYHEjLKBAfxqG9fFaQ2vzkrTGIw73o1Sud8dGGFJw5uujY6v0dvVL6aD/E7LDFW2JZC8/iqm4olun+zoGuntSlKmUlfm33Ew2Rz3d3WuTz3GlybKMBdxelXzYP6ryLO+552JI93Ni2u1liaVcztiwRVr8j6rnjgbWNGqmz7WJquZF2JXGXWxftd737pnXpHVk9PoLGqNrSptj2DzxqsdCle5IA","debug_symbols":"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+LzwauAV57fXwKuBVwOvOL+9Bl4NvBp4NZfrwquBV1NcF14NvBp4NcV14dXAq4FXU1wXXg284vz2mua6rK+G9RXnt9c012V9NayvZrjucF3WV9/97Z/f2DvPq+ad51VDf3DoDw79wXn7g/2887z6eed59fPO8+rnnefVnN/ez8urfl5e9fPyqjm/vZ+XV/28vOrn5VU/77yJfl5e9fPyqjm/vZ/gusF1X179/5rrLq67uO7Lq34W111c9+VVP4vrLq67uO7Lq342191cd3Pdl1f9bK67ue7Lq+b89n42191c911fNee395NcN7nuu77qJ7luct13fdXPO8+rn3eeVz/vPK9+3nle/bzzvPp553n1887z6ued59XPO8+rn3eeVz/vPK/m/PZ+Lp/35VU/L6+a89v7uXzel1f9vLzq5/J5X1718/KqOb+9n+K6xXVfXjXnt/dTXLe47surforrFtd9edVPc93mus11m3+/zXWb6zbXbf79Ntcdrvvyqjm/vZ/husN1h3+/w3WH6w7XfddXHe95Mv+/Dl4vXv/jZMc7z6vjnefV8c7z6njneXW887w63nleHe88r453nlfHO8+r453n1Zzf3gGvAl4FvOL89g54FfAq4FUsPi+8CnjF+e0d8CrgVcArzm/vgFcBrwJexea68CrgVWyuC68CXgW8iuS68CrgVcCrSK4LrwJecX57R3Ld5Lrv+qo5v73jcN3Ddd/1VcfhuofrvuurjneeV8c7z6vjnefV8c7z6njneXW887w63nleHe88r453nlfHO8+rv/vbf/ZA9t/+9v3zuh5eB68Xrzevk9eH15fXxevmNddtrttct7luc93mus11m+t+efX7Gb+8+rye9/X3+dXn9cvJgFcBrwJexXueTAe8CngV8Cre82R6wasFrzi/vde7/6oX66vF+orz23u9+696sb5arK9WcN3guqyvOL+9F7xa8GrBK85v7wWvFrxa8GotrguvFrxa7/P2/tvf/nl9ef3++13warG+Wm892AteLXi1WF+ttx7sBa8W66v11oO94BX725v97c3+9l7wiv3tzf72Zn97L3jF/vZmf3sveMX+9mZ/e7O/vRe8Yn97s7+92d/eC16xv73Z396L9RX725v97c3+9l6sr9jf3uxvb/a392J9xf72Zn97r/e8vl7veX293vP6ehW/q+L3XPyei99V8f0Wv+fm99z8rprvt/k9v/3B5vz2Xs11m+s2122+3+G6w3WH6w7f73Dd4brD72q47nDdtz/Y+93P0Pt9ftX7fd7e++0P9n73M/R+n7f3fvuDvd/9DL3f51fN+e3N+e3N+e29g+sG1w2u++6/6h1cN7juu/+q99sf7P32B3u//cHeb3+w99sf7A2v9tsf7P32B3u//cHeb3+w2d/e7G9vzm9vzm9v9rc3+9ub89ub89ub/e29N5/37Q82+9ub/e3N+e3N+e3N/vZmf3tzfntzfnuzv713ct23P9gbXrG/vdnf3uxv7w2v2N/e7G9v9rf3hlfsb2/2t/eGV+xvb/a3N/vbe8Mr9rc3+9ub/e294RX725v97b3f/mDvtz/Y++0P9n77g73f/mDvtz/Y++0P9n77g73f/mDvtz/Y++0P9qYeZH97s7+92d/em3qQ/e3N/vZmf3vv4fO+/cFmf3tv6sE9XBdecX57b+rBfJ+3N+e3N+e3d77P2zvf5+3N+e2dPL9Knl8lvEp4lTy/Sp5fJbxKeJU8v8rguvAqqQeT51cZXPftD3ZSDybPr3Jx3bc/2Mnzq1xc9+0Pdr79wc63P9j59gc73/5g59sf7Hz7g51vf7Dz7Q92vv3Bzrc/2Pn2BztZXyW84vz25vz2TtZXCa84v705v72T9VXCK85v72R9lfCK89ub89s7WV8lvOL89ub89k7WVwmvOL+9k/VVwivOb2/Ob+9kfZXwivPbm/PbO1lfJbzi/PZOnl8lz6+yuC7rq+T5VfL8Kovrsr5Knl9lc923P9j59gc73/5g59sf7Hz7g51vf7Dz7Q92vv3Bzrc/2Pn2Bzvf/mDn2x/spB5MeJXwKuFVUg8mvDrw6sCrw/OrA68OvDrUgwdeHXh14NWhHjzw6sCrA68Oz9sPvDrw6lAPHnh14NWBV4d68MCrA68OvDo8vzrw6sArzm9vzm/vw/rqsL7i/Pbm/PY+rK8O6yvOb+9DPXhYX523P9jn7Q/2efuDfd7+YJ+3P9jn7Q/2efuDfd7+YJ+3P9jn7Q/2efuDzfntzfntfeDVgVec396c394HXh14xfntfeDVgVec396c394HXh14xfntzfntfeDVgVec394HXh14dXjefuDVgVcHXh2etx94deDVgVeH5+0HXh14xfntfXjeflhfHdZXnN/eh+fth/XVYX11eN5+eN5+WF+dtz/Y5+0P9nn7g33e/mCftz/Y5+0P9qE/eOkPXvqDl/7gpT/I+e194dWFVxdecX57X3h14dWFV5fnVxdeXXjF+e194dWFVxdecX57X3h14dWFV5fnVxdeXXh1ed5+4dWFVxdeXZ63X3h14dWFV5fn7RdeXXjF+e19eX51WV9d1lec396X51eX9dVlfXV53n55fnVZX136g5f+4KU/eOkPXvqDl/7gpT946Q9e+oOX/uClP8j57X3h1YVXF15xfntfeHXh1YVXl/7ghVcXXnF+e194deHVhVec394XXl14deHVpT944dWFV5f+4IVXF15deHXpD154deHVhVeX/uCFVxdecX57X563X9ZXl/UV57f35Xn7ZX11WV8Vz9uL5+3F+qroDxb9waI/WPQHi/5g0R8s+oNFf7DoDxb9waI/yPntXfCq4FXBK85v74JXBa8KXhXP2wteFbzi/PYueFXwquAV57d3wauCVwWviv5gwauCV0V/sOBVwauCV0V/sOBVwauCV0V/sOBVwSvOb++iP1isr4r1Fee3d9EfLNZXxfqq6A8W/cFifVX0B4v+YNEfLPqDRX+w6A8W/cGiP1j0B4v+4Hd/+/c1nxdeFbwqeMX57V3wquBVwasqPi+8KnjF+e1d8KrgVcErzm/vglcFrwpeVXNdeFXwqugPFrwqeFXwqugPFrwqeFXwqugPNrxqeMX57d30B5v1VbO+4vz2bvqDzfqqWV81/cGmP9isr777239/Y3/72z+vD68vr4vXLyf/zm//fb1eTn73t39fL15vXvN54VXDq4ZXnN/eDa8aXjW86s3nhVcNrzi/vRteNbxqeMX57d3wquFVw6tOrguvGl51cl141fCq4VUfrguvGl41vOrDdeFVwyvOb+8+XJf1VbO+4vz27st1WV8166u+XPdyXdZX3/3tn9/YO8+r+53n1U1/sOkPNv3Bpj/Y7zyv7neeV/c7z6v7nefVnN/eDa8aXjW84vz2bnjV8KrhVTefF141vOL89m541fCq4RXnt3fDq4ZXDa96uC68Gng173kyPfBq4NXAq3nPk+mBVwOvBl7Nw3Xh1cArzm/vYT/DsL4a1lec397DfoZhfTWsr2ZxXfYzDOureed59bzzvHreeV497zyvnneeV887z6vnnefV887z6nnnefW887x63nlezfntPfBq4NXAK85v74FXA68GXk3yeeHVwCvOb++BVwOvBl5xfnsPvBp4NfBqDteFVwOv5nBdeDXwauDVXK4LrwZeDbyay3Xh1cArzm/vuVyX9dWwvuL89p7iuqyvhvXVFNctrsv6at55Xj3vPK+ed55XzzvPq+ed59XzzvPqeed59bzzvHreeV497zyvnneeV3N+ew+8Gng18Irz23vg1cCrgVczfF54NS+vhvPb53l5Nc/Lq3leXg3nt8/z8mqel1fzvLya5z3/ap6H6768mie4bnDd4Lovr+YJrhtcN7juy6v/X3PdxXVfXg3nt8+zuO7iuu/6aji/fZ7FdRfXfddX82yuu7nuu76a553nNc87z2ued57XPO88r3neeV7zvPO85nnnec3zzvOa553nNc87z2u++9t/9kDO3/72/fv68PryunjdvJ739Xl4HbxevN685rqH6x6ue7ju4bqH616ue7nul1e/n/HLq8/r5PXh9X2/65dX87y8mufl1TzveTLzvLya5+XVPC+v5nnPk5nn5dU8L6+G89vnKa5bXLf599tct7luc93m329z3ea67/pqOL99nua6w3WHf7/DdYfrDtcd/v0O1x2uO3Djfd4+f/vbP6+D1++/34BX8a6vJt56cAJeBbyKd3018daDE/Aq3vXVxFsPTsAr9rcP+9uH/e0T8Ir97cP+9mF/+wS8Yn/7sL99Al6xv33Y3z7sb5+AV+xvH/a3D/vbJ+AV+9uH/e0Tm+turru57lsPTmyum1w3ue5bD04k102u+9aDE+95fRPveX0T73l9E8nv6n1+NZzfPpzfPpzfPuxvH85vH85vH85vn3j7g8P57cP57ROX616ue7nu5fu9XPdy3ct1L9/v5brFdYvfVXHd4rrFdYvvt7hucd3iusX321y3uW7zu2qu21y3uW7zu2qu21y3ue7wuxquO1x3+F29/cGJtz84Mfyuht/V8LuCV+vtD856+4Oz3v7grLc/OOxvH/a3D+e3D+e3D/vbh/3tw/ntw/ntw/72WW9/cDi/fdjfPuxvH85vH85vH/a3D/vbh/Pbh/Pbh/3tsxbXffuDs+AV+9uH/e3D/vZZ8Ir97cP+9mF/+yx4xf72YX/7LHjF/vZhf/uwv30WvGJ/+7C/fdjfPgtesb992N8+6+0Pznr7g7Pe/uCstz846+0Pznr7g7Pe/uCstz846+0P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WMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYw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UseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSx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0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQs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61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuX3wQlsoo7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWH4fnMAmhk3UsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyO5ffBCWyijmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCy/D05gE8Mm6lhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lh+H5zAJupYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbH8vvgBDYxbKKOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsfw+OIFN1LE8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy++DE9jEsIk6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqW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TVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1ic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bKKO5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ffBCWyijuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5X//xwcnsIk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNj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LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvq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OpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6l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fsfycSzf1zwFv2P5OJbva55CeQrtKXhPbO+J7T2xvSe298T2ntjeE9t7YntPbO+J7T2xvSe298T2ntjeE9t7YntPbO+J7T2xvSe298T2ntjeE9t7YntPbO+J7T2xvSe298T2ntjeE9t7YntPbO+J7T2xvSe298T2ntjeE9t7YntPbO+J7T2xvSe298T2ntjeE9t7YntPvN4Tr/fE6z3xek+83hOv98TrPfF6T7zeE6/3xOs98XpPvN4Tr/fE6z3xek+83hOv98TrPfF6T7zeE6/3xOs98bo7X3fn6+583Z2vu/N1d77uztfd+bo7X3fn6+583Z2vu/N1d77uztfd+bo7X3fn6+583Z2vu/N1d77uztfd+bo7X3fn6+583Z3/HMt/D07QTtBO4Hcs1+9Yrt+xXL9juX7Hcv2O5fody/U7lut3LNfvWK7fsVy/Y/k4lu9r/iZefxPH38TxN3H8TZz0tfK19rXra+Nr62v2YO3B2oO1B2sP1h6sp7CewnoK6ymsp/A8hecpPE/heQrPU3iewvMUnqfwPIXHKXwcy99r47/F+TiW72vpa+Vr7WvX18bX1tc4hfGeON4Tx3vieE8c74njPXG8J473xPGeON4Tx3vieE8c74njPXG8J473xPGeON4Tx3vieE8c74njPXG8J473xPGeON4Tx3vieE8c74njPXG8J473xPGeON4Tx3vieE8c74njPXG8J473xPGeON4Tx3vieE8c74njPXG8J473xPGeON4Tx3vieE8c74njPXG8J473xPGeON4Tx3vieE8c74njPXG8J473xPGeOO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O4+487s7j7jzuzuPuPO7O6+687s7r7vznWP57KB/ah+vD+MDfwnpPXO+J6z1xvSeu98T1nrjeE9d74npPXO+J6z1xvSeu98T1nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+nrh+77x+77x+77x+77x+77x+77x+77x+77x+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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use jwt::JWT;\nuse std::hash::pedersen_hash;\n\n// Max length of the signed JWT data (header.payload in base64)\nglobal MAX_DATA_LENGTH: u32 = 1024;\n// Max email length (e.g., \"alice@example.com\")\nglobal MAX_EMAIL_LENGTH: u32 = 64;\n// Merkle tree depth (supports 2^20 = 1M users)\nglobal TREE_DEPTH: u32 = 20;\n\n/// Compute Pedersen hash of email bytes (1 byte = 1 Field)\nfn hash_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> Field {\n    let storage = email.storage();\n    let mut fields: [Field; MAX_EMAIL_LENGTH] = [0; MAX_EMAIL_LENGTH];\n    for i in 0..MAX_EMAIL_LENGTH {\n        fields[i] = storage[i] as Field;\n    }\n    pedersen_hash(fields)\n}\n\n/// Compute leaf hash: pedersen(email_hash, amount, salt)\nfn compute_leaf(email_hash: Field, amount: Field, salt: Field) -> Field {\n    pedersen_hash([email_hash, amount, salt])\n}\n\n/// Verify Merkle proof and return computed root\nfn verify_merkle_proof(\n    leaf: Field,\n    siblings: [Field; TREE_DEPTH],\n    path_indices: [Field; TREE_DEPTH],\n) -> Field {\n    let mut current = leaf;\n    for i in 0..TREE_DEPTH {\n        let sibling = siblings[i];\n        let is_right = path_indices[i];\n        // If is_right == 1, current is on right, so hash(sibling, current)\n        // If is_right == 0, current is on left, so hash(current, sibling)\n        let left = if is_right == 1 { sibling } else { current };\n        let right = if is_right == 1 { current } else { sibling };\n        current = pedersen_hash([left, right]);\n    }\n    current\n}\n\n/// Compute secret hash from secret code field\n/// The secret is already converted to Field by the prover (frontend)\n/// Secret = Pedersen hash of 8-char alphanumeric code\nfn hash_secret(secret: Field) -> Field {\n    pedersen_hash([secret])\n}\n\n/// Compute IdentityCommitment = Pedersen(emailHash, secretHash)\n/// This creates an unlinkable identity - same email with different secrets\n/// produces completely different commitments\nfn compute_identity_commitment(email_hash: Field, secret_hash: Field) -> Field {\n    pedersen_hash([email_hash, secret_hash])\n}\n\nfn main(\n    // Private inputs - JWT data\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    expected_email: BoundedVec<u8, MAX_EMAIL_LENGTH>,\n    // Private inputs - Merkle proof\n    salt: Field,\n    amount: Field,\n    merkle_siblings: [Field; TREE_DEPTH],\n    merkle_path_indices: [Field; TREE_DEPTH],\n    // Private input - recipient (returned as public output)\n    recipient: Field,\n    // Private input - Secret code (ADR-012: for unlinkable identity)\n    secret: Field,\n    // Public inputs\n    pubkey_modulus_limbs: pub [u128; 18],\n    merkle_root: pub Field,\n) -> pub (Field, Field) {\n    // 1. Initialize and verify the JWT\n    let jwt: JWT<MAX_DATA_LENGTH> = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n    jwt.verify();\n\n    // 2. Verify the email claim in JWT matches private expected_email\n    jwt.assert_claim_string(\"email\".as_bytes(), expected_email);\n\n    // 3. Compute email hash (intermediate value, NOT exposed publicly)\n    let email_hash = hash_email(expected_email);\n\n    // 4. Compute secret hash (ADR-012)\n    let secret_hash = hash_secret(secret);\n\n    // 5. Compute IdentityCommitment (ADR-012)\n    // This replaces the raw email_hash as the public identity\n    // Same email + different secret = different identity (unlinkability)\n    let identity_commitment = compute_identity_commitment(email_hash, secret_hash);\n\n    // 6. Compute leaf from identity_commitment, amount, salt\n    // Note: Leaf now uses identity_commitment instead of email_hash\n    let leaf = compute_leaf(identity_commitment, amount, salt);\n\n    // 7. Verify Merkle proof - computed root must match public merkle_root\n    let computed_root = verify_merkle_proof(leaf, merkle_siblings, merkle_path_indices);\n    assert(computed_root == merkle_root, \"Merkle proof verification failed\");\n\n    // 8. Return identity_commitment and recipient as public outputs\n    // identity_commitment replaces email_hash (ADR-012 privacy upgrade)\n    // Contract verifies msg.sender == recipient to prevent front-running\n    (identity_commitment, recipient)\n}\n\n#[test]\nfn test_hash_email() {\n    // Test with a simple email\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"test@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    let hash = hash_email(email);\n    // Just check it doesn't panic\n    assert(hash != 0);\n}\n\n#[test]\nfn test_hash_secret() {\n    // Test that secret hashing works\n    let secret: Field = 12345678; // Simulated secret code as Field\n    let hash = hash_secret(secret);\n    assert(hash != 0);\n    assert(hash != secret); // Hash should differ from input\n}\n\n#[test]\nfn test_identity_commitment() {\n    // Test that identity commitment is computed correctly\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"alice@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    \n    let email_hash = hash_email(email);\n    let secret: Field = 98765432;\n    let secret_hash = hash_secret(secret);\n    \n    let commitment = compute_identity_commitment(email_hash, secret_hash);\n    assert(commitment != 0);\n    assert(commitment != email_hash); // Commitment should differ from email_hash\n}\n\n#[test]\nfn test_identity_unlinkability() {\n    // CRITICAL TEST: Same email with different secrets = different commitments\n    // This proves the unlinkability property of ADR-012\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"bob@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    \n    let email_hash = hash_email(email);\n    \n    // Two different secrets\n    let secret1: Field = 11111111;\n    let secret2: Field = 22222222;\n    \n    let secret_hash1 = hash_secret(secret1);\n    let secret_hash2 = hash_secret(secret2);\n    \n    let commitment1 = compute_identity_commitment(email_hash, secret_hash1);\n    let commitment2 = compute_identity_commitment(email_hash, secret_hash2);\n    \n    // MUST be different - this is the core privacy property\n    assert(commitment1 != commitment2, \"Unlinkability failed: same email with different secrets must produce different commitments\");\n}\n","path":"/Users/yaman/dev/zarf/zarf/circuits/src/main.nr"},"52":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/yaman/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/lib.nr"},"55":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"56":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"95":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"98":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"99":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"102":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"110":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"139":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr"},"142":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/yaman/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"158":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"159":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"}},"expression_width":{"Bounded":{"width":4}}}