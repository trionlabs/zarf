{"noir_version":"1.0.0-beta.17+0d6984c7c643b690e6559351f0cb36ce62b44b26","hash":"6787415508738813201","abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":1024,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"expected_email","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_path_indices","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"unlock_time","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2707472466662157409":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"6587586420081008171":{"error_kind":"string","string":"Merkle proof verification failed"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"8784292831194001448":{"error_kind":"string","string":"data length is too long"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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K1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15epKra5sPrOYm/a5unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytXl15V7N3yurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV66uXF25unJ15erK1ZWrK1dXrq5cXbm6cnXl6srVlasrV1eurlxdubpydeXqytWVqytXV2p1FVf9nAZ1J+tqEcX6rFls6g5taxHF+4Ty09Mb/vLyp0P5FIafCOVnQPlE/PKbhPJnpFf+uFB+JpSPP/75tUL5M9MqXxCV/s//a/3Pf0eV//+/FFfVUQvqS2F8orIqXwx/C/Mk1F2SXlsTCVNfFK1Y7jEL9ZeYtqS4bCUSpr4wPDt+YT0L41ea1vAKlk/rUmd4WGdoT5jWtZ0s1FVW9e8iUlft5UNf2c+rQhXOMOyyETJsL/4tTJ/C//nvktKV247TNkF+hnrt37B/s+Me5k8YThGUmw7tuaZ05XEphizfKRvWswLju5WvKDe/qs7yaNXlL7SxPPLnF/7uLXclYvy9dSDhZKGuPPM3b9i43KDJM9Mh+AVV455cRo6rmiZlpkwUZT6vse3Fpu2hfCH8fqYx+HsxjEtk6kh+ToMc/cKqcc2sX4uiulAuivx1vMhpf3L87jPLrx336pbf4DvA8vugWX5x2GG6l0erzgfbRpzf+c7f7Dz1hhOmbZp9eInXz4RPyEpNu6No5WUPxwE/2K7k8j4Jlnfr7DBxupWazNt2prueYF3hXRyZLa/5f5VFq64j2KcuNstkKWReXxLaUWD8JrBMvkzqjCJ/2QrLudfPYln8d55j7fapNoyLXXbseAS71PQTZVAm034i1FXutKeYtD2UP8hpu93O4DoRPjjcMM28fZDIZOHfpU49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","debug_symbols":"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h+dXh+ftl/XV5fnV5fnV5Xn7ZX11eX51ed5+6Q9e+oOX/uClP3jpD176g5f+4KU/eOkPXvqDl/7gpT94qQcvvLrw6sKrSz144dWFVxdeXZ5fXXh14dWlHrzw6sKrC68u9eCFVxdeXXh1ed5+4dWFV5d68MKrC68uvLrUgxdeXXh14dXl+dWFVxdecX57cX57XdZXl/UV57cX57fXZX11WV9xfntd6sHL+urSH7z0By/9wUt/8NIfvPQHL/3BS3/w0h+89Acv/UHOby/Ob68Lry684vz24vz2uvDqwivOb68Lry684vz24vz2uvDqwivOby/Ob68Lry684vz2uvDqwqvL8/YLry68uvCqeN5e8KrgVcGr4nl7wauCV5zfXsXz9mJ9VayvOL+9iuftxfqqWF8Vz9uL5+3F+qroDxb9waI/WPQHi/5g0R8s+oNFf7DoDxb9waI/yPntVfCq4FXBK85vr4JXBa8KXhXPrwpeFbzi/PYqeFXwquAV57dXwauCVwWviudXBa8KXhXP2wteFbwqeFU8by94VfCq4FXxvL3gVcErzm+v4vlVsb4q1lec317F86tifVWsr4rn7cXzq2J9VfQHi/5g0R8s+oNFf7DoDxb9waI/WPQHi/5g0R/k/PYqeFXwquAV57dXwauCVwWviv5gwauCV5zfXgWvCl4VvOL89mp41fCq4VXTH2x41fCq6Q82vGp41fCq6Q82vGp41fCq6Q82vGp4xfnt1Txvb9ZXzfqK89ured7erK+a9VXzvL153t6sr5r+YNMfbPqDTX+w6Q82/cGmP9j0B5v+YNMfbPqDnN9eDa8aXjW84vz2anjV8KrhVfO8veFVwyvOb6+GVw2vGl5xfns1vGp41fCq6Q82vGp41fQHG141vGp41fQHG141vGp41fQHG141vOL89mr6g836qllfcX57Nf3BZn3VrK+a/mDTH2zWV01/sOkPNv3Bpj/Y9Aeb/mDTH2z6g01/sOkPfve3f1/zeeFVw6uGV5zfXg2vBl4NvJp33kQNvBp4xfntNfBq4NXAK85vr4FXA68GXk1wXXg18GroDw68Gng18GroDw68Gng18GroDw68GnjF+e019AeH9dWwvuL89hr6g8P6alhfDf3BoT84rK+++9t/f2N/+9t/X+fD6+D14vXLyb/z2z+vX05+97d/Xxevm9d8Xng18GrgFee318CrgVcDr+bweeHVwCvOb6+BVwOvBl5xfnsNvBp4NfBqLteFVwOvprguvBp4NfBqiuvCq4FXA6+muC68GnjF+e01zXVZXw3rK85vr2muy/pqWF/NcN3huqyvvvvbP7+xd55XzTvPq4b+4NAfHPqD8/YH+3nnefXzzvPq553n1c87z6s5v72fl1f9vLzq5+VVc357Py+v+nl51c/Lq37eeRP9vLzq5+VVc357P8F1g+u+vPr/NdddXHdx3ZdX/Syuu7juy6t+FtddXHdx3ZdX/Wyuu7nu5rovr/rZXHdz3ZdXzfnt/Wyuu7nuu75qzm/vJ7luct13fdVPct3kuu/6qp93nlc/7zyvft55Xv2887z6eed59fPO8+rnnefVzzvPq593nlc/7zyvft55Xs357f1cPu/Lq35eXjXnt/dz+bwvr/p5edXP5fO+vOrn5VVzfns/xXWL6768as5v76e4bnHdl1f9FNctrvvyqp/mus11m+s2/36b6zbXba7b/Pttrjtc9+VVc357P8N1h+sO/36H6w7XHa77rq863vNk/n8dvF68/sfJjneeV8c7z6vjnefV8c7z6njneXW887w63nleHe88r453nlfHO8+rOb+9A14FvAp4xfntHfAq4FXAq1h8XngV8Irz2zvgVcCrgFec394BrwJeBbyKzXXhVcCr2FwXXgW8CngVyXXhVcCrgFeRXBdeBbzi/PaO5LrJdd/1VXN+e8fhuofrvuurjsN1D9d911cd7zyvjneeV8c7z6vjnefV8c7z6njneXW887w63nleHe88r453nld/97f/7IHsv/3t++d1PbwOXi9eb14nrw+vL6+L181rrttct7luc93mus11m+s21/3y6vczfnn1eT3v6+/zq8/rl5MBrwJeBbyK9zyZDngV8CrgVbznyfSCVwtecX57r3f/VS/WV4v1Fee393r3X/VifbVYX63gusF1WV9xfnsveLXg1YJXnN/eC14teLXg1VpcF14teLXe5+39t7/98/ry+v33u+DVYn213nqwF7xa8GqxvlpvPdgLXi3WV+utB3vBK/a3N/vbm/3tveAV+9ub/e3N/vZe8Ir97c3+9l7wiv3tzf72Zn97L3jF/vZmf3uzv70XvGJ/e7O/vRfrK/a3N/vbm/3tvVhfsb+92d/e7G/vxfqK/e3N/vZe73l9vd7z+nq9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RyY6jyWPzxOPzxOPPZbrOvH6PPH6PPHaY7muE6/PE689lmvf+dp3vvadr33na9/52ne+9p2vfedr3/nad772na9952vtfGXilYlXJl5r5ysTr0y8MvH6PPHKxCsTr7XzlYlXJl6ZeK2dr0y8MvHKxGuP5crEKxOvtfOViVcmXpl4rZ2vTLwy8crE6/PEKxOvTHQeSzqPJa/rxOs60Xks6TyWvK4Tr+tE57HktXa+rhOvfedr3/nad772na9952vf+dp3vvadr33na9/52nd2Hks6jyWvTLwy0Xks6TyWvDLxykTnseSViVcmOo8lnceSVyZemeg8lnQeS16ZeGWi81jyysQrE689lisTr0y8MrHssZRMLJlYMrHssZRMLJnoPJYseyzlOrFcJzqPJcseS7lOLNeJZY+l7LGU68Sy71z2ncu+c9l3LvvOZd+57DuXfeey71z2ncu+s/NYsmRiycSSic5jyZKJJRNLJpbPE0smlkx0HkuWTCyZWDLReSxZMrFkYsnE8nliycSSiWWPpWRiycSSiWWPpWRiycSSiWWPpWRiyUTnsWT5PLFcJ5brROexZPk8sVwnluvEssdSPk8s14ll37nsO5d957LvXPady75z2Xcu+85l37nsO5d9Z+exZMnEkoklE53HkiUTSyaWTCz7ziUTSyY6jyVLJpZMLJnoPJZsmdgysWVi23dumdgyse07t0xsmdgyse07t0xsmdgyse07t0xsmeg8lmx7LO06sV0nOo8l2x5Lu05s14ltj6XtsbTrxLbv3Pad275z23du+85t37ntO7d957bv3Pad276z81iyZWLLxJaJzmPJloktE1smtj2WloktE53Hki0TWya2THQeS7ZMbJnYMrHtO7dMbJnY9p1bJrZMbJnY9p1bJrZMbJnY9p1bJrZMdB5Ltn3ndp3YrhOdx5Jt37ldJ7brxLbv3Pad23Vi23du+85t37ntO7d957bv3Pad275z23du+87fHMuf8B7IxJaJLROdx5ItE0cmjkwcZlTlyMSRic5jyZGJIxNHJjqPJUcmjkwcmTihA5k4MnHsO49MHJk4MnHsO49MHJk4MnHsO49MHJnoPJYc+87jOnFcJzqPJce+87hOHNeJY9957DuP68RvjuXzs/zLsXxEPopQLAVU/pvH8hVQ+Ztj+ROlaIX3QCaOTByZ6DyWHJk4MnFk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mGMJcyxhjiXMsYQ5ljDHEuZYwhzL/0IHMtEcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hjCXMsYY4lzLGEOZYwxxLmWMIcS5hj+fnfuKhMXDLRHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS5ljCHEuYYwlzLGGOJcyxhDmWMMcS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Y0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhS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WErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbS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LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtj+X1wApuoY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqW3wcnsIlhE3UsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8dydSxXx3J1LFfHcnUsV8cyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGM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5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5X0cy/35e1gf/k1w49/DXxO/D8eH8OHfBDf/HsqH9uH6MD6sD4+HvyZ+H44P4YMTXCe4TnCd4DrBdYLrBOME4wTjBOME4wTjBOME4wTjBOME6wTrBOsE6wTrBOsE6wTrBOsE6wTPCZ4TPCd4TvCc4DnBc4LnBM8JHhN8HMv34fgQPqQP5UP7cH0YH9YHJzhOcJzgOMFxguMExwmOExwnOE5wnCCcIJwgnCCcIJwgnCCcIJwgnCCcIJ0gnSCdIJ0gnSCdIJ0gnSCdIJ2gnKCcoJygnKCcoJygnKCcoJygnKCdoJ2gncAmPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4/r+J+fPz/03838PxIXxIH8qH9uH6MD6sD05wnOA4wXGC4wTHCY4THCc4TnCc4DhBOEE4QThBOEE4QThBOEE4QThBOEE6QTpBOkE6QTpBOkE6QTpBOkE6QTlBOUE5QTlBOUE5QTlBOUE5QTlBO0E7QTtBO0E7QTtBO0E7QTtBO8F1gusE1wmuE1wnuE5wneA6wXWC6wTjBOME4wTjBOME4wTjBOME4wTjBOsE6wTrBOsE6wTrBOsE6wTrBOsEzwmeEzwneE7wnOA5wXOC5wTPCWzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFt4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4rWJ1yZem3ht4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3is4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6b+Gzis4nPJj6bqGM5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2P5fXACm6hjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2P53//xwQlsoo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXo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1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUs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S+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSz9cSz7+cm/Cfb+Pfyb4H1+8m+Cl38P77+H+3Es34fjQ/iQPpQP7cP1YXxYH5zgOMFxguMExwmOExwnOE5wnOA4wXGCcIJwgnCCcIJwgnCCcIJwgnCCcIJ0gnSCdIJ0gnSCdIJ0gnSCdIJ0gnKCcoJygnKCcoJygnKCcoJygr8mvvr38NfEf7+w9+NYPq/9NfH7WvqaE/w18fva9TUn+Gvi97XHa9f/Bn9N/Lz218Tva/43+Gvi97X2Nf8b/DXx+9r6mqfw18TPa39N/Lw2nsJfE7+vla95Cn9N/L42vuYpjKewnsJ6CusprKewnsJ6CusprKewnsJ6Cs9TeJ7C8xSep/A8hecpPE/heQrPU7CJH8fy99rHsfy9dmzix7F8Xytfa1+7vja+tr7GKXwcy+c1m/hxLN/X0tfK19rXrq+Nr62vcQrHJn4cy+e1CF9LXytfa1+7vja+tr7mKaSnkJ6CTfw4lu9rnoJN/DiW72uegk38OJbPa+Up2MSPY/m+5inYxI9j+b7mKdjEj2P5vuYptKfQnkJ7Cu0ptKfQnkJ7Cu0ptKfQnsL1FK6ncD2F6ylcT+F6CtdT+NfE/Pn5e1gfHg//mvjfw/EhfEgfyof24frgBOME4wTrBOsE6wTrBOsE6wTrBOsE6wTrBM8JnhM8J3hO8JzgOcFzgucEzwkev4nhPfHjWP6O8eNYvq+lr5Wvta9dXxtfW1/jN/HjWD6vHX4Tw3vix7F8Xytfa1+7vja+tr5GDz6O5fOa98SPY/m+lr5Wvta+dn1tfG19zVPwnvhxLJ/X0lPwnvhxLN/XPAXviR/H8n3NU/Ce+HEsn9fKU/Ce+HEs39c8Be+JH8fyfc1T8J4Y3hPDe2J4TwzvieE9MbwnhvfE8J4Y3hPDe2J4TwzvieE9MbwnhvfE8J4Y3hPDe2J4TwzvieE9MbwnhvfE8J4Y3hPDe2J4TwzvieE9MbwnhvfE8J4Y3hPDe2J4TwzvieE9MbwnhvfE8J4Y3hPDe2J4TwzvieE9MbwnhvfE8J4Y3hPDe2J4T0zviek9Mb0npvfE9J6Y3hPTe2J6T0zviek9Mb0npvfE9J6Y3hPTe2J6T0zviek9Mb0n/jmWz/+T+HMs/z0cH8KH9KF8aB+uD+PD+uAE6QTpBOkE6QTpBOkE6QTpBOkE6QTlBOUE5QTlBOUE5QTlBOUE5QTlBO0E7W9i+5vY/ia2v4ntb2L7m9j+Jra/ie1v4vU38fqbeP1NvP4mXn8Tr7+J19/E62/i9Tfx0oOPY/m8NvTg41i+r6Wvla+1r11fG19bX7MHaw/WU1hPYT2F9RTWU1hPYT2F9RTWU3iewvMUnqfwPIXnKTxP4XkKz1N4noL3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5b3xPKeWN4Ty3tieU8s74nlPbG8J5a7c7k7l7tzuTuXu3O5O5e7c7k7l7tzuTuXu3O5O5e7c7k7l7tzuTuXu3O5O5e7c7k7l7tzuTuXu3O5O5e7c7k7l7tzuTv/OZbPw59j+e/h+BA+8JvYfsfycSx/x/hxLN/XxtfW1/hNbL9j+TiWz2snfC19rXytfe362vja+hq/iR/H8nkt6EH7HcvHsXxfK19rX7u+Nr62vkYPPo7l85rfsXwcy/c1T8HvWD6O5fuap+B3LB/H8n3NU/A7lo9j+bxWnoLfsXwcy/c1T8HvWD6O5fuap1CeQnsK3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hPbe2J7T2zvie09sb0ntvfE9p7Y3hOv98TrPfF6T7zeE6/3xOs98XpPvN4Tr/fE6z3xek+83hOv98TrPfF6T7zeE6/3xOs98XpPvN4Tr/fE6z3xek+87s7X3fm6O1935+vufN2dr7vzdXe+7s7X3fm6O1935+vufN2dr7vzdXe+7s7X3fm6O1935+vufN2dr7vzdXe+7s7X3fm6O1935z/H8t+DE7QTtBP4Hcv1O5brdyzX71iu37Fcv2O5fsdy/Y7l+h3L9TuW63cs1+9YPo7l+5q/idffxPE3cfxNHH8TJ32tfK197fra+Nr6mj1Ye7D2YO3B2oO1B+sprKewnsJ6CuspPE/heQrPU3iewvMUnqfwPIXnKTxP4XEKH8fy99r4b3E+juX7Wvpa+Vr72vW18bX1NU5hvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeO98TxnjjeE8d74nhPHO+J4z1xvCeOu/O4O4+787g7j7vzuDuPu/O4O4+787g7j7vzuDuPu/O4O4+787g7j7vzuDuPu/O4O4+787g7j7vzuDuPu/O6O6+787o7/zmW/x7Kh/bh+jA+8Lew3hPXe+J6T1zvies9cb0nrvfE9Z643hPXe+J6T1zvies9cb0nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrp8nrt87r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987r987P793fn7v/Pze+fm98/N75+f3zs/vnZ/fOz+/d35+7/z83vn5vfPze+fn987P752f3zs/v3d+fu/8/N75+e8Tn/8+8fnvE5//PvH57xOf/z7x+e8Tn/8+8fnvE5+783N3fu7Oz935uTs/d+fn7vzcnZ+783N3fu7Oz935uTs/d+fn7vzcnZ+783N3fu7Oz935uTs/d+fn7vzcnZ+783N3fu7Of47lvwcnaCdoJ2gnuE7g7vzcnZ+783N3fu7Oz935uTs/d+fn7vzcnZ+783N3fu7Oz935uTs/d+fn7vzcnZ+783N3fu7Oz935uTs/d+fn7vzcnZ+783N3fu7Oz935uTs/d+fn7vzcnZ+783N31rFcHct97M7zw+48Opb5YXeeH3bn0bHMD7vz/LA7j45lftid54fdeXQs88PuPD/szqNjmR925/lhdx4dy/ywO88Pu/PoWOaH3Xl+2J1HxzI/7M7zw+48Opb5YXeeH3bn0bHMT3gK6Smkp5CeQnoK6Smkp5CeQnoK6Smkp1CeQnkK5SmUp1CeQnkK5SmUp1CeQnkK7Sm0p9CeQnsK7Sm0p9CeQnsK7Sm0p3A9hespXE/hegrXU7iewvUUrqdwPYXrKYynMJ7CeArjKYynMJ7CeArjKYynMJ7CegrszvPD7jw/7M7zw+48P+zO88PuPD/szvPD7jw/7M7zw+48P88JnhM8J3hO8JzgOcFzgucE7M5z2J3nsDvPYXeew+48h915DrvzHHbnOezO8+dY/ntwguMExwmOExwnYHeew+48h915DrvzHHbnOezOc9id57A7z2F3nsPuPIfdeQ678xx25znsznPYnX8f+Fs47M5z2J3nsDvPYXeew+48h915DrvzHHbnOezOc9id57A7z2F3nsPuPIfdeU55CuUplKdQnkJ5CuUptKfQnkJ7Cu0ptKfQnkJ7Cu0ptKfQnsL1FK6ncD2F6ylcT+F6CtdTuJ7C9RSupzCewngK4ymMpzCewngK4ymMpzCewngK6ymsp7CewnoK6ymsp7CewnoK6ymsp/A8hecpPE/heQrPU3iewvMUnqfwPAV25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wl25wls30R4CukppKeQnkJ6CuzOE+zOE+zOE+zOE+zOE+zOE+zOE+zOE+zOE+zOE+UE5QTlBOUE5QTlBO0E7QTtBO0E7QTtBO0E7QTtBO0E1wmuE1wnuE5wneA6wXWC69/C9W/h+rcw/i2Mfwvj38L4tzD+LYx/C+Pfwvi3MP4tjH8L69/C+rew/i2sfwvr38L6t7D+Lax/C+vfwvq38PxbeP4tPP8Wnn8LzyI9i/Qs0vMUnqfg7pzuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzununO7OOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LJPuzununO7O6e6c7s7p7pzuzununO7O6e6c7s7p7pzuzuXuXO7O5e5c7s7l7lzuzuXuXO7O5e5c7s7l7lzuzuXuXO7Of47lvwcnOE5wnOA4wXECd2cdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L/zX1RruyLLty3b/oeT9Ukswk6V8xBEGSZUPAhSRcSwYM4/671ypGVo+XA8RZc3dzz9EVu6MqYzHZY0n2WJI9lmSPJdljSfZYkj2WZI8l2WNJ9liSPZZkjyXZY0n2WJI9lmSPJdljSfZYkj2WZI8l2WNJ9liSPZZkjyXZY0n2WJI9lmSPJdljSfZYkj2WZI8l2WPJYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5Oyk4KTgpOCk4KTgpMDtvZufN7LyZnTez82Z23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5MztvZufN7LwPJzic4HCC5ATJCZITMDtvZufN7LyZnTez82Z23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5MztvZufN7LyZnTez82Z23szOm9l5MztvZufN7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZufD7HyYnQ+z82F2PszOh9n5MDsfZudTpFCkUKTQpNCk0KTA7HyYnQ+z82F2PszOh9n5MDsns3MyOyezczI7J7NzMjsns3MyOyezczI7J7NzMjsns3MyOyezczI7J7NzMjsns3MyO6dxAuMExgmMExgnME5gnICeyB5LsseS7LEkeyzJHkuyx5LssSR7LMkeS7LHkuyxJHssyR5LsseS7LEkeyzJHkuyx5LssSR7LMkeS7LHkuyxJHssyR5LsseS7LEkeyzJHkuyx5LssSR7LMkeS7LHkuyxJHssyR5LsseS7LEkeyzJHkuyx5LssSR7LMkeS7LHkuyxZNITk56Y9MSkJyY9MemJSU9MemLSE5OemPTEpCcmPTHpiUlPTHpi0hOTnphNCk0KTQpNCk0KTQroO2eh75yFvnMW+s5Z6Dtnoe+chb5zFvrOWeg7J3ssyR5LsseS7LEkeyzJHkuyx5LssSR7LMkeS7LHkuyxJHssyR5LsseS7LEkeyzJHkuyx5LssSR7LMkeS7LHkuyxJHssyR5LsseS7LEkeyzJHkuyx5LssSR7LMkeS7LHkuyxJHssyR5LsseSxexczM7F7FzMzsXsXMzOxexczM7F7FzMzsXsXMzOxexczM7F7FzMzsXsXMzOxexczM7F7FzMzsXsXMzOxexczM6VnCA5QXKC5ATJCZITJCcoTkBPLHpi0ROLnlj0xKInFj2x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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use jwt::JWT;\nuse std::hash::pedersen_hash;\n\n// Max length of the signed JWT data (header.payload in base64)\nglobal MAX_DATA_LENGTH: u32 = 1024;\n// Max email length (e.g., \"alice@example.com\")\nglobal MAX_EMAIL_LENGTH: u32 = 64;\n// Merkle tree depth (supports 2^20 = 1M users)\nglobal TREE_DEPTH: u32 = 20;\n\n/// Compute Pedersen hash of email bytes (1 byte = 1 Field)\nfn hash_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> Field {\n    let storage = email.storage();\n    let mut fields: [Field; MAX_EMAIL_LENGTH] = [0; MAX_EMAIL_LENGTH];\n    for i in 0..MAX_EMAIL_LENGTH {\n        fields[i] = storage[i] as Field;\n    }\n    pedersen_hash(fields)\n}\n\n/// Compute leaf hash: pedersen(identity_commitment, amount, unlock_time)\nfn compute_leaf(identity_commitment: Field, amount: Field, unlock_time: Field) -> Field {\n    pedersen_hash([identity_commitment, amount, unlock_time])\n}\n\n/// Verify Merkle proof and return computed root\nfn verify_merkle_proof(\n    leaf: Field,\n    siblings: [Field; TREE_DEPTH],\n    path_indices: [Field; TREE_DEPTH],\n) -> Field {\n    let mut current = leaf;\n    for i in 0..TREE_DEPTH {\n        let sibling = siblings[i];\n        let is_right = path_indices[i];\n        // If is_right == 1, current is on right, so hash(sibling, current)\n        // If is_right == 0, current is on left, so hash(current, sibling)\n        let left = if is_right == 1 { sibling } else { current };\n        let right = if is_right == 1 { current } else { sibling };\n        current = pedersen_hash([left, right]);\n    }\n    current\n}\n\n/// Compute secret hash from secret code field\n/// The secret is already converted to Field by the prover (frontend)\n/// Secret = Pedersen hash of 8-char alphanumeric code\nfn hash_secret(secret: Field) -> Field {\n    pedersen_hash([secret])\n}\n\n/// Compute IdentityCommitment = Pedersen(emailHash, secretHash)\n/// This creates an unlinkable identity - same email with different secrets\n/// produces completely different commitments\nfn compute_identity_commitment(email_hash: Field, secret_hash: Field) -> Field {\n    pedersen_hash([email_hash, secret_hash])\n}\n\nfn main(\n    // Private inputs - JWT data\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    expected_email: BoundedVec<u8, MAX_EMAIL_LENGTH>,\n    // Private inputs - Merkle proof\n    amount: Field,\n    merkle_siblings: [Field; TREE_DEPTH],\n    merkle_path_indices: [Field; TREE_DEPTH],\n    // Private input - recipient (returned as public output)\n    recipient: Field,\n    // Private input - Secret code (ADR-012: for unlinkable identity)\n    secret: Field,\n    // Public inputs\n    pubkey_modulus_limbs: pub [u128; 18],\n    merkle_root: pub Field,\n    // New Public Input for Discrete Vesting (ADR-023)\n    unlock_time: pub Field,\n) -> pub (Field, Field, Field) {\n    // 1. Initialize and verify the JWT\n    let jwt: JWT<MAX_DATA_LENGTH> = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n    jwt.verify();\n\n    // 2. Verify the email claim in JWT matches private expected_email\n    jwt.assert_claim_string(\"email\".as_bytes(), expected_email);\n\n    // 3. Compute email hash (intermediate value, NOT exposed publicly)\n    let email_hash = hash_email(expected_email);\n\n    // 4. Compute secret hash (ADR-012)\n    let secret_hash = hash_secret(secret);\n\n    // 5. Compute IdentityCommitment (ADR-012)\n    // This replaces the raw email_hash as the public identity\n    // Same email + different secret = different identity (unlinkability)\n    let identity_commitment = compute_identity_commitment(email_hash, secret_hash);\n\n    // 6. Compute leaf from identity_commitment, amount AND unlock_time (ADR-023)\n    // Note: Leaf now uses identity_commitment instead of email_hash\n    // REFACTOR: Added unlock_time to bind vesting schedule to the leaf\n    let leaf = compute_leaf(identity_commitment, amount, unlock_time);\n\n    // 7. Verify Merkle proof - computed root must match public merkle_root\n    let computed_root = verify_merkle_proof(leaf, merkle_siblings, merkle_path_indices);\n    assert(computed_root == merkle_root, \"Merkle proof verification failed\");\n\n    // 8. Return identity_commitment, recipient AND amount as public outputs\n    // identity_commitment replaces email_hash (ADR-012 privacy upgrade)\n    // Contract verifies msg.sender == recipient to prevent front-running\n    // Contract needs amount to transfer tokens\n    (identity_commitment, recipient, amount)\n}\n\n#[test]\nfn test_hash_email() {\n    // Test with a simple email\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"test@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    let hash = hash_email(email);\n    // Just check it doesn't panic\n    assert(hash != 0);\n}\n\n#[test]\nfn test_hash_secret() {\n    // Test that secret hashing works\n    let secret: Field = 12345678; // Simulated secret code as Field\n    let hash = hash_secret(secret);\n    assert(hash != 0);\n    assert(hash != secret); // Hash should differ from input\n}\n\n#[test]\nfn test_identity_commitment() {\n    // Test that identity commitment is computed correctly\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"alice@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    \n    let email_hash = hash_email(email);\n    let secret: Field = 98765432;\n    let secret_hash = hash_secret(secret);\n    \n    let commitment = compute_identity_commitment(email_hash, secret_hash);\n    assert(commitment != 0);\n    assert(commitment != email_hash); // Commitment should differ from email_hash\n}\n\n#[test]\nfn test_identity_unlinkability() {\n    // CRITICAL TEST: Same email with different secrets = different commitments\n    // This proves the unlinkability property of ADR-012\n    let mut email: BoundedVec<u8, MAX_EMAIL_LENGTH> = BoundedVec::new();\n    let test_bytes = \"bob@example.com\".as_bytes();\n    for b in test_bytes {\n        email.push(b);\n    }\n    \n    let email_hash = hash_email(email);\n    \n    // Two different secrets\n    let secret1: Field = 11111111;\n    let secret2: Field = 22222222;\n    \n    let secret_hash1 = hash_secret(secret1);\n    let secret_hash2 = hash_secret(secret2);\n    \n    let commitment1 = compute_identity_commitment(email_hash, secret_hash1);\n    let commitment2 = compute_identity_commitment(email_hash, secret_hash2);\n    \n    // MUST be different - this is the core privacy property\n    assert(commitment1 != commitment2, \"Unlinkability failed: same email with different secrets must produce different commitments\");\n}\n","path":"/Users/yaman/dev/zarf/zarf/circuits/src/main.nr"},"52":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/yaman/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/lib.nr"},"55":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"56":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"95":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"98":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"99":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"102":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"110":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"139":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr"},"142":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/yaman/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"158":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"159":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/yaman/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"}},"expression_width":{"Bounded":{"width":4}}}