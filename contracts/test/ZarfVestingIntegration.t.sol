// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {ZarfVesting} from "../src/ZarfVesting.sol";
import {JWKRegistry} from "../src/JWKRegistry.sol";
import {HonkVerifier} from "../src/HonkVerifier.sol";
import {MockERC20} from "./mocks/MockERC20.sol";

/**
 * @title ZarfVestingIntegration
 * @notice Integration tests using real HonkVerifier with pre-generated proofs
 * @dev Test proof generated by poc/scripts/generateTestProof.js
 */
contract ZarfVestingIntegrationTest is Test {
    ZarfVesting public vesting;
    JWKRegistry public jwkRegistry;
    HonkVerifier public verifier;
    MockERC20 public token;

    address public owner = address(this);

    // Test data from fixtures/testProof.json
    bytes32 public merkleRoot;
    bytes32 public emailHash;
    address public recipient;

    uint256 public constant TOTAL_SUPPLY = 1_000_000 ether;
    uint256 public constant ALLOCATION = 1000;
    uint256 public constant CLIFF = 0;
    uint256 public constant VESTING_DURATION = 1;

    function setUp() public {
        string memory json = vm.readFile(_getFixturePath());

        merkleRoot = bytes32(vm.parseUint(vm.parseJsonString(json, ".testData.merkleRoot")));
        emailHash = bytes32(vm.parseUint(vm.parseJsonString(json, ".testData.emailHash")));
        recipient = vm.parseJsonAddress(json, ".testData.recipient");

        // Deploy JWK registry and register test pubkey
        jwkRegistry = new JWKRegistry();
        _registerTestPubkey();

        // Deploy real HonkVerifier
        verifier = new HonkVerifier();

        // Deploy token and vesting contract
        token = new MockERC20("Zarf Token", "ZARF", TOTAL_SUPPLY);
        vesting = new ZarfVesting("Integration Test", "Integration test vesting", address(token), address(verifier), address(jwkRegistry));

        // Setup vesting
        vesting.setMerkleRoot(merkleRoot);
        vesting.setAllocation(emailHash, ALLOCATION);

        // Deposit tokens
        token.approve(address(vesting), ALLOCATION);
        vesting.deposit(ALLOCATION);

        // Start vesting with discrete unlocks (1 second period for instant testing)
        vesting.startVesting(CLIFF, VESTING_DURATION, VESTING_DURATION);

        // Warp past vesting period
        vm.warp(block.timestamp + CLIFF + VESTING_DURATION + 1);
    }

    /// @dev Register the test pubkey from the generated proof
    function _registerTestPubkey() internal {
        bytes32[18] memory pubkeyLimbs = _getTestPubkeyLimbs();
        jwkRegistry.registerKey("test-key", pubkeyLimbs);
    }

    /**
     * @notice Test claiming with a real ZK proof
     * @dev This test uses a pre-generated proof from the circuit
     */
    function test_ClaimWithRealProof() public {
        // Load proof from fixture (generated by generateTestProof.js)
        bytes memory proof = _getTestProof();
        bytes32[] memory publicInputs = _getTestPublicInputs();

        // Verify public inputs structure
        // Layout: [pubkey[0..17], merkleRoot, emailHash, recipient]
        assertEq(publicInputs.length, 21, "Should have 21 public inputs");
        assertEq(publicInputs[18], merkleRoot, "Merkle root should match");
        assertEq(publicInputs[19], emailHash, "Email hash should match");
        assertEq(publicInputs[20], bytes32(uint256(uint160(recipient))), "Recipient should match");

        // Claim as recipient
        vm.prank(recipient);
        vesting.claim(proof, publicInputs);

        // Verify tokens transferred
        assertEq(token.balanceOf(recipient), ALLOCATION, "Recipient should receive tokens");
        assertEq(vesting.claimed(emailHash), ALLOCATION, "Claimed amount should be recorded");
    }

    /**
     * @notice Test that invalid proof fails verification
     */
    function test_RevertInvalidProof() public {
        bytes memory invalidProof = new bytes(100); // Invalid proof
        bytes32[] memory publicInputs = _getTestPublicInputs();

        vm.prank(recipient);
        // Verifier reverts with ProofLengthWrongWithLogN, which bubbles up as a revert
        vm.expectRevert();
        vesting.claim(invalidProof, publicInputs);
    }

    /**
     * @notice Test that proof with wrong merkle root fails
     */
    function test_RevertWrongMerkleRoot() public {
        bytes memory proof = _getTestProof();
        bytes32[] memory publicInputs = _getTestPublicInputs();

        // Modify merkle root in public inputs
        publicInputs[18] = bytes32(uint256(0xDEAD));

        vm.prank(recipient);
        // Will fail at verifier level (proof doesn't match modified inputs)
        vm.expectRevert();
        vesting.claim(proof, publicInputs);
    }

    /**
     * @notice Test that front-running is prevented
     */
    function test_RevertFrontRunning() public {
        bytes memory proof = _getTestProof();
        bytes32[] memory publicInputs = _getTestPublicInputs();

        // Attacker tries to use the proof (recipient doesn't match msg.sender)
        address attacker = address(0xBAD);
        vm.prank(attacker);
        vm.expectRevert(ZarfVesting.InvalidRecipient.selector);
        vesting.claim(proof, publicInputs);
    }

    /**
     * @notice Test that unregistered pubkey fails
     */
    function test_RevertUnregisteredPubkey() public {
        bytes memory proof = _getTestProof();
        bytes32[] memory publicInputs = _getTestPublicInputs();

        // Modify pubkey limbs to an unregistered key
        publicInputs[0] = bytes32(uint256(0xDEAD));

        vm.prank(recipient);
        // Will fail at verifier level (proof doesn't match modified inputs)
        vm.expectRevert();
        vesting.claim(proof, publicInputs);
    }

    // ============ Helper Functions ============

    /**
     * @dev Returns the test proof bytes from the JSON fixture
     */
    function _getTestProof() internal view returns (bytes memory) {
        string memory json = vm.readFile(_getFixturePath());
        return vm.parseBytes(vm.parseJsonString(json, ".proof"));
    }

    /**
     * @dev Returns the test public inputs array from the JSON fixture
     */
    function _getTestPublicInputs() internal view returns (bytes32[] memory) {
        string memory json = vm.readFile(_getFixturePath());
        return vm.parseJsonBytes32Array(json, ".publicInputs");
    }

    /**
     * @dev Helper to get public key limbs from the fixture for registration
     */
    function _getTestPubkeyLimbs() internal view returns (bytes32[18] memory limbs) {
        bytes32[] memory publicInputs = _getTestPublicInputs();
        for (uint256 i = 0; i < 18; i++) {
            limbs[i] = publicInputs[i];
        }
    }

    function _getFixturePath() internal view returns (string memory) {
        string memory root = vm.projectRoot();
        return string.concat(root, "/test/fixtures/testProof.json");
    }
}

